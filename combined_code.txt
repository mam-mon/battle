--- 代码合集生成于: 2025-09-02 17:44:08 ---
--- 根目录: C:\Users\User\Desktop\private\battle ---

================================================================================
### 文件路径: Buffs.py
================================================================================

from damage import DamagePacket, DamageType
from abc import ABC
import collections
from collections import defaultdict
from rich.console import Console, Group
from rich.live import Live
from rich.table import Table
from rich.panel import Panel
from rich.text import Text
import time
import random
from rich.text import Text
from rich.progress import BarColumn  # 可选：也可以直接用 Text
import math
from collections import Counter
#import pygame
import sys

class Buff(ABC):
    """通用 Buff/DeBuff 基类，所有状态继承此类。"""
    display_name     = None      # 界面显示名
    max_stacks       = 1         # 最大叠层数；1 表示不可叠加
    dispellable      = False     # 是否可被驱散
    duration         = None      # 持续秒数；None 或 0 表示无限
    hidden           = False     # 是否在界面隐藏
    is_debuff        = False     # 是否为负面状态
    priority         = 0         # 执行顺序，越大越先执行
    disable_attack   = False     # 是否禁止攻击（如眩晕、不灭二阶段）

    def __init__(self, stacks: int = 1, duration_override: float = None):
        self.stacks = min(stacks, self.max_stacks)
        self.remaining = duration_override if duration_override is not None else self.duration
        self._accum = 0.0

    def on_apply(self, wearer):
        """Buff 被添加到角色时触发"""
        pass

    def on_remove(self, wearer):
        """Buff 被移除时触发"""
        pass

    def on_tick(self, wearer, dt):
        """
        每帧或定时触发，用于持续性效果。
        返回字符串则表示有飘字。
        """
        return None

    def before_take_damage(self, wearer, dmg):
        """受到伤害前触发，可修改 dmg"""
        return dmg

    def on_attacked(self, wearer, attacker, dmg):
        """每次被攻击后触发"""
        pass

    def on_fatal(self, wearer):
        """
        临界（hp<=0）时触发一次，自救或其他
        返回 True 则移除自身 Buff
        """
        return False


class SteelHeartBuff(Buff):
    """刚毅：受到致命伤时自救一次，可叠加"""
    display_name = "刚毅"
    dispellable  = False
    max_stacks   = 99  # ✅ 允许叠加

    def __init__(self, uses: int = 1):
        super().__init__(stacks=uses)

    def on_fatal(self, wearer):
        if self.stacks > 0:
            self.stacks -= 1
            wearer.hp = 1
            wearer.shield += int(wearer.max_hp * 0.3)
            return self.stacks == 0  # 最后1次后移除
        return False


class RegenerationBuff(Buff):
    """
    再生：每层每秒回复 1 点 HP，持续存在（无限）。
    """
    display_name = "再生"
    dispellable  = True
    max_stacks   = 99
    is_debuff    = False

    def __init__(self, stacks: int = 1):
        super().__init__(stacks=stacks)
        self._timer = 0.0  # 新增：秒计时器

    def on_tick(self, wearer, dt):
        self._timer += dt  # 累加每帧的时间
        
        # 当计时器超过或等于1秒时，执行回血
        while self._timer >= 1.0:
            amount = self.stacks  # 每秒回复量 = 层数
            wearer.heal(amount)
            self._timer -= 1.0  # 计时器减去1秒，准备下一次计时
        return None


class PoisonDebuff(Buff):
    """
    毒：每层每秒对角色造成 1 点毒系伤害；优先消耗护盾
    """
    display_name = "毒"
    dispellable  = True
    max_stacks   = 99
    is_debuff    = True

    def __init__(self, stacks: int = 1):
        super().__init__(stacks=stacks)
        self._timer = 0.0

    def on_tick(self, wearer, dt):
        self._timer += dt
        while self._timer >= 1.0:
            dmg = self.stacks
            # <-- 核心修改：创建并发送一个伤害信息包 -->
            packet = DamagePacket(
                amount=dmg, 
                damage_type=DamageType.POISON, # 类型是毒
                is_dot=True,                   # 标记为持续伤害
                is_sourceless=True             # 标记为无来源伤害
            )
            wearer.take_damage(packet)
            self._timer -= 1.0
        return None


class AttackDisabledBuff(Buff):
    """通用：禁止角色普攻"""
    display_name    = "无法攻击"
    dispellable     = False
    is_debuff       = True
    hidden          = True
    disable_attack  = True

    def __init__(self, duration: float):
        super().__init__(stacks=1)
        self.remaining = duration

    def on_tick(self, wearer, dt):
        if self.remaining is None:
            return None
        self.remaining -= dt
        if self.remaining <= 0:
            wearer.remove_buff(self)
        return None

class StunDebuff(Buff):
    """
    眩晕：禁止普攻，不可叠加，不可驱散
    """
    display_name    = "眩晕"
    max_stacks      = 1
    dispellable     = False
    is_debuff       = True
    disable_attack  = True
    duration        = 2.0

    def __init__(self, duration=2.0):
        super().__init__(duration_override=duration)

    def on_apply(self, wearer):
        for b in wearer.buffs:
            if b is not self and isinstance(b, StunDebuff):
                b.remaining = max(b.remaining, self.remaining)
                wearer.remove_buff(self)
                return

    def on_tick(self, wearer, dt):
        self.remaining -= dt
        if self.remaining <= 0:
            wearer.remove_buff(self)
        return None


# 替换 Buffs.py 中的 ThornsBuff 类
class ThornsBuff(Buff):
    """荆棘：被攻击时反弹当前层数的真实伤害给攻击者"""
    display_name  = "荆棘"
    dispellable   = True
    is_debuff     = False
    max_stacks    = 99

    def on_attacked(self, wearer, attacker, dmg):
        if attacker is not None and self.stacks > 0 and attacker.hp > 0:
            # 创建一个真实伤害、无来源的伤害包进行反伤
            thorns_packet = DamagePacket(
                amount=self.stacks,
                damage_type=DamageType.TRUE,
                source=wearer,
                is_sourceless=True
            )
            attacker.take_damage(thorns_packet)

class PhoenixCrownStage1Buff(Buff):
    """不灭·觉醒（Stage1）：防御→攻击+攻速"""
    display_name  = "不灭·觉醒"
    dispellable   = False
    is_debuff     = False

    def __init__(self):
        super().__init__(stacks=1)
        self._boosted = False

    def on_apply(self, wearer):
        bm = wearer.base_max_hp
        wearer.max_hp = bm * 2
        wearer.hp     = min(wearer.hp + bm, wearer.max_hp)

    def on_tick(self, wearer, dt):
        if not self._boosted:
            bd = wearer.base_defense
            ba = wearer.base_attack
            bs = wearer.base_attack_speed
            wearer.attack = ba + bd
            wearer.attack_speed = bs + bd * 0.05
            wearer.attack_interval = 6.0 / wearer.attack_speed
            wearer.defense = 0
            self._boosted = True
        if wearer.hp / wearer.max_hp <= 0.2:
            wearer.remove_buff(self)
            wearer.add_buff(PhoenixCrownStage2Buff())
        return None


class PhoenixCrownStage2Buff(Buff):
    """不灭·第二阶段：禁手+回血反击"""
    display_name    = "不灭"
    dispellable     = False
    is_debuff       = False
    disable_attack  = True

    def __init__(self):
        super().__init__(stacks=1)
        self._healed_total  = 0.0
        self._rec_atk       = None
        self._rec_def       = None
        self._rec_as        = None
        self._rec_dr        = None
        self._timer         = 0.0  # 新增：秒计时器

    def on_apply(self, wearer):
        self._rec_atk  = wearer.attack
        self._rec_def  = wearer.defense
        self._rec_as   = wearer.attack_speed
        self._rec_dr   = wearer.damage_resistance
        wearer.damage_resistance = self._rec_dr + 0.5

    def on_tick(self, wearer, dt):
        self._timer += dt
        
        # 每秒触发一次回血
        while self._timer >= 1.0:
            if wearer.hp < wearer.max_hp: # 只有没满血的时候才回
                heal_amount = wearer.max_hp * 0.1 # 每秒回复最大生命的10%
                actual_healed = min(heal_amount, wearer.max_hp - wearer.hp) # 实际回复量
                wearer.hp += actual_healed
                self._healed_total += actual_healed
            self._timer -= 1.0

        if wearer.hp >= wearer.max_hp:
            total = int(self._healed_total)
            attacker = getattr(wearer, "_last_real_attacker", None)
            text = "" # 初始化返回文本

            if attacker and attacker.hp > 0:
                attacker.take_damage(total)
                attacker.last_hits.append((total, False))
                text = f"[不灭反击] {wearer.name} → {attacker.name} 造成 {total} 点伤害"

            # 恢复原属性
            wearer.attack            = self._rec_atk
            wearer.defense           = self._rec_def
            wearer.attack_speed      = self._rec_as
            wearer.attack_interval   = 6.0 / self._rec_as
            wearer.damage_resistance = self._rec_dr
            wearer.max_hp            = wearer.base_max_hp
            wearer.hp                = min(wearer.hp, wearer.max_hp)
            wearer.remove_buff(self)
            return text

        return None
    
class StormDebuff(Buff):
    """
    风暴印记 (可驱散)
    当携带者受到下一次任意来源的伤害时，
    此印记会引爆，造成额外伤害，然后消失。
    """
    display_name = "风暴"
    dispellable  = True
    is_debuff    = True

    def before_take_damage(self, wearer, packet: DamagePacket): # <-- 接收 packet
        print("[风暴引爆!] 造成额外伤害")
        # 直接在传入的伤害包上增加伤害
        packet.amount += 50
        # 移除自己
        wearer.remove_buff(self)


class BleedDebuff(Buff):
    """
    流血 (可叠加, 可驱散)
    每层每秒对目标造成 1 点真实伤害（无视防御）。
    """
    display_name = "流血"
    dispellable  = True
    is_debuff    = True
    max_stacks   = 99

    def __init__(self, stacks: int = 1, duration: float = 5.0):
        super().__init__(stacks=stacks, duration_override=duration)
        self._timer = 0.0

    def on_tick(self, wearer, dt):
        self._timer += dt
        if self._timer >= 1.0:
            dmg = self.stacks
            # <-- 核心修改：创建并发送一个伤害信息包 -->
            packet = DamagePacket(
                amount=dmg,
                damage_type=DamageType.TRUE, # 类型是真实伤害
                is_dot=True,
                is_sourceless=True
            )
            wearer.take_damage(packet)
            self._timer -= 1.0
        
        self.remaining -= dt
        if self.remaining <= 0:
            wearer.remove_buff(self)
        return None

class BlockBuff(Buff):
    """格挡：每层可以完全抵挡一次任意来源的伤害。"""
    display_name = "格挡"
    max_stacks   = 99

    def before_take_damage(self, wearer, packet: DamagePacket): # <-- 参数改为 packet
        if self.stacks > 0 and packet.amount > 0:
            print(f"[格挡] 效果触发！抵挡了 {int(packet.amount)} 点伤害。")
            self.stacks -= 1
            if self.stacks <= 0:
                wearer.remove_buff(self)
            
            packet.amount = 0 # 将伤害包的数值清零


class DragonSoulBuff(Buff):
    """【龙魂】：一种特殊的能量资源，可被消耗。"""
    display_name = "龙魂"
    max_stacks   = 10 # 龙魂上限为10层
    is_debuff    = False

class SunstoneBrandDebuff(Buff):
    """【日之烙印】：一种可被引爆的印记。"""
    display_name = "日之烙印"
    is_debuff    = True
    max_stacks   = 99


================================================================================
### 文件路径: Character.py
================================================================================

# Character.py (最终完整版)
import pygame
import sys
import time
import collections
import math
import random
# from rich.console import Console  <- No longer needed
# console = Console()

import Buffs
import Talents
import Equips
from damage import DamagePacket, DamageType
from settings import RARITY_COLORS

RARITY_GOLD_VALUE = {"common": 10, "uncommon": 25, "rare": 60, "epic": 150, "legendary": 400, "mythic": 1000}

class Character:
    DEFAULT_SLOT_CAPACITY = {"weapon": 1, "offhand": 1, "helmet": 1, "armor": 1, "pants": 1, "accessory": 4}

    def __init__(self, name, hp, defense, magic_resist, attack, attack_speed,
                 equipment=None, talents=None, id=None): # <-- 1. 在这里增加 id=None

        self.id = id or name # <-- 2. 增加这一行，如果提供了id就用id，否则用名字
        self.name, self.level, self.gold = name, 1, 0
        self.exp, self.exp_to_next_level, self.backpack = 0, 100, []
        self.SLOT_CAPACITY = self.DEFAULT_SLOT_CAPACITY.copy()
        self.max_talent_slots = 3 
        self.learned_talents = talents or []
        self.equipped_talents = []
        self._innate_max_hp, self._innate_defense, self._innate_attack, self._innate_attack_speed = hp, defense, attack, attack_speed
        self.magic_resist = magic_resist
        self.slots = {
            slot: [None] * capacity for slot, capacity in self.SLOT_CAPACITY.items()
        }
        for eq in (equipment or []): self.equip(eq)
        self.base_max_hp, self.base_defense, self.base_attack, self.base_attack_speed = 0, 0, 0, 0
        self.recalculate_stats(); self.hp = self.max_hp
        initial_talents_to_equip = self.learned_talents[:]
        self.learned_talents = []
        for talent in initial_talents_to_equip: self.learn_talent(talent); self.equip_talent(talent)
        self.shield, self._cd, self.crit_chance, self.crit_multiplier = 0, 0.0, 0.0, 1.5
        self.last_damage, self.last_hits, self.buffs, self.damage_resistance = 0, collections.deque(maxlen=5), [], 0.0

    def add_gold(self, amount, source=""):
        if amount <= 0: return None
        self.gold += amount
        source_text = f" ({source})" if source else ""
        return f"获得了 {amount} G！{source_text} (当前: {self.gold} G)"

    def pickup_item(self, item_to_pickup):
        item_name = getattr(item_to_pickup, 'display_name', item_to_pickup.__class__.__name__)
        all_current_items = self.backpack + self.all_equipment
        is_duplicate = any(getattr(item, 'display_name', item.__class__.__name__) == item_name for item in all_current_items)
        if is_duplicate:
            rarity = getattr(item_to_pickup, 'rarity', 'common')
            gold_value = RARITY_GOLD_VALUE.get(rarity, 5)
            return self.add_gold(gold_value, source=f"转化({item_name})")
        else:
            self.backpack.append(item_to_pickup)
            return f"物品「{item_name}」已放入你的背包。"
    
    # ... (其他所有方法都保持不变)
    def learn_talent(self, talent_to_learn):
        if not any(isinstance(t, talent_to_learn.__class__) for t in self.learned_talents):
            self.learned_talents.append(talent_to_learn)
            print(f"学会了新天赋: {talent_to_learn.display_name}")
            return True
        return False
    def equip_talent(self, talent_to_equip):
        if len(self.equipped_talents) >= self.max_talent_slots: print("天赋槽已满！"); return False
        if talent_to_equip not in self.learned_talents: print("尚未学会该天赋！"); return False
        if talent_to_equip in self.equipped_talents: print("该天赋已被装备。"); return False
        self.equipped_talents.append(talent_to_equip); self.recalculate_stats(); print(f"已装备天赋: {talent_to_equip.display_name}"); return True
    def unequip_talent(self, talent_to_unequip):
        if talent_to_unequip not in self.equipped_talents: return
        self.equipped_talents.remove(talent_to_unequip); self.recalculate_stats(); print(f"已卸下天赋: {talent_to_unequip.display_name}")
    # 文件: Character.py

    def on_enter_combat(self):
        self.buffs.clear(); self.hp = self.max_hp; self.shield = 0; self._cd = 0.0;

        # 新增逻辑：重置装备的战斗内状态
        for eq in self.all_equipment:
            if isinstance(eq, Equips.AdventurersPouch):
                eq.atk_bonus = 0 # 战斗准备时，将钱袋的加成清零

        # 重置完后再重算一次属性，确保一个干净的状态
        self.recalculate_stats() 
        print(f"{self.name} 已进入战斗准备状态！")
    def update(self, dt) -> list[str]:
        texts = []
        for buff in list(self.buffs):
            if hasattr(buff, "on_tick"): res = buff.on_tick(self, dt);
            if isinstance(res, str) and res: texts.append(res)
        for eq in self.all_equipment:
            if hasattr(eq, "on_tick"): res = eq.on_tick(self, dt);
            if isinstance(res, str) and res: texts.append(res)
        return texts
    # 在 Character.py 文件中，找到并替换 recalculate_stats 方法

    # Replace the entire recalculate_stats method with this new version
    def recalculate_stats(self):
        """重新计算所有来自装备和天赋的属性加成"""
        # 1. 保存当前血量百分比
        hp_percent = self.hp / self.max_hp if hasattr(self, 'max_hp') and self.max_hp > 0 else 1

        # 2. 重置为纯粹的“固有”属性
        self.base_max_hp = self._innate_max_hp
        self.base_defense = self._innate_defense
        self.base_attack = self._innate_attack
        self.base_attack_speed = self._innate_attack_speed

        # 3. 加上所有来自“装备”的属性
        all_eq = self.all_equipment
        self.base_max_hp += sum(getattr(eq, "hp_bonus", 0) for eq in all_eq)
        self.base_defense += sum(getattr(eq, "def_bonus", 0) for eq in all_eq)
        self.base_attack += sum(getattr(eq, "atk_bonus", 0) for eq in all_eq)
        self.base_attack_speed += sum(getattr(eq, "as_bonus", 0) for eq in all_eq)

        # 4. 将“当前属性”先重置为“基础属性”
        self.max_hp = self.base_max_hp
        self.defense = self.base_defense
        self.attack = self.base_attack
        self.attack_speed = self.base_attack_speed
        self.crit_chance = 0.0 
        self.magic_resist = 3 
        self.damage_resistance = 0.0

        # --- 核心修复在这里 ---
        # 5. 在应用天赋之前，先重置 SLOT_CAPACITY 为默认值
        #    这可以防止天赋效果（如二刀流）在卸下后依然残留
        self.SLOT_CAPACITY = self.DEFAULT_SLOT_CAPACITY.copy()

        # 6. 应用所有来自“已装备天赋”的修改（这可能会改变 SLOT_CAPACITY）
        for talent in self.equipped_talents:
            if hasattr(talent, 'on_init'):
                talent.on_init(self)

        # 7. 新增：同步装备槽容量
        #    在天赋修改完 SLOT_CAPACITY 规则后，我们在这里确保 self.slots 的实际大小与规则匹配
        for slot, required_capacity in self.SLOT_CAPACITY.items():
            current_slots = self.slots.get(slot, [])
            current_capacity = len(current_slots)

            if current_capacity < required_capacity:
                # 如果实际槽位比需要的少，就用 None 补上
                current_slots.extend([None] * (required_capacity - current_capacity))
            elif current_capacity > required_capacity:
                # 如果实际槽位比需要的多（例如卸下了二刀流天赋）
                # 我们需要处理多余的装备，这里简单地将它们放回背包
                extra_items = current_slots[required_capacity:]
                for item in extra_items:
                    if item:
                        self.backpack.append(item)
                # 然后截断列表
                self.slots[slot] = current_slots[:required_capacity]
        # --- 修复结束 ---

        # 8. 最后，应用其他装备效果（比如暴击率）
        self.magic_resist += sum(getattr(eq, "magic_resist_bonus", 0) for eq in all_eq)
        self.crit_chance += sum(getattr(eq, "crit_bonus", 0) for eq in all_eq)

        # 9. 恢复血量百分比并最终计算
        self.hp = min(self.max_hp, self.max_hp * hp_percent)
        self.attack_interval = 6.0 / self.attack_speed
        print("角色属性已更新！")
    
    @property
    def all_equipment(self):
        eqs = []
        for eq_list in self.slots.values():
            # 筛选出不是 None 的真实装备
            eqs.extend([item for item in eq_list if item is not None])
        return eqs

# --- 3. 完整替换 equip 方法 ---
    def equip(self, eq_to_equip, specific_index=None):
        """装备一件物品，可以指定精确的槽位索引。"""
        slot = eq_to_equip.slot
        if slot not in self.SLOT_CAPACITY:
            raise ValueError(f"未知插槽：{slot}")

        # 如果指定了索引
        if specific_index is not None:
            if 0 <= specific_index < self.SLOT_CAPACITY[slot]:
                # 卸下目标槽位原有的物品
                unequipped_item = self.slots[slot][specific_index]
                # 穿上新物品
                self.slots[slot][specific_index] = eq_to_equip
                self.recalculate_stats()
                return unequipped_item # 返回被替换下的物品 (可能是None)
            else:
                return eq_to_equip # 索引无效，装备失败

        # 如果未指定索引，则自动寻找空位
        else:
            try:
                # 找到第一个空槽位 (值为None)
                empty_index = self.slots[slot].index(None)
                self.slots[slot][empty_index] = eq_to_equip
                self.recalculate_stats()
                return None # 成功装备到空槽，没有物品被替换
            except ValueError:
                # 如果找不到None，说明槽位已满
                # 对于单槽位，直接替换
                if self.SLOT_CAPACITY[slot] == 1:
                    unequipped_item = self.slots[slot][0]
                    self.slots[slot][0] = eq_to_equip
                    self.recalculate_stats()
                    return unequipped_item
                else: # 多槽位已满且未指定索引，则失败
                    print(f"警告: {slot} 插槽已满且未指定替换位置")
                    return eq_to_equip

# --- 4. 完整替换 unequip 方法 ---
    def unequip(self, eq_to_unequip):
        """从角色身上卸下指定的装备。"""
        slot = eq_to_unequip.slot
        if eq_to_unequip in self.slots[slot]:
            # 找到物品的索引
            index = self.slots[slot].index(eq_to_unequip)
            # 将该位置设置回 None
            self.slots[slot][index] = None
            self.recalculate_stats()
            return eq_to_unequip # 返回被卸下的物品
        return None
    def take_damage(self, packet: DamagePacket):
        final_packet = packet.copy()
        for eq in self.all_equipment:
            if hasattr(eq, "before_take_damage"): eq.before_take_damage(self, final_packet)
        for buff in list(self.buffs):
            if hasattr(buff, "before_take_damage"): buff.before_take_damage(self, final_packet)
        mitigated_amount = final_packet.amount
        if not final_packet.ignores_armor and final_packet.damage_type != DamageType.TRUE:
            if final_packet.damage_type == DamageType.PHYSICAL: mitigated_amount -= self.defense
            elif final_packet.damage_type == DamageType.MAGIC: mitigated_amount -= self.magic_resist
        mitigated_amount *= (1.0 - self.damage_resistance)
        mitigated_amount = max(0, mitigated_amount)
        if self.shield > 0: shield_absorbed = min(self.shield, mitigated_amount); self.shield -= shield_absorbed; mitigated_amount -= shield_absorbed
        if mitigated_amount > 0:
            self.hp = max(0, self.hp - mitigated_amount)
            timestamp = pygame.time.get_ticks() if "pygame" in sys.modules else int(time.time() * 1000)
            self.last_hits.append((int(mitigated_amount), timestamp))
        for eq in self.all_equipment:
            if hasattr(eq, "after_take_damage"): eq.after_take_damage(self, final_packet, mitigated_amount)
        for buff in list(self.buffs):
            if hasattr(buff, "on_attacked"): buff.on_attacked(self, final_packet.source, mitigated_amount)
        if self.hp <= 0:
            to_remove = []
            for buff in list(self.buffs):
                if hasattr(buff, "on_fatal") and buff.on_fatal(self): to_remove.append(buff)
            for buff in to_remove: self.remove_buff(buff)
    def try_attack(self, target, dt):
        if any(getattr(b, "disable_attack", False) for b in self.buffs): return None
        self._cd += dt
        if self._cd < self.attack_interval or self.hp <= 0: return None
        is_crit = (random.random() < self.crit_chance)
        damage = self.attack * self.crit_multiplier if is_crit else self.attack
        packet = DamagePacket(amount=damage, damage_type=DamageType.PHYSICAL, source=self, is_critical=is_crit)
        for eq in self.all_equipment:
            if hasattr(eq, "before_attack"): eq.before_attack(self, target, packet)
        pre_total = target.shield + target.hp; target.take_damage(packet); post_total = target.shield + target.hp
        actual_dmg = pre_total - post_total
        for eq in self.all_equipment:
            if hasattr(eq, "after_attack"): eq.after_attack(self, target, actual_dmg)
        if is_crit:
            for eq in self.all_equipment:
                if hasattr(eq, "on_critical"): eq.on_critical(self, target, actual_dmg)
        else:
            for eq in self.all_equipment:
                if hasattr(eq, "on_non_critical"): eq.on_non_critical(self, target, actual_dmg)
        extra_texts = []
        for t in self.equipped_talents:
            if hasattr(t, "on_attack"): out = t.on_attack(self, target, actual_dmg);
            if out: extra_texts.extend(out)
        self._cd -= self.attack_interval; text = f"{self.name} → {target.name} 造成 {int(actual_dmg)} 点伤害"
        if is_crit: text += " (暴击!)"
        return text, extra_texts
    def perform_extra_attack(self, target):
        print(f"[{self.name}] 正在执行额外攻击！")
        is_crit = (random.random() < self.crit_chance); damage = self.attack * self.crit_multiplier if is_crit else self.attack
        packet = DamagePacket(amount=damage, damage_type=DamageType.PHYSICAL, source=self, is_critical=is_crit)
        for eq in self.all_equipment:
            if hasattr(eq, "before_attack"): eq.before_attack(self, target, packet)
        pre_total = target.shield + target.hp; target.take_damage(packet); post_total = target.shield + target.hp
        actual_dmg = pre_total - post_total
        for eq in self.all_equipment:
            if hasattr(eq, "after_attack"): eq.after_attack(self, target, actual_dmg)
        if is_crit:
            for eq in self.all_equipment:
                if hasattr(eq, "on_critical"): eq.on_critical(self, target, actual_dmg)
        else:
            for eq in self.all_equipment:
                if hasattr(eq, "on_non_critical"): eq.on_non_critical(self, target, actual_dmg)
        text = f"{self.name} (额外攻击) → {target.name} 造成 {int(actual_dmg)} 点伤害"
        if is_crit: text += " (暴击!)"
        return text
    def heal(self, amount: float) -> float:
        healed = min(self.max_hp - self.hp, amount)
        if healed <= 0: return 0.0
        self.hp += healed
        for buff in list(self.buffs):
            if hasattr(buff, "on_healed"): buff.on_healed(self, healed)
        return healed
    def add_status(self, status: Buffs.Buff, *, source: "Character" = None):
        final_buff = None; added_stacks = status.stacks
        for b in self.buffs:
            if isinstance(b, status.__class__):
                if b.max_stacks == 1: b.remaining = b.duration
                else: b.stacks = min(b.stacks + status.stacks, b.max_stacks)
                final_buff = b; break
        if final_buff is None: final_buff = status; self.buffs.append(status); status.on_apply(self)
        if source is not None and source is not self and getattr(final_buff, "is_debuff", False):
            for t in self.equipped_talents:
                if hasattr(t, "on_inflict_debuff"): t.on_inflict_debuff(source, self, final_buff, added_stacks)
        if getattr(final_buff, "dispellable", False) and getattr(final_buff, "is_debuff", False):
            for t in self.equipped_talents:
                if hasattr(t, "on_debuff_applied"): t.on_debuff_applied(self, final_buff)
    add_buff, add_debuff = add_status, add_status
    def remove_buff(self, buff): self.buffs.remove(buff); buff.on_remove(self)
    def add_exp(self, amount):
        if self.hp <= 0: return []
        self.exp += amount; messages = [f"获得了 {amount} 点经验！ (当前: {self.exp}/{self.exp_to_next_level})"]
        if self.exp >= self.exp_to_next_level: messages.extend(self.level_up())
        return messages
    def level_up(self):
        level_up_messages = []
        while self.exp >= self.exp_to_next_level:
            self.level += 1; self.exp -= self.exp_to_next_level; self.exp_to_next_level = int(self.exp_to_next_level * 1.5)
            self._innate_max_hp += 10; self._innate_attack += 2; self._innate_defense += 1
            self.recalculate_stats()
            level_up_messages.append(f"🎉 等级提升！现在是 {self.level} 级！"); level_up_messages.append("   生命+10，攻击+2，防御+1")
        return level_up_messages


================================================================================
### 文件路径: combine_code.py
================================================================================

import os
import datetime

# --- 配置 ---
# 要搜索的根文件夹 ('.' 代表当前文件夹)
ROOT_DIR = '.'
# 要包含的文件扩展名
FILE_EXTENSIONS = ('.py', '.json')
# 输出文件名
OUTPUT_FILE = 'combined_code.txt'
# --- 结束配置 ---

def combine_files():
    """
    遍历指定目录及其子目录，将特定扩展名的文件内容合并到一个文件中。
    """
    print(f"开始扫描文件夹: {os.path.abspath(ROOT_DIR)}")
    print(f"将要合并的文件类型: {FILE_EXTENSIONS}")
    
    # 使用 with 语句确保文件被正确关闭
    with open(OUTPUT_FILE, 'w', encoding='utf-8') as outfile:
        # 写入文件头部信息
        outfile.write(f"--- 代码合集生成于: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')} ---\n")
        outfile.write(f"--- 根目录: {os.path.abspath(ROOT_DIR)} ---\n\n")
        
        # os.walk() 会递归地遍历目录
        for dirpath, _, filenames in os.walk(ROOT_DIR):
            for filename in filenames:
                # 检查文件扩展名是否符合要求
                if filename.endswith(FILE_EXTENSIONS):
                    # 构建完整的文件路径
                    file_path = os.path.join(dirpath, filename)
                    # 获取相对路径，这样更清晰
                    relative_path = os.path.relpath(file_path, ROOT_DIR)
                    
                    print(f"正在添加文件: {relative_path}")
                    
                    # 写入文件分隔符和路径信息
                    outfile.write("=" * 80 + "\n")
                    outfile.write(f"### 文件路径: {relative_path}\n")
                    outfile.write("=" * 80 + "\n\n")
                    
                    try:
                        # 读取源文件内容并写入输出文件
                        with open(file_path, 'r', encoding='utf-8') as infile:
                            outfile.write(infile.read())
                        outfile.write("\n\n\n") # 在文件末尾添加一些空行以作区分
                    except Exception as e:
                        # 如果文件读取失败（例如因为编码问题），则记录错误信息
                        outfile.write(f"*** 无法读取文件: {relative_path} | 错误: {e} ***\n\n\n")

    print(f"\n成功！所有代码已整合到文件: {OUTPUT_FILE}")

if __name__ == '__main__':
    combine_files()


================================================================================
### 文件路径: damage.py
================================================================================

# damage.py
from enum import Enum, auto

class DamageType(Enum):
    PHYSICAL = auto()      # 普通物理伤害
    MAGIC = auto()         # 魔法伤害
    TRUE = auto()          # 真实伤害
    POISON = auto()        # 毒系伤害
    DRAGON_SOURCE = auto() # 龙源伤害

class DamagePacket:
    """一个用来封装所有伤害信息的数据结构"""
    def __init__(self, amount, damage_type, source=None,
                 is_critical=False, is_dot=False, 
                 is_sourceless=False, ignores_armor=False):
        
        self.amount = amount               # 基础伤害数值
        self.damage_type = damage_type     # 伤害类型 (物理, 魔法, 真实...)
        self.source = source               # 伤害来源 (哪个角色)
        
        # --- 各种标志 (Flags) ---
        self.is_critical = is_critical         # 是否暴击
        self.is_dot = is_dot                   # 是否为持续伤害(DOT)
        self.is_sourceless = is_sourceless     # 是否为无来源伤害 (如环境、反伤)
        self.ignores_armor = ignores_armor     # 是否穿甲 (无视防御)

    def copy(self):
        """创建一个副本，方便在计算过程中修改而不影响原始包"""
        return DamagePacket(
            self.amount, self.damage_type, self.source,
            self.is_critical, self.is_dot, self.is_sourceless, self.ignores_armor
        )


================================================================================
### 文件路径: dungeon_generator.py
================================================================================

# 文件: dungeon_generator.py (完整替换)

import random
from settings import SCREEN_WIDTH, SCREEN_HEIGHT

class Room:
    def __init__(self, x, y, room_type="combat"):
        self.x, self.y, self.type = x, y, room_type
        self.doors = {"N": False, "S": False, "E": False, "W": False}
        self.is_cleared = False
        self.monsters = []
        # 你还可以添加 event_id, treasure_contents 等字段

class Floor:
    def __init__(self, width=21, height=21):
        self.width, self.height = width, height
        self.rooms, self.start_room, self.boss_room = {}, None, None

    def generate_floor(self, num_rooms=8, floor_data=None):
        """
        使用传入的 floor_data 动态生成楼层内容
        """
        self.rooms.clear()
        grid = [[None for _ in range(self.width)] for _ in range(self.height)]
        
        # 1. 创建房间布局 (这部分逻辑不变)
        sx, sy = self.width // 2, self.height // 2
        start_room = Room(sx, sy, "start")
        start_room.is_cleared = True
        grid[sy][sx] = start_room
        self.rooms[(sx, sy)] = start_room
        
        frontier = [(sx, sy)]
        
        while len(self.rooms) < num_rooms and frontier:
            px, py = random.choice(frontier)
            possible_neighbors = []
            directions = [(0, -1, "N", "S"), (0, 1, "S", "N"), (1, 0, "E", "W"), (-1, 0, "W", "E")]
            for dx, dy, door, opposite_door in directions:
                nx, ny = px + dx, py + dy
                if 0 <= nx < self.width and 0 <= ny < self.height and not grid[ny][nx]:
                    possible_neighbors.append((nx, ny, door, opposite_door))
            
            if possible_neighbors:
                nx, ny, door, opposite_door = random.choice(possible_neighbors)
                new_room = Room(nx, ny)
                grid[ny][nx] = new_room
                self.rooms[(nx, ny)] = new_room
                frontier.append((nx, ny))
                grid[py][px].doors[door] = True
                new_room.doors[opposite_door] = True
            else:
                frontier.remove((px, py))

        # --- 2. 核心修改：根据 floor_data 填充房间内容 ---
        if not floor_data:
            print("错误: 未提供楼层数据，无法填充内容！")
            return

        # 定位Boss房间 (逻辑不变)
        self.start_room = self.rooms[(sx, sy)]
        farthest_dist = -1
        boss_coord = (sx, sy)
        for coord in self.rooms.keys():
            dist = abs(coord[0] - sx) + abs(coord[1] - sy)
            if dist > farthest_dist and self.rooms[coord] is not self.start_room:
                farthest_dist = dist
                boss_coord = coord
        self.boss_room = self.rooms[boss_coord]
        self.boss_room.type = "boss"
        
        # 确定特殊房间类型和数量 (逻辑不变)
        room_type_pool = ["combat"] * 4 + ["event"] * 2 + ["treasure"]*2 + ["shop", "rest", "elite"]
        special_room_candidates = [r for r in self.rooms.values() if r.type == "combat"]
        for room_type in ["event", "treasure", "shop", "rest", "elite"]:
            if special_room_candidates:
                candidate = random.choice(special_room_candidates)
                candidate.type = room_type
                special_room_candidates.remove(candidate)

        # 动态填充怪物
        m_uid = 0
        for room in self.rooms.values():
            if room.type in ["combat", "elite", "boss"]:
                num = 1
                e_id = "slime" # 默认值

                if room.type == "boss":
                    num = 1
                    e_id = floor_data.get("boss_id", "ruin_golem")
                elif room.type == "elite":
                    num = random.randint(2, 3)
                    if floor_data.get("elite_pool"):
                        e_id = random.choice(floor_data["elite_pool"])
                else: # 普通战斗
                    num = random.randint(1, 3)
                    if floor_data.get("monster_pool"):
                        e_id = random.choice(floor_data["monster_pool"])
                
                for _ in range(num):
                    px, py = random.randint(100, SCREEN_WIDTH - 100), random.randint(100, SCREEN_HEIGHT - 100)
                    room.monsters.append({'id': e_id, 'pos': (px, py), 'uid': f'm_{m_uid}'})
                    m_uid += 1


================================================================================
### 文件路径: enemies.json
================================================================================

{
    "slime": {
        "name": "史莱姆",
        "stats": {
            "hp": 20,
            "defense": 2,
            "magic_resist": 0,
            "attack": 5,
            "attack_speed": 1.0
        },
        "exp_reward": 5,
        "possible_talents": [{"talent_class_name": "PoisonousTalent", "chance": 0.5}]
    },
    "goblin": {
        "name": "哥布林",
        "stats": {
            "hp": 40,
            "defense": 4,
            "magic_resist": 2,
            "attack": 8,
            "attack_speed": 1.2
        },
        "exp_reward": 8,
        "possible_talents": [{"talent_class_name": "DualWieldTalent", "chance": 0.5}]
        
    },
    "goblin_archer": {
        "name": "哥布林弓箭手", "exp_reward": 30,
        "stats": {"hp": 60, "defense": 2, "magic_resist": 1, "attack": 10, "attack_speed": 1.8},
        "possible_talents": [{"talent_class_name": "FirstStrike", "chance": 0.15}]
    },
    "goblin_captain": {
        "name": "哥布林队长", "exp_reward": 80,
        "stats": {"hp": 150, "defense": 8, "magic_resist": 5, "attack": 18, "attack_speed": 1.2},
        "possible_talents": [{"talent_class_name": "Brawler", "chance": 0.5}]
    },
    "armored_skeleton": {
        "name": "重甲骷髅", "exp_reward": 40,
        "stats": {"hp": 100, "defense": 20, "magic_resist": 5, "attack": 15, "attack_speed": 0.8}
    },
    "giant_bat": {
        "name": "巨型蝙蝠", "exp_reward": 35,
        "stats": {"hp": 70, "defense": 3, "magic_resist": 3, "attack": 10, "attack_speed": 2.5}
    },
    "wild_boar": {
        "name": "狂野野猪", "exp_reward": 50,
        "stats": {"hp": 200, "defense": 5, "magic_resist": 2, "attack": 20, "attack_speed": 1.0}
    },
    "forest_spirit": {
        "name": "森林之灵", "exp_reward": 60,
        "stats": {"hp": 120, "defense": 5, "magic_resist": 15, "attack": 15, "attack_speed": 1.1},
        "possible_talents": [{"talent_class_name": "MagicShield", "chance": 1.0}]
    },
    "rock_golem": {
        "name": "岩石傀儡", "exp_reward": 70,
        "stats": {"hp": 300, "defense": 15, "magic_resist": 10, "attack": 22, "attack_speed": 0.7},
        "possible_talents": [{"talent_class_name": "Giant", "chance": 1.0}]
    },
    "ruin_golem": {
        "name": "遗迹守护者", "exp_reward": 200,
        "stats": {"hp": 500, "defense": 25, "magic_resist": 15, "attack": 30, "attack_speed": 0.9},
        "possible_talents": [{"talent_class_name": "LastStand", "chance": 1.0}]
    },
    "mimic": {
        "name": "宝箱怪", "exp_reward": 100,
        "stats": {"hp": 150, "defense": 10, "magic_resist": 10, "attack": 25, "attack_speed": 1.5}

    },
    "fire_elemental": {
        "name": "火焰元素", "exp_reward": 120,
        "stats": {"hp": 180, "defense": 8, "magic_resist": 20, "attack": 28, "attack_speed": 1.3},
        "possible_talents": [{"talent_class_name": "FlameAura", "chance": 1.0}]
    },
    "ice_elemental": {
        "name": "冰霜元素", "exp_reward": 120,
        "stats": {"hp": 180, "defense": 8, "magic_resist": 20, "attack": 28, "attack_speed": 1.3},
        "possible_talents": [{"talent_class_name": "FrostAura", "chance": 1.0}]
    },
    "orc_warrior": {
        "name": "兽人战士", "exp_reward": 150,
        "stats": {"hp": 250, "defense": 12, "magic_resist": 5, "attack": 35, "attack_speed": 1.0},
        "possible_talents": [{"talent_class_name": "Berserker", "chance": 0.5}]
    },
    "orc_shaman": {
        "name": "兽人萨满", "exp_reward": 150,
        "stats": {"hp": 200, "defense": 8, "magic_resist": 15, "attack": 30, "attack_speed": 1.2},
        "possible_talents": [{"talent_class_name": "HealingWave", "chance": 0.5}]
    },
    "dark_knight": {
        "name": "黑暗骑士", "exp_reward": 300,
        "stats": {"hp": 400, "defense": 20, "magic_resist": 10, "attack": 50, "attack_speed": 1.0},
        "possible_talents": [{"talent_class_name": "Executioner", "chance": 1.0}]
    },
    "necromancer": {
        "name": "死灵法师", "exp_reward": 250,
        "stats": {"hp": 300, "defense": 10, "magic_resist": 25, "attack": 40, "attack_speed": 1.1},
        "possible_talents": [{"talent_class_name": "SummonSkeletons", "chance": 1.0}]
    },
    "poisonDragon": {
        "name": "毒龙",
        "stats": {
            "hp": 800,
            "defense": 14,
            "magic_resist": 2,
            "attack": 8,
            "attack_speed": 1.2
        },
        "talents": [
            "PoisonousTalent",
            "BambooLeafTalent"
        ],
        "exp_reward": 800
    }
}


================================================================================
### 文件路径: Equips.py
================================================================================

import Buffs
import Talents
from damage import DamagePacket, DamageType
from abc import ABC
import collections
from collections import defaultdict
from rich.console import Console, Group
from rich.live import Live
from rich.table import Table
from rich.panel import Panel
from rich.text import Text
import time
import random
from rich.text import Text
from rich.progress import BarColumn
import math
from collections import Counter
import sys

class Equipment:
    slot = None
    def on_battle_start(self, wearer): pass
    def before_attack(self, wearer, target, dmg): return dmg
    def after_attack(self, wearer, target, dmg): pass
    def before_take_damage(self, wearer, dmg): return dmg
    def on_critical(self, wearer, target, dmg): pass
    def on_non_critical(self, wearer, target, dmg): pass

class WoodenShield(Equipment):
    """木盾：副手插槽；+2 防御；战斗开始时获得 10 护盾"""
    slot = "offhand"
    display_name    = "木盾"

    def __init__(self):
        self.type = "armor"
        self.def_bonus    = 2
        self.shield_bonus = 10

    def on_battle_start(self, wearer):
        # 防御是永久属性，由Character.__init__处理
        wearer.shield  += self.shield_bonus

class WoodenSword(Equipment):
    """木剑：武器插槽；+3 攻击；每普攻 3 次，第 4 次普攻造成双倍伤害"""
    slot = "weapon"
    display_name    = "木剑"

    def __init__(self):
        self.type = "weapon"
        self.rarity = "common"
        self.atk_bonus = 3
        self._count    = 0
    
    # on_battle_start 已被移除，因为攻击是永久属性

    def before_attack(self, wearer, target, packet: DamagePacket):
        # 效果现在修改的是伤害包的数值
        if self._count >= 3:
            packet.amount *= 2
            self._count = 0

    def after_attack(self, wearer, target, actual_dmg):
        # 这里的dmg是造成伤害后的最终数值，可以直接使用
        if actual_dmg <= wearer.base_attack:
            self._count += 1

class WoodenSword_Star(Equipment):
    """木剑⭐：武器插槽；+6 攻击；现在每攻击 2 次，第 3 次普攻造成双倍伤害。"""
    slot = "weapon"
    display_name = "木剑⭐"
    
    def __init__(self):
        self.type = "weapon"
        self.rarity = "uncommon" # 升级后，品质也提升了
        self.atk_bonus = 6       # 基础攻击更高
        self._count = 0

    def before_attack(self, wearer, target, packet: DamagePacket):
        # 效果增强：从3次触发改为2次触发
        if self._count >= 2:
            packet.amount *= 2
            self._count = 0

    def after_attack(self, wearer, target, actual_dmg):
        # 这里的dmg是造成伤害后的最终数值，可以直接使用
        self._count += 1

class WoodenArmor(Equipment):
    """木铠甲：护甲插槽；+2 防御；30% 概率额外减免 30% 点物理伤害"""
    slot = "armor"
    display_name    = "木铠甲"

    def __init__(self):
        self.type = "armor"
        self.rarity = "common"
        self.def_bonus = 2

    # on_battle_start 已被移除，因为防御是永久属性

    def before_take_damage(self, wearer, packet: DamagePacket):
        # 效果现在只对物理伤害生效
        if packet.damage_type == DamageType.PHYSICAL and random.random() < 0.3:
            packet.amount = max(0, packet.amount * 0.7)

class WoodenArmor_Star(Equipment):
    """木铠甲⭐：护甲插槽；+5 防御；50% 概率额外减免 50% 点物理伤害"""
    slot = "armor"
    display_name = "木铠甲⭐"

    def __init__(self):
        self.type = "armor"
        self.rarity = "uncommon"
        self.def_bonus = 5 # 基础防御更高

    def before_take_damage(self, wearer, packet: DamagePacket):
        # 效果现在只对物理伤害生效
        if packet.damage_type == DamageType.PHYSICAL and random.random() < 0.5:
            packet.amount = max(0, packet.amount * 0.5)

class IronSword(Equipment):
    """铁剑：武器插槽；+5 攻击；基础 +5% 暴击率；未暴击时，下次普攻暴击率 +5%，最多 8 层；暴击后清除"""
    slot = "weapon"
    display_name = "铁剑"
    def __init__(self):
        self.rarity = "common"
        self.type = "weapon"
        self.atk_bonus = 5
        self.base_crit_bonus = 0.05
        self.max_stacks = 8
        self._stacks = 0
    def on_battle_start(self, wearer):
        # 攻击和暴击都是永久属性
        # 但暴击率需要在战斗中动态变化，所以我们需要在战前设置初始值
        wearer.crit_chance += self.base_crit_bonus
    def on_critical(self, wearer, target, dmg):
        wearer.crit_chance -= self._stacks * self.base_crit_bonus
        self._stacks = 0
    def on_non_critical(self, wearer, target, dmg):
        if self._stacks < self.max_stacks:
            self._stacks += 1
            wearer.crit_chance += self.base_crit_bonus

class IronRing(Equipment):
    """铁戒指：饰品槽；+5% 暴击；+10% 爆伤；赠送两层“刚毅”Buff"""
    slot = "accessory"
    display_name = "铁戒指"
    def __init__(self):
        self.rarity = "common"
        self.type = "misc" # 添加类型
        self.crit_bonus = 0.05
        self.crit_dmg_bonus = 0.10
    def on_battle_start(self, wearer):
        # 暴击和爆伤是永久属性
        # 只保留战斗开始时的效果
        wearer.add_status(Buffs.SteelHeartBuff(uses=2))

class IronHammer(Equipment):
    """铁锤：武器槽；+8 攻击；+5% 暴击；20% 概率眩晕敌人 2 秒"""
    slot = "weapon"
    display_name = "铁锤"
    def __init__(self):
        self.rarity = "uncommon"
        self.type = "weapon"
        self.atk_bonus = 8
        self.crit_chance_bonus = 0.05
        self.stun_chance = 0.20
        self.stun_duration = 2.0
    def on_battle_start(self, wearer):
        # 攻击和暴击是永久属性
        pass
    def after_attack(self, wearer, target, dmg):
        if random.random() < self.stun_chance:
            target.add_status(Buffs.StunDebuff(self.stun_duration), source=wearer)

class NaturalNecklace(Equipment):
    """自然项链：饰品槽；最大 HP +20；提供 2 层“再生”Buff"""
    slot = "accessory"
    display_name = "自然项链"
    def __init__(self):
        self.rarity = "uncommon"
        self.type = "misc" # 添加类型
        self.hp_bonus = 20
    def on_battle_start(self, wearer):
        # HP是永久属性
        # 只保留战斗开始时的效果
        wearer.add_status(Buffs.RegenerationBuff(stacks=2))

class ThornsRing(Equipment):
    """荆棘环：饰品槽；+0.2 攻速；+10% 爆伤；战斗开始时提供 3 层 荆棘"""
    slot = "accessory"
    display_name = "荆棘环"
    def __init__(self):
        self.rarity = "uncommon"
        self.type = "misc" # 添加类型
        self.atk_speed_bonus = 0.2
        self.crit_damage_bonus = 0.10
        self.thorns_stacks = 3
    def on_battle_start(self, wearer):
        # 攻速和爆伤是永久属性
        # 只保留战斗开始时的效果
        wearer.add_status(Buffs.ThornsBuff(stacks=self.thorns_stacks))

class PhoenixCrown(Equipment):
    """紫金冠：头盔槽；无基础属性；附加“不灭”效果"""
    slot = "helmet"
    display_name = "紫金冠"
    def __init__(self):
        self.rarity = "legendary"
        self.type = "armor" # 添加类型
    def on_battle_start(self, wearer):
        # 这个设计是完美的，只添加Buff
        wearer.add_buff(Buffs.PhoenixCrownStage1Buff())

class SlimeSword(Equipment):
    """史莱姆之剑：武器；+6 攻击；攻击时有15%概率使敌人中毒1层"""
    slot = "weapon"
    display_name = "史莱姆之剑"
    def __init__(self):
        self.rarity = "common"
        self.type = "weapon"
        self.atk_bonus = 6
        self.poison_chance = 0.15
    def on_battle_start(self, wearer):
        # 攻击是永久属性
        pass
    def after_attack(self, wearer, target, dmg):
        if random.random() < self.poison_chance:
            target.add_debuff(Buffs.PoisonDebuff(stacks=1), source=wearer)


class VampiresFang(Equipment):
    """吸血鬼之牙：饰品槽；攻击造成10%生命偷取，生命低于50%时效果翻倍。"""
    slot = "accessory"
    display_name = "吸血鬼之牙"
    def __init__(self):
        self.rarity, self.type = "rare", "misc"
        self.lifesteal_ratio = 0.10

    # after_attack 现在接收的是最终伤害数值
    def after_attack(self, wearer, target, actual_dmg):
        ratio = self.lifesteal_ratio
        if wearer.hp / wearer.max_hp < 0.5:
            ratio *= 2
        
        healed_amount = actual_dmg * ratio
        if healed_amount > 0:
            wearer.heal(healed_amount)

class HourglassOfTime(Equipment):
    """时光沙漏：副手槽；暴击时有40%几率立即重置攻击冷却。"""
    slot = "offhand"
    display_name = "时光沙漏"
    def __init__(self):
        self.rarity, self.type = "uncommon", "armor" # 副手算防具
        self.proc_chance = 0.4

    def on_critical(self, wearer, target, dmg):
        if random.random() < self.proc_chance:
            print("[时光沙漏] 效果触发！")
            # 直接将攻击冷却充满
            wearer._cd = wearer.attack_interval

class Stormcaller(Equipment):
    """风暴召唤者：武器槽；+15攻击；每攻击4次，为敌人附加一层【风暴】印记。"""
    slot = "weapon"
    display_name = "风暴召唤者"
    def __init__(self):
        self.rarity, self.type = "legendary", "weapon"
        self.atk_bonus = 15
        self._attack_count = 0

    def after_attack(self, wearer, target, dmg):
        self._attack_count += 1
        if self._attack_count >= 4:
            self._attack_count = 0
            print("[风暴召唤者] 附加了风暴印记！")
            target.add_debuff(Buffs.StormDebuff(), source=wearer)
# --- 白色 (Common) 品质新装备 ---

class LeatherGloves(Equipment):
    """皮手套：副手槽；+0.3 攻击速度。"""
    slot = "offhand"
    display_name = "皮手套"
    def __init__(self):
        self.rarity, self.type = "common", "armor"
        self.atk_speed_bonus = 0.3

class RustyHelmet(Equipment):
    """生锈的头盔：头盔槽；+30 最大生命值。"""
    slot = "helmet"
    display_name = "生锈的头盔"
    def __init__(self):
        self.rarity, self.type = "common", "armor"
        self.hp_bonus = 30

# --- 绿色 (Uncommon) 品质新装备 ---

class BarbedAxe(Equipment):
    """倒钩斧：武器槽；+5攻击；攻击时有30%几率使敌人【流血】5秒。"""
    slot = "weapon"
    display_name = "倒钩斧"
    def __init__(self):
        self.rarity, self.type = "uncommon", "weapon"
        self.atk_bonus = 5
        self.bleed_chance = 0.3
    def after_attack(self, wearer, target, dmg):
        if random.random() < self.bleed_chance:
            target.add_debuff(Buffs.BleedDebuff(stacks=1), source=wearer)

# 在 Equips.py 文件中，找到并替换 TowerShield 类

class TowerShield(Equipment):
    """塔盾：副手槽；+3防御；战斗开始时，获得3层【格挡】。"""
    slot = "offhand"
    display_name = "塔盾"
    def __init__(self):
        self.rarity, self.type = "uncommon", "armor"
        self.def_bonus = 3
        self.block_stacks = 3

    def on_battle_start(self, wearer):
        wearer.add_buff(Buffs.BlockBuff(stacks=self.block_stacks))
    

# --- 蓝色 (Rare) 品质新装备 ---


class AdventurersPouch(Equipment):
    """冒险家的钱袋：饰品槽；每拥有20金币，就为你提供+1攻击力。（战斗开始时结算）"""
    slot = "accessory"
    display_name = "冒险家的钱袋"
    def __init__(self):
        self.rarity, self.type = "rare", "misc"
        self.atk_bonus = 0 # 初始攻击力加成为0

    def on_battle_start(self, wearer):
        # 在战斗开始时，只计算应该加多少攻击力，并存到自己的属性里
        gold = getattr(wearer, 'gold', 0)
        self.atk_bonus = gold // 20
        if self.atk_bonus > 0:
            print(f"[冒险家的钱袋] 你获得了 {self.atk_bonus} 点额外攻击力！")
            # 重新计算一次总属性，让这个新的atk_bonus生效
            wearer.recalculate_stats()

class ShadowCloak(Equipment):
    """暗影斗篷：护甲槽；+5防御；受到暴击伤害时，有30%概率免疫该次伤害。"""
    slot = "armor"
    display_name = "暗影斗篷"
    def __init__(self):
        self.rarity, self.type = "rare", "armor"
        self.def_bonus = 5
        self.crit_immunity_chance = 0.3
    def before_take_damage(self, wearer, packet: DamagePacket):
        if packet.damage_type == DamageType.PHYSICAL and packet.is_critical:
            if random.random() < self.crit_immunity_chance:
                print("[暗影斗篷] 免疫了暴击伤害！")
                packet.amount = 0

# 在 Equips.py 文件末尾添加

# --- “烙印”体系示例 ---

class SunScorchedBlade(Equipment):
    """日灼之刃 [武器-稀有]：攻击速度+0.5；命中时附加一层【日之烙印】。"""
    slot, display_name = "weapon", "日灼之刃"
    def __init__(self):
        self.rarity, self.type = "rare", "weapon"
        self.atk_speed_bonus = 0.5
    def after_attack(self, wearer, target, actual_dmg):
        target.add_debuff(Buffs.SunstoneBrandDebuff(stacks=1), source=wearer)

class Avalanche(Equipment):
    """山崩 [武器-史诗]：攻击力+20；暴击时引爆目标所有【日之烙印】，每层造成20额外真实伤害。"""
    slot, display_name = "weapon", "山崩"
    def __init__(self):
        self.rarity, self.type = "epic", "weapon"
        self.atk_bonus = 20
    def on_critical(self, wearer, target, actual_dmg):
        # 寻找目标身上的烙印
        brand_debuff = next((b for b in target.buffs if isinstance(b, Buffs.SunstoneBrandDebuff)), None)
        if brand_debuff:
            stacks = brand_debuff.stacks
            print(f"[山崩] 引爆了 {stacks} 层烙印！")
            # 造成额外伤害
            extra_dmg = stacks * 20
            packet = DamagePacket(amount=extra_dmg, damage_type=DamageType.TRUE, source=wearer)
            target.take_damage(packet)
            # 移除烙印
            target.remove_buff(brand_debuff)

# --- “龙魂”体系示例 ---

class DragonBloodChalice(Equipment):
    """龙血酒杯 [饰品-史诗]：每秒失去5点生命，但获得1层【龙魂】。"""
    slot, display_name = "accessory", "龙血酒杯"
    def __init__(self):
        self.rarity, self.type = "epic", "misc"
        self._timer = 0.0
    def on_battle_start(self, wearer):
        self._timer = 0.0 # 重置计时器
    def on_tick(self, wearer, dt): # 需要在 Character.update 中调用 on_tick
        self._timer += dt
        if self._timer >= 1.0:
            self._timer -= 1.0
            # 扣血
            packet = DamagePacket(amount=5, damage_type=DamageType.TRUE, is_sourceless=True)
            wearer.take_damage(packet)
            # 获得龙魂
            wearer.add_buff(Buffs.DragonSoulBuff(stacks=1))

class DragonscaleWard(Equipment):
    """龙鳞盾 [副手-稀有]：战斗开始时，消耗所有【龙魂】，每层提供15点护盾。"""
    slot, display_name = "offhand", "龙鳞盾"
    def __init__(self):
        self.rarity, self.type = "rare", "armor"
    def on_battle_start(self, wearer):
        soul_buff = next((b for b in wearer.buffs if isinstance(b, Buffs.DragonSoulBuff)), None)
        if soul_buff:
            stacks = soul_buff.stacks
            shield_gain = stacks * 15
            print(f"[龙鳞盾] 消耗了 {stacks} 层龙魂，获得了 {shield_gain} 点护盾！")
            wearer.shield += shield_gain
            wearer.remove_buff(soul_buff)

UPGRADE_MAP = {
    WoodenSword: WoodenSword_Star,
    WoodenArmor: WoodenArmor_Star,
    # 在这里继续为你其他的装备添加升级配方...
    # 例如:
    # IronSword: IronSword_Star, 
}


================================================================================
### 文件路径: events.json
================================================================================

{
    "fountain_of_power": {
        "title": "力量源泉",
        "description": "你发现一个散发着微光的源泉。泉水似乎蕴含着奇特的力量，你可以从中感受到生命与毁灭的气息。",
        "choices": [
            {
                "text": "喝一口 (恢复全部生命)",
                "outcomes": [
                    { "type": "HEAL", "amount": "full", "result_text": "泉水让你精神焕发，所有伤痛都消失了！" }
                ]
            },
            {
                "text": "将武器浸入 (风险与机遇)",
                "outcomes": [
                    { "type": "WEAPON_UPGRADE", "chance": 0.6, "result_text": "你的武器吸收了源泉的力量，变得更加锋利了！(攻击力+5)" },
                    { "type": "WEAPON_CURSE", "chance": 0.4, "result_text": "武器无法承受这股力量，反而变得迟钝了...(攻击力-3)" }
                ]
            }
        ]
    },
    "wandering_spirit": {
        "title": "迷途的古代灵魂",
        "description": "一个半透明的灵魂在你面前徘徊，它似乎在寻求帮助，又像是在守护着什么。",
        "choices": [
            {
                "text": "帮助它安息 (获得天赋)",
                "outcomes": [
                    { "type": "GAIN_TALENT", "talent_class_name": "HeartOfHealingTalent", "result_text": "灵魂感激地消散了，你从中领悟了「治愈之心」！" }
                ]
            },
            {
                "text": "攻击它 (触发战斗)",
                "outcomes": [
                    { "type": "TRIGGER_COMBAT", "enemy_id": "goblin_captain", "result_text": "灵魂发出了尖啸，化作一个强大的敌人向你袭来！" }
                ]
            }
        ]
    }
}


================================================================================
### 文件路径: game.py
================================================================================

# game.py (已更新)
import pygame
import pickle
import os
import time
import json
import sys
from settings import *
# <-- 导入 ui 模块，而不仅仅是 init_fonts
import ui
from Character import Character
import Equips
import Talents

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("我的游戏")
        self.clock = pygame.time.Clock()
        self.running = True
        self.fonts = ui.init_fonts()
        self.state_stack = []

        # <-- 核心改动：在游戏启动时加载所有Buff图标资源 -->
        #ui.load_buff_icons()

        self.player = None
        self.current_stage = "1"
        self.loaded_dialogue_index = 0

        self.story_data = self._load_json("story.json")
        self.enemy_data = self._load_json("enemies.json")
        self.loot_data = self._load_json("loot_tables.json")
        self.event_data = self._load_json("events.json")

        self.dungeon_data = {}
        dungeon_folder = 'dungeons'
        for filename in os.listdir(dungeon_folder):
            if filename.endswith('.json'):
                dungeon_id = filename.split('.')[0]
                self.dungeon_data[dungeon_id] = self._load_json(os.path.join(dungeon_folder, filename))

    def run(self):
        from states.title import TitleScreen
        self.state_stack.append(TitleScreen(self))

        while self.running and self.state_stack:
            self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(60)
        
        pygame.quit()
        sys.exit()

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            if self.state_stack:
                self.state_stack[-1].handle_event(event)

    def update(self):
        if self.state_stack:
            self.state_stack[-1].update()

    def draw(self):
        # --- 全新的分层绘制逻辑 ---
        if not self.state_stack:
            pygame.display.flip()
            return

        # 1. 找到最底部的非弹窗界面
        base_state_index = -1
        for i in range(len(self.state_stack) - 1, -1, -1):
            if not getattr(self.state_stack[i], 'is_overlay', False):
                base_state_index = i
                break
        
        # 2. 绘制所有底层界面 (通常只有一个)
        if base_state_index != -1:
            for i in range(base_state_index + 1):
                 self.state_stack[i].draw(self.screen)

        # 3. 逐个绘制所有弹窗界面
        for i in range(base_state_index + 1, len(self.state_stack)):
            self.state_stack[i].draw(self.screen)
        
        pygame.display.flip()

    def _load_json(self, filename):
        try:
            with open(filename, 'r', encoding='utf-8') as f: return json.load(f)
        except Exception as e:
            print(f"ERROR: Could not load {filename}: {e}")
            return None

    def get_save_filename(self, slot_number):
        return f"save_slot_{slot_number}.dat"

    def peek_save_slot(self, slot_number):
        filename = self.get_save_filename(slot_number)
        if not os.path.exists(filename): return None
        try:
            with open(filename, "rb") as f: return pickle.load(f)
        except Exception: return None

    def save_to_slot(self, slot_number):
        filename = self.get_save_filename(slot_number)
        try:
            dialogue_index = 0
            from states.story import StoryScreen
            for state in reversed(self.state_stack):
                if isinstance(state, StoryScreen):
                    dialogue_index = state.dialogue_index; break
            data_to_save = {
                "player": self.player, "current_stage": self.current_stage,
                "dialogue_index": dialogue_index, "timestamp": time.time()
            }
            with open(filename, "wb") as f: pickle.dump(data_to_save, f)
            print(f"Game saved to slot {slot_number}")
            return f"成功保存到槽位 {slot_number}！"
        except Exception as e:
            print(f"Save failed: {e}"); return "存档失败！"

    def load_from_slot(self, slot_number):
        data = self.peek_save_slot(slot_number)
        if data:
            self.player = data["player"]
            self.current_stage = data["current_stage"]
            self.loaded_dialogue_index = data.get("dialogue_index", 0)
            return True
        return False
   
    def start_new_game(self):
        player_eq = [Equips.WoodenSword(), Equips.WoodenArmor(), Equips.NaturalNecklace(), Equips.IronRing()]#
        player_talents = [
            Talents.HeartOfHealingTalent(), # 治愈之心
            Talents.DualWieldTalent(),       # 二刀流
        ]
        self.player = Character(
            "玩家", 
            hp=300, 
            defense=5, 
            magic_resist=3, 
            attack=20, 
            attack_speed=1.2, 
            equipment=player_eq,
            talents=player_talents  # <-- 将天赋列表传给角色
        )
        self.current_stage = "1"
        self.loaded_dialogue_index = 0


================================================================================
### 文件路径: loot_tables.json
================================================================================

{
    "slime": [
        {
            "item_class_name": "SlimeSword",
            "chance": 0.99
        }
    ],
    "goblin": [
        {
            "item_class_name": "IronSword",
            "chance": 0.2
        },
        {
            "item_class_name": "WoodenShield",
            "chance": 0.2
        }
    ],
    "goblin_captain": [
        { "item_class_name": "IronHammer", "chance": 0.25 },
        { "item_class_name": "IronRing", "chance": 0.15 }
    ]
}


================================================================================
### 文件路径: main.py
================================================================================

# main.py
from game import Game
import Equips
print(f"DEBUG: 正在从这个路径加载 Equips.py -> {Equips.__file__}")


if __name__ == "__main__":
    # 确保所有逻辑文件（Buffs, Talents, Equips, Character）都可被导入
    # 确保所有数据文件 (.json) 都在场
    g = Game()
    g.run()


================================================================================
### 文件路径: monster_sprite.py
================================================================================

# monster_sprite.py (已更新)
import pygame
from settings import *

class Monster(pygame.sprite.Sprite):
    def __init__(self, monster_data): # <-- 改为接收整个 data 字典
        super().__init__()
        self.enemy_id = monster_data['id']
        self.uid = monster_data['uid'] # <-- 新增：记录自己的 uid
        
        self.image = pygame.Surface([30, 30])
        color = (255, 0, 0)
        if self.enemy_id == "slime": color = (100, 200, 100)
        elif self.enemy_id == "goblin": color = (200, 150, 50)
        elif self.enemy_id == "ruin_golem": # Boss用大一点的方块和不同颜色
            self.image = pygame.Surface([60, 60])
            color = (150, 50, 200)
        
        self.image.fill(color)
        self.rect = self.image.get_rect(center=monster_data['pos'])

    def update(self):
        pass


================================================================================
### 文件路径: player_sprite.py
================================================================================

# player_sprite.py
import pygame
from settings import *

class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.image = pygame.Surface([40, 40])
        self.image.fill(TEXT_COLOR) # 暂时用一个白色方块代表玩家
        self.rect = self.image.get_rect(center=(x, y))
        self.speed = 5

    def update(self):
        """根据按键更新玩家位置"""
        keys = pygame.key.get_pressed()
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.rect.x -= self.speed
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.rect.x += self.speed
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.rect.y -= self.speed
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.rect.y += self.speed

        # 简单的边界限制，防止跑出屏幕
        if self.rect.left < 0: self.rect.left = 0
        if self.rect.right > SCREEN_WIDTH: self.rect.right = SCREEN_WIDTH
        if self.rect.top < 0: self.rect.top = 0
        if self.rect.bottom > SCREEN_HEIGHT: self.rect.bottom = SCREEN_HEIGHT


================================================================================
### 文件路径: settings.py
================================================================================

# settings.py
import pygame
SCREEN_WIDTH = 1280
SCREEN_HEIGHT = 720
BG_COLOR = (10, 20, 30)
TEXT_COLOR = (230, 230, 230)
HOVER_COLOR = (200, 220, 255) # 鼠标悬停颜色
PANEL_BG_COLOR = (20, 35, 50)
PANEL_BORDER_COLOR = (100, 180, 255)
HP_BAR_GREEN = (0, 200, 0)
SHIELD_BAR_GREY = (150, 150, 150)
FONT_SIZE_NORMAL = 28
FONT_SIZE_SMALL = 22
FONT_SIZE_LARGE = 48
FONT_NAME_CN = 'Microsoft YaHei'
FONT_NAME_EN = 'Consolas'

# --- 新增颜色和尺寸 ---
XP_BAR_COLOR = (150, 100, 255)      # 经验条颜色
LOG_TEXT_COLOR = (200, 200, 200)    # 战斗日志文字颜色
LOG_BG_COLOR = (30, 45, 60, 200)    # 战斗日志背景色 (带透明度)
BUTTON_CLICK_COLOR = (150, 200, 255) # 按钮点击颜色

# Buff/Debuff 图标尺寸
BUFF_ICON_SIZE = (32, 32)

# --- 布局位置 ---
# (这些是建议值，你可以随时调整)
PLAYER_PANEL_RECT = pygame.Rect(50, 450, 500, 250)
ENEMY_PANEL_RECT = pygame.Rect(SCREEN_WIDTH - 550, 50, 500, 250)
BATTLE_LOG_RECT = pygame.Rect(50, 50, SCREEN_WIDTH - 650, 350)


# --- 物品品质颜色 ---
RARITY_COLORS = {
    "common":    (255, 255, 255),  # 白色
    "uncommon":  (30, 255, 30),    # 绿色
    "rare":      (0, 150, 255),   # 蓝色
    "epic":      (180, 50, 255),   # 紫色
    "legendary": (255, 150, 0),    # 橙色
    "mythic":    (255, 50, 50),    # 红色
}


================================================================================
### 文件路径: story.json
================================================================================

{
    "1": {
        "type": "story",
        "text": [
            { "speaker": "旁白", "line": "你睁开眼睛，发现自己身处一片宁静的森林之中。" },
            { "speaker": "旁白", "line": "阳光透过树叶的缝隙洒下，空气中弥漫着青草的气息。" },
            { "speaker": "旁白", "line": "突然，一阵“咕叽咕叽”的声音传来，一只果冻状的生物出现在你面前！" }
        ],
        "next": "2"
    },
    "2": {
        "type": "combat",
        "enemy_id": "slime",
        "next_win": "3",
        "next_lose": "game_over"
    },
    "3": {
        "type": "story",
        "text": [
            { "speaker": "旁白", "line": "你轻松地战胜了史莱姆。" },
            { "speaker": "你", "line": "看来这里的生物并没有想象中那么强大。" },
            { "speaker": "你", "line": "我决定继续深入森林，探索这个未知的世界..." },
            { "speaker": "旁白", "line": "(未完待续)" }
        ],
        "next": "4"
    },
    "4": {
        "type": "story",
        "text": [
            { "speaker": "猎人", "line": "你的第一个任务，就是独自进入那座『日之石遗迹』..." },
            { "speaker": "猎人", "line": "抵达最深处的圣堂，并带回试炼完成的证明。准备好了吗？" },
            { 
                "speaker": "玩家", 
                "line": "我准备好了。",
                "action": "start_trial"
            }
        ],
        "next": "4" 
    },
    "trial_combat": {
        "type": "combat",
        "enemy_id": "slime", 
        "next_win": "map_return", 
        "next_lose": "title"
    },
    "5": {
        "type": "story",
        "text": [
            { "speaker": "旁白", "line": "……" },
            { "speaker": "旁白", "line": "………………" },
            { "speaker": "你", "line": "……唔……好困…………" },
            { "speaker": "旁白", "line": "我的意識就像被黏在天花板上的口香糖，掙扎著想往下掉，卻怎麼也擺脫不了那股黏膩的睡意。" },
            { "speaker": "旁白", "line": "耳邊是「嘎吱、嘎吱」的木頭呻吟聲，那老舊的木板好像隨時都會散架一樣，還有規律得讓人想打瞌睡的海浪拍打船身的「噗通、噗通」悶響。" },
            { "speaker": "旁白", "line": "鼻腔裡充斥著一股鹹澀的海風，混合著老木頭和一點點說不清道不明的魚腥味，嗯，這就是「海上男兒」的浪漫吧，大概。" },
            { "speaker": "旁白", "line": "眼皮就像灌了鉛一樣沉重，比我期末考試前熬夜看漫畫的眼睛還重。" },
            { "speaker": "你", "line": "「再睡五分鐘，就五分鐘……」我心裡嘀咕著，翻了個身。" },
            { "speaker": "你", "line": "……" },
            { "speaker": "你", "line": "等等！現在是什麼時候了？！" }
        ],
        "next": "quit"
    }
}


================================================================================
### 文件路径: Talents.py
================================================================================

import Buffs
from abc import ABC
import collections
from collections import defaultdict
from rich.console import Console, Group
from rich.live import Live
from rich.table import Table
from rich.panel import Panel
from rich.text import Text
import time
import random
from rich.text import Text
from rich.progress import BarColumn  # 可选：也可以直接用 Text
import math
from collections import Counter
#import pygame
import sys
from rich.console import Console

from damage import DamagePacket, DamageType

class Talent:
    """天赋基类，之后可扩展更多钩子"""
    display_name = None
    def on_init(self, wearer):
        """角色创建/战前初始化时触发，用于修改槽位之类的属性"""
        pass
    def on_attack(self, wearer, target, dmg):
        """攻击后触发"""
        pass
    def on_debuff_applied(self, wearer, buff):
        """当一个 Debuff 被加到 wearer 上时触发"""
        pass
        
class PoisonousTalent(Talent):
    display_name = "毒物"
    def __init__(self, chance: float = 0.5):
        self.chance = chance

    def on_attack(self, wearer, target, dmg):
        if random.random() < self.chance:
            target.add_debuff(Buffs.PoisonDebuff(stacks=1), source=wearer)

class DualWieldTalent(Talent):
    """二刀流：武器槽提升到 2"""
    display_name = "二刀流"
    def on_init(self, wearer):
        cur = wearer.SLOT_CAPACITY.get("weapon", 1)
        if cur < 2:
            wearer.SLOT_CAPACITY["weapon"] = 2

class TripleWieldTalent(Talent):
    """三刀流：武器槽提升到 3"""
    display_name = "三刀流"
    def on_init(self, wearer):
        cur = wearer.SLOT_CAPACITY.get("weapon", 1)
        if cur < 3:
            wearer.SLOT_CAPACITY["weapon"] = 3

class ThousandWorldTalent(Talent):
    """三千世界：普攻时有 chance 概率立即额外连续普攻 2 次"""
    display_name = "三千世界"

    def __init__(self, chance: float = 0.33):
        self.chance = chance

    def on_attack(self, wearer, target, dmg):
        """
        在主攻后调用，如果命中且触发了三千世界，
        就返回额外攻击的文本列表；否则返回空列表。
        """
        extra_texts = []
        if random.random() < self.chance:
            # 额外出手两次
            for _ in range(2):
                text = wearer.perform_extra_attack(target)
                extra_texts.append(text)
        return extra_texts

class HeartOfHealingTalent(Talent):
    """治愈之心：被施加可驱散的 Debuff 时，30% 概率驱散此层，并获得 1 层 再生"""
    display_name = "治愈之心"

    def __init__(self, chance: float = 0.3):
        self.chance = chance

    def on_debuff_applied(self, wearer, buff):
        if random.random() < self.chance:
            # 驱散一层
            if hasattr(buff, "stacks"):
                buff.stacks -= 1
                if buff.stacks <= 0:
                    wearer.remove_buff(buff)
            else:
                wearer.remove_buff(buff)
            # 获得 1 层“再生”
            wearer.add_buff(Buffs.RegenerationBuff(stacks=1))

class BambooLeafTalent(Talent):
    display_name = "竹叶青"

    def __init__(self, chance: float = 1.0):
        self.chance = chance
        self._bamboo_atk_bonus = 0  # 上一次总加成
        self._bamboo_spd_bonus = 0

    def on_inflict_debuff(self, wearer, target, buff, added_stacks):
        # 只有是 PoisonDebuff 且概率命中才触发
        if not isinstance(buff, Buffs.PoisonDebuff) or random.random() >= self.chance:
            return

        # ① 给自己加这次相同的层数
        own = next((b for b in wearer.buffs if isinstance(b, Buffs.PoisonDebuff)), None)
        if own:
            own.stacks = min(own.stacks + added_stacks, own.max_stacks)
        else:
            wearer.add_buff(Buffs.PoisonDebuff(stacks=added_stacks))

        # ② 统计当前毒总层数
        total_stacks = next((b.stacks for b in wearer.buffs if isinstance(b, Buffs.PoisonDebuff)), 0)

        # ③ 撤销旧加成
        wearer.attack -= self._bamboo_atk_bonus
        current_as = 6.0 / wearer.attack_interval
        base_as = current_as - self._bamboo_spd_bonus

        # ④ 重新计算加成（基于总毒层数）
        atk_bonus = total_stacks * 1
        spd_bonus = total_stacks * 0.1

        wearer.attack += atk_bonus
        wearer.attack_interval = 6.0 / (base_as + spd_bonus)

        # ⑤ 记录新的加成值
        self._bamboo_atk_bonus = atk_bonus
        self._bamboo_spd_bonus = spd_bonus

class GlassCannon(Talent):
    """【天赋】玻璃大炮：造成的伤害提升50%，受到的伤害也提升30%。"""
    display_name = "玻璃大炮"
    def on_init(self, wearer):
        wearer.attack *= 1.5
        wearer.damage_resistance -= 0.3

class Giant(Talent):
    """【天赋】巨人：最大生命值提升50%，但攻击速度降低20%。"""
    display_name = "巨人"
    def on_init(self, wearer):
        wearer.max_hp *= 1.5
        wearer.hp = wearer.max_hp
        wearer.attack_speed *= 0.8
        wearer.attack_interval = 6.0 / wearer.attack_speed

class Executioner(Talent):
    """【天赋】处决者：对生命值低于30%的敌人造成100%额外伤害。"""
    display_name = "处决者"
    def on_attack(self, wearer, target, dmg):
        if target.hp / target.max_hp < 0.3:
            # 造成一次额外的真实伤害
            packet = DamagePacket(amount=dmg * 1.0, damage_type=DamageType.TRUE, source=wearer)
            target.take_damage(packet)

class Scavenger(Talent):
    """【天赋】清道夫：击败敌人时获得的金币提升50%。"""
    display_name = "清道夫"
    # (此天赋的逻辑需要在给予金币的地方检查)

class MagicShield(Talent):
    """【天赋】法力护盾：获得+20魔法抗性。"""
    display_name = "法力护盾"
    def on_init(self, wearer):
        wearer.magic_resist += 20

class FirstStrike(Talent):
    """【天赋】先发制人：进入战斗后的第一次攻击必定暴击。"""
    display_name = "先发制人"
    def on_init(self, wearer):
        self._used = False
    def on_attack(self, wearer, target, dmg):
        if not self._used:
            # 这个天赋最好在 before_attack 钩子中实现
            pass 
    
class LastStand(Talent):
    """【天赋】背水一战：生命值低于25%时，获得50%伤害减免。"""
    display_name = "背水一战"
    def on_init(self, wearer):
        wearer.damage_resistance_last_stand = 0.5 # 自定义一个属性
    # (此天赋的逻辑需要在 take_damage 中检查)

class AdrenalineRush(Talent):
    """【天赋】肾上腺素：每次杀死敌人，攻击速度提升10%，持续到战斗结束。"""
    display_name = "肾上腺素"
    # (此天赋逻辑复杂，需要战斗系统支持 on_kill 钩子)

# 文件: Talents.py

class Brawler(Talent):
    """【天赋】格斗家：你无法装备副手物品，但你的基础攻击力提升30%。"""
    display_name = "格斗家"
    def on_init(self, wearer):
        # 只是修改规则和基础值，不再调用recalculate_stats
        wearer.SLOT_CAPACITY["offhand"] = 0
        wearer.base_attack *= 1.3 
        # 移除下面这两行
        # wearer.attack = wearer.base_attack
        # wearer.recalculate_stats()

class QuickLearner(Talent):
    """【天赋】速学者：获得的经验值提升25%。"""
    display_name = "速学者"
    # (此天赋的逻辑需要在 add_exp 中检查)


================================================================================
### 文件路径: treasure_sprite.py
================================================================================

# treasure_sprite.py
import pygame
from settings import *

class TreasureChest(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        
        # 将来你可以换成漂亮的宝箱图片
        # 现在我们用一个金色的方块代替
        self.image = pygame.Surface([60, 50])
        self.image.fill((255, 215, 0)) # 金色
        self.rect = self.image.get_rect(center=(x, y))


================================================================================
### 文件路径: ui.py
================================================================================

# ui.py (已更新)
import pygame
import textwrap
import inspect
import os
from collections import deque
from settings import *

def init_fonts():
    fonts = {}
    try:
        fonts['normal'] = pygame.font.SysFont(FONT_NAME_CN, FONT_SIZE_NORMAL)
        fonts['small'] = pygame.font.SysFont(FONT_NAME_CN, FONT_SIZE_SMALL)
        fonts['large'] = pygame.font.SysFont(FONT_NAME_CN, FONT_SIZE_LARGE)
        # <-- 核心修复：在这里创建 'minimap' 字体 -->
        fonts['minimap'] = pygame.font.SysFont(FONT_NAME_CN, 16) 
    except pygame.error:
        print("警告: 未找到指定中文字体，将使用默认字体。")
        fonts['normal'] = pygame.font.Font(None, FONT_SIZE_NORMAL + 4)
        fonts['small'] = pygame.font.Font(None, FONT_SIZE_SMALL + 4)
        fonts['large'] = pygame.font.Font(None, FONT_SIZE_LARGE + 4)
        # <-- 核心修复：确保在默认字体情况下也创建 'minimap' 字体 -->
        fonts['minimap'] = pygame.font.Font(None, 18)
    return fonts

class Button:
    def __init__(self, rect, text, font):
        self.rect = pygame.Rect(rect)
        self.text = text
        self.font = font
        self.is_hovered = False
        self.is_clicked = False
    def handle_event(self, event):
        action_triggered = False
        if event.type == pygame.MOUSEMOTION:
            self.is_hovered = self.rect.collidepoint(event.pos)
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1 and self.is_hovered:
            self.is_clicked = True
            action_triggered = True
        if event.type == pygame.MOUSEBUTTONUP and event.button == 1:
            self.is_clicked = False
        return action_triggered
    def draw(self, surface):
        button_color = PANEL_BG_COLOR
        if self.is_clicked: button_color = BUTTON_CLICK_COLOR
        elif self.is_hovered: button_color = PANEL_BORDER_COLOR
        pygame.draw.rect(surface, button_color, self.rect, border_radius=10)
        pygame.draw.rect(surface, PANEL_BORDER_COLOR, self.rect, 2, border_radius=10)
        text_surf = self.font.render(self.text, True, TEXT_COLOR)
        text_rect = text_surf.get_rect(center=self.rect.center)
        surface.blit(text_surf, text_rect)
def draw_text(surface, text, font, color, rect, aa=True):
    y = rect.top; line_spacing = -2; font_height = font.size("Tg")[1]
    max_chars_per_line = rect.width // font.size("一")[0] if font.size("一")[0] > 0 else 1
    wrapped_text = textwrap.wrap(text, width=max_chars_per_line)
    for line in wrapped_text:
        line_surface = font.render(line, aa, color)
        surface.blit(line_surface, (rect.left, y)); y += font_height + line_spacing
def draw_panel(surface, rect, title, font):
    pygame.draw.rect(surface, PANEL_BG_COLOR, rect, border_radius=10)
    pygame.draw.rect(surface, PANEL_BORDER_COLOR, rect, 3, border_radius=10)
    title_surf = font.render(title, True, TEXT_COLOR)
    title_rect = title_surf.get_rect(center=(rect.centerx, rect.top + 50))
    surface.blit(title_surf, title_rect)
def draw_health_bar(surface, rect, char):
    pygame.draw.rect(surface, (50, 50, 50), rect, border_radius=5)
    hp_percent = char.hp / char.max_hp if char.max_hp > 0 else 0
    hp_width = (rect.width - 4) * hp_percent
    hp_rect = pygame.Rect(rect.left + 2, rect.top + 2, hp_width, rect.height - 4)
    pygame.draw.rect(surface, HP_BAR_GREEN, hp_rect, border_radius=5)
    if char.shield > 0:
        shield_percent = min(char.shield / char.max_hp, 1.0) if char.max_hp > 0 else 0
        shield_width = (rect.width - 4) * shield_percent
        shield_rect = pygame.Rect(rect.right - 2 - shield_width, rect.top + 2, shield_width, rect.height - 4)
        pygame.draw.rect(surface, SHIELD_BAR_GREY, shield_rect, border_radius=5)
    pygame.draw.rect(surface, PANEL_BORDER_COLOR, rect, 2, border_radius=5)
    fonts = init_fonts()
    hp_text = f"{char.name} HP: {int(char.hp)}/{int(char.max_hp)} | 盾: {int(char.shield)}"
    text_surf = fonts['normal'].render(hp_text, True, TEXT_COLOR)
    text_rect = text_surf.get_rect(center=rect.center)
    surface.blit(text_surf, text_rect)
def get_display_name(obj):
    return getattr(obj, 'display_name', obj.__class__.__name__)

# 在 ui.py 文件中，找到并修改这个函数

def init_fonts():
    fonts = {}
    try:
        fonts['normal'] = pygame.font.SysFont(FONT_NAME_CN, FONT_SIZE_NORMAL)
        fonts['small'] = pygame.font.SysFont(FONT_NAME_CN, FONT_SIZE_SMALL)
        fonts['large'] = pygame.font.SysFont(FONT_NAME_CN, FONT_SIZE_LARGE)
        # <-- 新增：为小地图创建一个更小的字体 -->
        fonts['minimap'] = pygame.font.SysFont(FONT_NAME_CN, 16) 
    except pygame.error:
        print("警告: 未找到指定中文字体，将使用默认字体。")
        fonts['normal'] = pygame.font.Font(None, FONT_SIZE_NORMAL + 4)
        fonts['small'] = pygame.font.Font(None, FONT_SIZE_SMALL + 4)
        fonts['large'] = pygame.font.Font(None, FONT_SIZE_LARGE + 4)
        # <-- 新增：默认字体版本 -->
        fonts['minimap'] = pygame.font.Font(None, 18)
    return fonts

buff_icons = {}
def load_buff_icons():
    # <-- 核心改动 1: 确保这里包含了你项目中所有的Buff类名 -->
    icon_names = {
        'SteelHeartBuff': 'steel_heart.png',    # 刚毅
        'RegenerationBuff': 'regeneration.png', # 再生
        'PoisonDebuff': 'poison.png',           # 毒
        'AttackDisabledBuff': 'stun.png',       # 无法攻击 (用眩晕图标)
        'StunDebuff': 'stun.png',               # 眩晕
        'ThornsBuff': 'thorns.png',             # 荆棘
        'PhoenixCrownStage1Buff': 'phoenix.png', # 不灭1
        'PhoenixCrownStage2Buff': 'phoenix.png', # 不灭2
    }
    for buff_class_name, icon_filename in icon_names.items():
        try:
            path = os.path.join('assets', 'icons', icon_filename)
            image = pygame.image.load(path).convert_alpha()
            buff_icons[buff_class_name] = pygame.transform.scale(image, BUFF_ICON_SIZE)
        except pygame.error:
            print(f"警告: 无法加载图标 {path}")
    try: # 加载默认图标
        path = os.path.join('assets', 'icons', 'default.png')
        image = pygame.image.load(path).convert_alpha()
        buff_icons['default'] = pygame.transform.scale(image, BUFF_ICON_SIZE)
    except pygame.error:
        print("警告: 无法加载默认图标 default.png")

def draw_buff_icons(surface, char, x, y):
    # 这个函数现在只负责绘制，并返回它绘制的 (Rect, Buff对象) 列表
    drawn_elements = []
    for i, buff in enumerate(char.buffs):
        if buff.hidden: continue
        icon = buff_icons.get(buff.__class__.__name__, buff_icons.get('default'))
        if icon:
            icon_rect = pygame.Rect(x + i * (BUFF_ICON_SIZE[0] + 5), y, BUFF_ICON_SIZE[0], BUFF_ICON_SIZE[1])
            surface.blit(icon, icon_rect)
            drawn_elements.append((icon_rect, buff)) # 记录位置和对象

            if buff.max_stacks > 1 and buff.stacks > 1:
                fonts = init_fonts()
                stack_surf = fonts['small'].render(str(buff.stacks), True, TEXT_COLOR)
                stack_rect = stack_surf.get_rect(bottomright=(icon_rect.right, icon_rect.bottom))
                pygame.draw.rect(surface, (0,0,0), stack_rect.inflate(4,4))
                surface.blit(stack_surf, stack_rect)
    return drawn_elements


# 在 ui.py 文件中，找到并替换这个函数

# 在 ui.py 文件中，找到并替换这个函数

def draw_character_panel(surface, char, rect, fonts):
    """绘制一个完整的角色信息面板, 并返回可交互UI元素的位置和对象"""
    ui_elements = {'talents': [], 'buffs': []}

    pygame.draw.rect(surface, PANEL_BG_COLOR, rect, border_radius=15)
    pygame.draw.rect(surface, PANEL_BORDER_COLOR, rect, 3, border_radius=15)
    
    name_surf = fonts['large'].render(char.name, True, TEXT_COLOR)
    level_surf = fonts['normal'].render(f"Lv. {char.level}", True, TEXT_COLOR)
    surface.blit(name_surf, (rect.left + 20, rect.top + 15))
    surface.blit(level_surf, (rect.left + name_surf.get_width() + 30, rect.top + 28))

    # ... (血条、经验条、数值的绘制逻辑保持不变) ...
    hp_bar_rect = pygame.Rect(rect.left + 20, rect.top + 80, rect.width - 40, 30)
    hp_percent = char.hp / char.max_hp if char.max_hp > 0 else 0
    hp_width = (hp_bar_rect.width - 4) * hp_percent
    pygame.draw.rect(surface, (50,50,50), hp_bar_rect, border_radius=5)
    pygame.draw.rect(surface, HP_BAR_GREEN, (hp_bar_rect.left + 2, hp_bar_rect.top + 2, hp_width, hp_bar_rect.height - 4), border_radius=5)
    if char.shield > 0:
        shield_percent = min(char.shield / char.max_hp, 1.0)
        shield_width = (hp_bar_rect.width - 4) * shield_percent
        shield_rect_pos = hp_bar_rect.left + 2 + hp_width
        pygame.draw.rect(surface, SHIELD_BAR_GREY, (shield_rect_pos, hp_bar_rect.top + 2, shield_width, hp_bar_rect.height - 4), border_radius=5)
    hp_text = f"{int(char.hp)}/{int(char.max_hp)}" + (f" (+{int(char.shield)})" if char.shield > 0 else "")
    hp_text_surf = fonts['small'].render(hp_text, True, TEXT_COLOR)
    surface.blit(hp_text_surf, hp_text_surf.get_rect(center=hp_bar_rect.center))
    if hasattr(char, 'exp'):
        exp_bar_rect = pygame.Rect(rect.left + 20, rect.top + 120, rect.width - 40, 10)
        pygame.draw.rect(surface, (50,50,50), exp_bar_rect, border_radius=3)
        exp_percent = char.exp / char.exp_to_next_level if char.exp_to_next_level > 0 else 0
        exp_width = exp_bar_rect.width * exp_percent
        pygame.draw.rect(surface, XP_BAR_COLOR, (exp_bar_rect.left, exp_bar_rect.top, exp_width, exp_bar_rect.height), border_radius=3)
    stats_text = f"攻击: {int(char.attack)} | 防御: {int(char.defense)} | 攻速: {char.attack_speed:.2f}"
    stats_surf = fonts['small'].render(stats_text, True, TEXT_COLOR)
    surface.blit(stats_surf, (rect.left + 20, rect.top + 140))

    # --- 核心修复：使用 char.equipped_talents 来获取天赋 ---
    current_x = rect.left + 20
    if char.equipped_talents: # <-- 修改点 1
        talent_label_surf = fonts['small'].render("天赋: ", True, (255, 215, 0))
        surface.blit(talent_label_surf, (current_x, rect.top + 170))
        current_x += talent_label_surf.get_width()

        for i, talent in enumerate(char.equipped_talents): # <-- 修改点 2
            if not talent.display_name: continue
            name_surf = fonts['small'].render(talent.display_name, True, (255, 215, 0))
            name_rect = name_surf.get_rect(left=current_x, top=rect.top + 170)
            surface.blit(name_surf, name_rect)
            ui_elements['talents'].append((name_rect, talent))
            current_x += name_rect.width
            if i < len(char.equipped_talents) - 1: # <-- 修改点 3
                separator_surf = fonts['small'].render(" | ", True, (255, 215, 0))
                surface.blit(separator_surf, (current_x, rect.top + 170))
                current_x += separator_surf.get_width()

    # --- Buff 绘制逻辑保持不变 ---
    current_x = rect.left + 20
    if char.buffs:
        # ... (这部分代码无需修改) ...
        status_label_surf = fonts['small'].render("状态: ", True, TEXT_COLOR)
        surface.blit(status_label_surf, (current_x, rect.top + 200))
        current_x += status_label_surf.get_width()
        visible_buffs = [b for b in char.buffs if not b.hidden]
        for i, buff in enumerate(visible_buffs):
            buff_text = buff.display_name
            if buff.max_stacks > 1 and buff.stacks > 1: buff_text += f"({buff.stacks})"
            color = (255, 80, 80) if buff.is_debuff else (80, 255, 80)
            text_surf = fonts['small'].render(buff_text, True, color)
            text_rect = text_surf.get_rect(left=current_x, top=rect.top + 200)
            surface.blit(text_surf, text_rect)
            ui_elements['buffs'].append((text_rect, buff))
            current_x += text_rect.width
            if i < len(visible_buffs) - 1:
                separator_surf = fonts['small'].render(" | ", True, TEXT_COLOR)
                surface.blit(separator_surf, (current_x, rect.top + 200))
                current_x += separator_surf.get_width()
    
    return ui_elements

# ... (BattleLog 和 TooltipManager 保持不变) ...
class BattleLog:
    def __init__(self, rect, font, max_lines=8):
        self.rect, self.font, self.max_lines = rect, font, max_lines
        self.messages = deque(maxlen=max_lines)
        self.surface = pygame.Surface(self.rect.size, pygame.SRCALPHA)
    def add_message(self, message): self.messages.append(message)
    def draw(self, surface):
        self.surface.fill(LOG_BG_COLOR)
        for i, msg in enumerate(reversed(self.messages)):
            alpha = 255 - (i * 25)
            color = (LOG_TEXT_COLOR[0], LOG_TEXT_COLOR[1], LOG_TEXT_COLOR[2], alpha)
            msg_surf = self.font.render(msg, True, color)
            self.surface.blit(msg_surf, (10, self.rect.height - (len(self.messages) - i) * (self.font.get_height() + 2)))
        surface.blit(self.surface, self.rect.topleft)
class TooltipManager:
    def __init__(self, font, delay=500):
        self.font, self.delay = font, delay
        self.active_item, self.hover_start_time, self.tooltip_surface = None, 0, None
    def _get_description(self, item):
        if not item: return None
        doc = inspect.getdoc(item)
        if not doc: return get_display_name(item)
        display_name = getattr(item, 'display_name', item.__class__.__name__)
        return f"[ {display_name} ]\n" + "-"*20 + f"\n{doc}"
    def update(self, hovered_item):
        now = pygame.time.get_ticks()
        if hovered_item:
            if self.active_item != hovered_item:
                self.active_item, self.hover_start_time, self.tooltip_surface = hovered_item, now, None
            elif now - self.hover_start_time > self.delay and not self.tooltip_surface:
                self._create_tooltip_surface(self._get_description(self.active_item))
        else:
            self.active_item, self.tooltip_surface = None, None
    def _create_tooltip_surface(self, text):
        if not text: return
        lines, wrapped_lines, max_width = text.splitlines(), [], 0
        for line in lines:
            wrapped = textwrap.wrap(line, width=40, replace_whitespace=False)
            if not wrapped: wrapped_lines.append("")
            for wrapped_line in wrapped:
                wrapped_lines.append(wrapped_line)
                line_width = self.font.size(wrapped_line)[0]
                if line_width > max_width: max_width = line_width
        padding, line_height = 15, self.font.get_height()
        total_width, total_height = max_width + padding * 2, len(wrapped_lines) * line_height + padding * 2
        self.tooltip_surface = pygame.Surface((total_width, total_height), pygame.SRCALPHA)
        self.tooltip_surface.fill((20, 35, 50, 230))
        pygame.draw.rect(self.tooltip_surface, PANEL_BORDER_COLOR, self.tooltip_surface.get_rect(), 2, border_radius=8)
        current_y = padding
        for line in wrapped_lines:
            text_surf = self.font.render(line, True, TEXT_COLOR)
            self.tooltip_surface.blit(text_surf, (padding, current_y)); current_y += line_height
    def draw(self, surface):
        if self.tooltip_surface:
            mouse_pos = pygame.mouse.get_pos()
            tooltip_rect = self.tooltip_surface.get_rect(topleft=(mouse_pos[0] + 15, mouse_pos[1] + 15))
            if tooltip_rect.right > SCREEN_WIDTH: tooltip_rect.right = mouse_pos[0] - 15
            if tooltip_rect.bottom > SCREEN_HEIGHT: tooltip_rect.bottom = mouse_pos[1] - 15
            surface.blit(self.tooltip_surface, tooltip_rect)


================================================================================
### 文件路径: dungeons\sunstone_ruins.json
================================================================================


{
    "id": "sunstone_ruins",
    "name": "日之石遗迹",
    "description": "一座被阳光遗忘的古老遗迹，充满了基础的元素生物和哥布林。",

    
    "floor_pools": [
        {
            "floors": [1, 2, 3],
            "monster_pool": ["slime", "goblin", "giant_bat"], 
            "elite_pool": ["goblin_captain", "armored_skeleton"], 
            "boss_id": "ruin_golem",
            "event_pool": ["fountain_of_power", "wandering_spirit"],
            "shop_items": {
                "item_count": 3,
                "rarity_weights": { "common": 70, "uncommon": 30, "rare": 5 }
            },
            "treasure_loot": {
                "item_count": 2,
                "rarity_weights": { "common": 60, "uncommon": 35, "rare": 10, "epic": 1 }
            }
        },
        {
            "floors": [4, 5],
            "monster_pool": ["wild_boar", "forest_spirit", "rock_golem"],
            "elite_pool": ["fire_elemental", "ice_elemental"],
            "boss_id": "dark_knight",
            "event_pool": ["wandering_spirit"],
            "shop_items": {
                "item_count": 4,
                "rarity_weights": { "common": 20, "uncommon": 50, "rare": 25, "epic": 5 }
            },
            "treasure_loot": {
                "item_count": 2,
                "rarity_weights": { "common": 10, "uncommon": 40, "rare": 40, "epic": 10 }
            }
        }
    ]
}


================================================================================
### 文件路径: states\backpack.py
================================================================================

# states/backpack.py (Complete File)
import pygame
import math
from .base import BaseState
from ui import draw_text, draw_panel, get_display_name, TooltipManager, Button
from settings import *

SLOT_CONFIG = {
    "weapon": {"name": "武器", "icon": "武", "color": (255, 100, 100)},
    "offhand": {"name": "副手", "icon": "副", "color": (100, 255, 100)},
    "helmet": {"name": "头盔", "icon": "头", "color": (255, 255, 100)},
    "armor": {"name": "胸甲", "icon": "甲", "color": (100, 100, 255)},
    "pants": {"name": "腿甲", "icon": "腿", "color": (255, 100, 255)},
    "accessory": {"name": "饰品", "icon": "饰", "color": (100, 255, 255)},
}

RARITY_COLORS = {
    "common": (156, 163, 175), "uncommon": (16, 185, 129), "rare": (59, 130, 246),
    "epic": (139, 92, 246), "legendary": (245, 158, 11),
}

class BackpackScreen(BaseState):
    def __init__(self, game):
        super().__init__(game)
        self.is_overlay = True
        self.dragging_item, self.dragging_from, self.dragging_from_info = None, None, {}
        self.selected_category, self.search_text, self.search_active = "all", "", False
        self.hover_slot = None
        self.tooltip_manager = TooltipManager(self.game.fonts['small'])
        self._setup_layout()
        self._setup_animations()

    def _get_font(self, font_name, default_size=20):
        try:
            if hasattr(self.game, 'fonts') and font_name in self.game.fonts: return self.game.fonts[font_name]
        except: pass
        return pygame.font.Font(None, default_size)

    def _setup_layout(self):
        margin, header_height, sidebar_width, char_panel_width = 40, 80, 200, 280
        self.container_rect = pygame.Rect(margin, margin, SCREEN_WIDTH - 2*margin, SCREEN_HEIGHT - 2*margin)
        self.header_rect = pygame.Rect(self.container_rect.x, self.container_rect.y, self.container_rect.width, header_height)
        content_y, content_height = self.header_rect.bottom + 10, self.container_rect.height - header_height - 10
        self.sidebar_rect = pygame.Rect(self.container_rect.x, content_y, sidebar_width, content_height)
        self.character_panel_rect = pygame.Rect(self.container_rect.right - char_panel_width, content_y, char_panel_width, content_height)
        self.inventory_rect = pygame.Rect(self.sidebar_rect.right + 10, content_y, self.character_panel_rect.left - self.sidebar_rect.right - 20, content_height)
        self.search_rect = pygame.Rect(self.inventory_rect.x + 10, self.inventory_rect.y + 10, self.inventory_rect.width - 20, 35)
        self.grid_rect = pygame.Rect(self.inventory_rect.x + 10, self.search_rect.bottom + 15, self.inventory_rect.width - 20, self.inventory_rect.height - 60)
        self._generate_ui_elements()

    def _setup_animations(self): self.hover_animation, self.glow_animation = {}, 0

    def _generate_ui_elements(self):
        self.category_buttons = []
        categories = [("all", "全部"), ("weapon", "武器"), ("armor", "防具"), ("consumable", "消耗"), ("material", "材料"), ("misc", "其他")]
        btn_h, btn_s, start_y = 45, 8, self.sidebar_rect.y + 20
        for i, (cat_id, name) in enumerate(categories):
            rect = pygame.Rect(self.sidebar_rect.x + 15, start_y + i * (btn_h + btn_s), self.sidebar_rect.width - 30, btn_h)
            self.category_buttons.append({"id": cat_id, "name": name, "rect": rect, "hover": False})
        self.backpack_slots = []
        cols, rows, slot_size = 10, 6, min((self.grid_rect.width - 20) // 10 - 5, (self.grid_rect.height - 20) // 6 - 5)
        for row in range(rows):
            for col in range(cols):
                x, y = self.grid_rect.x + 10 + col * (slot_size + 5), self.grid_rect.y + 10 + row * (slot_size + 5)
                self.backpack_slots.append(pygame.Rect(x, y, slot_size, slot_size))
        self._generate_equipment_slots()
        close_btn_rect = pygame.Rect(self.container_rect.right - 45, self.container_rect.top + 10, 35, 35)
        self.close_button = Button(close_btn_rect, "X", self.game.fonts['normal'])

    def _generate_equipment_slots(self):
        self.equipment_slots = {}
        player = self.game.player
        model_rect = pygame.Rect(self.character_panel_rect.x + 15, self.character_panel_rect.y + 15, self.character_panel_rect.width - 30, 300)
        slot_size, spacing = 50, 10
        center_x = model_rect.centerx

        self.equipment_slots["helmet"] = [pygame.Rect(center_x - slot_size/2, model_rect.top + 10, slot_size, slot_size)]
        armor_rect = pygame.Rect(center_x - slot_size/2, model_rect.top + slot_size + spacing + 10, slot_size, slot_size)
        self.equipment_slots["armor"] = [armor_rect]
        self.equipment_slots["pants"] = [pygame.Rect(center_x - slot_size/2, armor_rect.bottom + spacing, slot_size, slot_size)]

        weapon_slots = []
        num_weapon_slots = player.SLOT_CAPACITY.get("weapon", 1)
        for i in range(num_weapon_slots):
            x = armor_rect.left - slot_size - spacing
            y = armor_rect.centery - slot_size/2 + i * (slot_size + spacing)
            weapon_slots.append(pygame.Rect(x, y, slot_size, slot_size))
        self.equipment_slots["weapon"] = weapon_slots

        if player.SLOT_CAPACITY.get("offhand", 0) > 0:
            self.equipment_slots["offhand"] = [pygame.Rect(armor_rect.right + spacing, armor_rect.centery - slot_size/2, slot_size, slot_size)]
        else:
            self.equipment_slots["offhand"] = []

        accessory_slots = []
        num_accessory_slots = player.SLOT_CAPACITY.get("accessory", 0)
        total_accessory_width = num_accessory_slots * slot_size + (num_accessory_slots - 1) * 5
        start_x = model_rect.centerx - total_accessory_width / 2
        accessory_y = model_rect.bottom - slot_size - 10
        for i in range(num_accessory_slots):
            x = start_x + i * (slot_size + 5)
            accessory_slots.append(pygame.Rect(x, accessory_y, slot_size, slot_size))
        self.equipment_slots["accessory"] = accessory_slots

    def handle_event(self, event):
        if self.close_button.handle_event(event): self.game.state_stack.pop(); return
        if event.type == pygame.KEYDOWN:
            if event.key in [pygame.K_b, pygame.K_ESCAPE]:
                if self.dragging_item: self._return_dragging_item()
                self.game.state_stack.pop(); return
            elif event.key == pygame.K_BACKSPACE and self.search_active: self.search_text = self.search_text[:-1]
            elif self.search_active and event.unicode.isprintable(): self.search_text += event.unicode
        elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            if not self.close_button.rect.collidepoint(event.pos): self._handle_mouse_down(event.pos)
        elif event.type == pygame.MOUSEBUTTONUP and event.button == 1: self._handle_mouse_up(event.pos)
        elif event.type == pygame.MOUSEMOTION: self._handle_mouse_motion(event.pos)

    def _handle_mouse_down(self, pos):
        if self.search_rect.collidepoint(pos): self.search_active = True; return
        else: self.search_active = False

        for button in self.category_buttons:
            if button["rect"].collidepoint(pos): self.selected_category = button["id"]; return

        if self.dragging_item: return

        # 从装备槽拾起
        for slot_type, slot_rects in self.equipment_slots.items():
            for i, rect in enumerate(slot_rects):
                if rect.collidepoint(pos) and self.game.player.slots[slot_type][i] is not None:
                    item_to_drag = self.game.player.slots[slot_type][i]
                    self.dragging_item = self.game.player.unequip(item_to_drag) # 使用新的unequip
                    self.dragging_from = 'equipment'
                    self.dragging_from_info = {'slot_type': slot_type, 'index': i}
                    return

        # 从背包拾起
        filtered_items = self._get_filtered_items()
        for i, rect in enumerate(self.backpack_slots):
            if rect.collidepoint(pos) and i < len(filtered_items):
                original_item = filtered_items[i]
                original_index_in_backpack = self.game.player.backpack.index(original_item)
                self.dragging_item = self.game.player.backpack.pop(original_index_in_backpack)
                self.dragging_from = 'backpack'
                self.dragging_from_info = {'index': original_index_in_backpack}
                return

    # --- 2. 替换 _handle_mouse_up 方法 ---
    def _handle_mouse_up(self, pos):
        if not self.dragging_item: return

        player = self.game.player
        source_type = self.dragging_from
        source_info = self.dragging_from_info

        # 检查是否放置在装备槽上
        for slot_type, slot_rects in self.equipment_slots.items():
            for i, rect in enumerate(slot_rects):
                if rect.collidepoint(pos) and self.dragging_item.slot == slot_type:
                    # 使用新的equip方法，并传入精确的索引 i
                    replaced_item = player.equip(self.dragging_item, specific_index=i)

                    # 如果有物品被替换下来，处理它
                    if replaced_item:
                        # 如果拖拽的物品来自背包，则把替换下的物品放回背包
                        if source_type == 'backpack':
                            player.backpack.append(replaced_item)
                        # 如果拖拽的物品来自另一个装备槽（实现交换）
                        elif source_type == 'equipment':
                            # 尝试把被替换的物品，装备回原来的拖拽起始槽
                            player.equip(replaced_item, specific_index=source_info['index'])

                    self.dragging_item = None
                    return

        # 检查是否放置在背包网格上
        if self.grid_rect.collidepoint(pos):
            player.backpack.append(self.dragging_item)
            self.dragging_item = None
            return

        # 如果放置在无效区域，返回原处
        self._return_dragging_item()
        self.dragging_item = None
        
    def _handle_mouse_motion(self, pos):
        for button in self.category_buttons: button["hover"] = button["rect"].collidepoint(pos)
        self.hover_slot = None
        for slot_type, slot_rects in self.equipment_slots.items():
            for i, rect in enumerate(slot_rects):
                if rect.collidepoint(pos): self.hover_slot = (slot_type, i); break

    def _get_filtered_items(self):
        items = self.game.player.backpack.copy()
        if self.selected_category != "all":
            items = [item for item in items if hasattr(item, 'type') and item.type == self.selected_category]
        if self.search_text:
            items = [item for item in items if self.search_text.lower() in get_display_name(item).lower()]
        return items

    def _return_dragging_item(self):
        if not self.dragging_item: return
        if self.dragging_from == 'backpack': 
            self.game.player.backpack.insert(self.dragging_from_info.get('index', 0), self.dragging_item)
        elif self.dragging_from == 'equipment': 
            self.game.player.equip(self.dragging_item)

    def _update_hovers(self):
        if self.dragging_item: self.tooltip_manager.update(None); return
        mouse_pos = pygame.mouse.get_pos()
        hovered_item = None
        all_elements = []
        for slot_type, slot_rects in self.equipment_slots.items():
            equipped_items = self.game.player.slots.get(slot_type, [])
            for i, rect in enumerate(slot_rects):
                if i < len(equipped_items): all_elements.append((rect, equipped_items[i]))
        filtered_items = self._get_filtered_items()
        for i, rect in enumerate(self.backpack_slots):
            if i < len(filtered_items): all_elements.append((rect, filtered_items[i]))
        for rect, obj in all_elements:
            if rect.collidepoint(mouse_pos): hovered_item = obj; break
        self.tooltip_manager.update(hovered_item)

    def update(self, dt=0):
        current_time = pygame.time.get_ticks()
        if not hasattr(self, '_last_time'): self._last_time = current_time
        dt_ms = current_time - self._last_time; self._last_time = current_time; dt_sec = dt_ms / 1000.0
        self.glow_animation = (self.glow_animation + dt_sec * 3) % (2 * math.pi)
        self.animation_offset = math.sin(self.glow_animation) * 2; self._update_hovers()

    def draw(self, surface):
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA); overlay.fill((0, 0, 0, 160)); surface.blit(overlay, (0, 0))
        self._draw_modern_panel(surface, self.container_rect, (25, 30, 50, 240))
        self._draw_header(surface); self._draw_sidebar(surface); self._draw_inventory_area(surface)
        self._draw_character_panel(surface); self._draw_dragging_item(surface)
        self.close_button.draw(surface); self.tooltip_manager.draw(surface)
        if hasattr(self, 'update'): self.update()

    def _draw_modern_panel(self, surface, rect, color, border_color=None):
        pygame.draw.rect(surface, color, rect, border_radius=12)
        if border_color is None: border_color = (70, 80, 100, 180)
        pygame.draw.rect(surface, border_color, rect, width=2, border_radius=12)
        glow_rect = rect.inflate(-4, -4); pygame.draw.rect(surface, (255, 255, 255, 10), glow_rect, width=1, border_radius=10)

    def _draw_header(self, surface):
        header_bg = self.header_rect.inflate(-10, -10); self._draw_modern_panel(surface, header_bg, (35, 40, 65, 200))
        title_font = self._get_font('large', 32); title_text = title_font.render("背包系统", True, (255, 215, 0))
        title_rect = title_text.get_rect(x=header_bg.x + 20, centery=header_bg.centery); surface.blit(title_text, title_rect)

    def _draw_sidebar(self, surface):
        sidebar_bg = self.sidebar_rect.inflate(-5, -5); self._draw_modern_panel(surface, sidebar_bg, (30, 35, 55, 200))
        for button in self.category_buttons:
            is_active, is_hover = button["id"] == self.selected_category, button["hover"]
            if is_active: bg_color, border_color, text_color = (255, 215, 0, 100), (255, 215, 0), (255, 255, 255)
            elif is_hover: bg_color, border_color, text_color = (70, 80, 100, 120), (100, 110, 130), (240, 240, 240)
            else: bg_color, border_color, text_color = (40, 50, 70, 80), (60, 70, 90), (180, 180, 180)
            button_rect = button["rect"]; 
            if is_hover: button_rect = button_rect.move(2 + self.animation_offset, 0)
            pygame.draw.rect(surface, bg_color, button_rect, border_radius=8); pygame.draw.rect(surface, border_color, button_rect, width=2, border_radius=8)
            font = self._get_font('small', 18); text = f"{button['name']}"; text_surface = font.render(text, True, text_color); text_rect = text_surface.get_rect(center=button_rect.center); surface.blit(text_surface, text_rect)

    def _draw_inventory_area(self, surface):
        inventory_bg = self.inventory_rect.inflate(-5, -5); self._draw_modern_panel(surface, inventory_bg, (30, 35, 55, 200))
        search_bg_color, border_color = ((50, 60, 80, 150), (255, 215, 0)) if self.search_active else ((40, 50, 70, 120), (70, 80, 100))
        pygame.draw.rect(surface, search_bg_color, self.search_rect, border_radius=6); pygame.draw.rect(surface, border_color, self.search_rect, width=2, border_radius=6)
        search_font = self._get_font('small', 18); display_text = self.search_text or "搜索物品..."; text_color = (255, 255, 255) if self.search_text else (150, 150, 150)
        search_surface = search_font.render(display_text, True, text_color); search_text_rect = search_surface.get_rect(x=self.search_rect.x + 10, centery=self.search_rect.centery); surface.blit(search_surface, search_text_rect)
        if self.search_active and int(self.glow_animation * 2) % 2: pygame.draw.line(surface, (255, 255, 255), (search_text_rect.right + 2, self.search_rect.y + 8), (search_text_rect.right + 2, self.search_rect.bottom - 8), 2)
        self._draw_backpack_grid(surface)

    def _draw_backpack_grid(self, surface):
        filtered_items = self._get_filtered_items()
        for i, slot_rect in enumerate(self.backpack_slots):
            rarity_color = RARITY_COLORS['common']; bg_color, border_color = (40, 50, 70, 60), (60, 70, 90, 120)
            if i < len(filtered_items): item = filtered_items[i]; rarity = getattr(item, 'rarity', 'common'); rarity_color = RARITY_COLORS.get(rarity, RARITY_COLORS['common']); bg_color, border_color = (*rarity_color, 30), (*rarity_color, 180)
            pygame.draw.rect(surface, bg_color, slot_rect, border_radius=6); pygame.draw.rect(surface, border_color, slot_rect, width=2, border_radius=6)
            if i < len(filtered_items):
                item = filtered_items[i]
                if item != self.dragging_item:
                    item_name = get_display_name(item); font = self._get_font('small', 12) 
                    item_surface = font.render(item_name, True, (255, 255, 255)); 
                    if item_surface.get_width() > slot_rect.width - 8: 
                        item_name = item_name[:5] + ".."
                        item_surface = font.render(item_name, True, (255, 255, 255))
                    item_rect = item_surface.get_rect(center=slot_rect.center); surface.blit(item_surface, item_rect)
                    pygame.draw.rect(surface, rarity_color, (slot_rect.x, slot_rect.y, slot_rect.width, 3), border_top_left_radius=2, border_top_right_radius=2)

    def _draw_character_panel(self, surface):
        panel_bg = self.character_panel_rect.inflate(-5, -5); self._draw_modern_panel(surface, panel_bg, (30, 35, 55, 200))
        model_area = pygame.Rect(panel_bg.x + 15, panel_bg.y + 15, panel_bg.width - 30, 300)
        pygame.draw.rect(surface, (20, 25, 40, 150), model_area, border_radius=10)
        self._draw_equipment_slots(surface); self._draw_character_stats(surface, panel_bg)

    def _draw_equipment_slots(self, surface):
        player = self.game.player # 先获取玩家对象
        for slot_type, slot_rects in self.equipment_slots.items():
            slot_config = SLOT_CONFIG.get(slot_type, {"name": slot_type, "icon": "?", "color": (100, 100, 100)})
            for i, slot_rect in enumerate(slot_rects):
                is_hover = self.hover_slot == (slot_type, i)
                bg_color, border_color = ((*slot_config["color"], 50), slot_config["color"]) if is_hover else ((40, 50, 70, 100), (70, 80, 100))
                
                pygame.draw.rect(surface, bg_color, slot_rect, border_radius=8)
                pygame.draw.rect(surface, border_color, slot_rect, width=2, border_radius=8)
                
                # --- 核心修复在这里 ---
                # 直接从 player.slots 获取指定位置的物品，它可能是真实装备，也可能是 None
                item_in_slot = player.slots[slot_type][i]

                # 判断槽位里是否有物品
                if item_in_slot is not None:
                    # 如果有物品，并且不是正在拖拽的那个，就绘制物品名称
                    if item_in_slot != self.dragging_item:
                        item_name = get_display_name(item_in_slot)
                        font = self._get_font('small', 13)
                        if font.size(item_name)[0] > slot_rect.width - 6: 
                            item_name = item_name[:3] + ".."
                        text = font.render(item_name, True, (255, 255, 255))
                        text_rect = text.get_rect(center=slot_rect.center)
                        surface.blit(text, text_rect)
                else:
                    # 如果没有物品 (值为None)，就绘制插槽的默认名称
                    font = self._get_font('small', 14)
                    text_surf = font.render(slot_config["name"], True, (80, 90, 110))
                    text_rect = text_surf.get_rect(center=slot_rect.center)
                    surface.blit(text_surf, text_rect)
                    
    def _draw_character_stats(self, surface, panel_bg):
        stats_area = pygame.Rect(panel_bg.x + 15, panel_bg.bottom - 185, panel_bg.width - 30, 170)
        pygame.draw.rect(surface, (20, 25, 40, 150), stats_area, border_radius=10)
        player = self.game.player
        stats_data = [("最大生命", f"{int(getattr(player, 'max_hp', 0))}"), ("攻击", f"{int(getattr(player, 'attack', 0))}"), ("防御", f"{int(getattr(player, 'defense', 0))}"), ("攻击速度", f"{getattr(player, 'attack_speed', 0):.2f}"), ("暴击率", f"{getattr(player, 'crit_chance', 0) * 100:.1f}%"), ("暴击伤害", f"{getattr(player, 'crit_multiplier', 0) * 100:.1f}%")]
        stats_font = self.game.fonts['small']; line_height = 26; y_offset = stats_area.y + 12
        for i, (name, value) in enumerate(stats_data):
            y_pos = y_offset + i * line_height
            name_surface = stats_font.render(f"{name}:", True, (180, 180, 180)); name_rect = name_surface.get_rect(x=stats_area.x + 15, centery=y_pos); surface.blit(name_surface, name_rect)
            value_surface = stats_font.render(str(value), True, (255, 215, 0)); value_rect = value_surface.get_rect(right=stats_area.right - 15, centery=y_pos); surface.blit(value_surface, value_rect)

    def _draw_dragging_item(self, surface):
        if self.dragging_item:
            mouse_pos = pygame.mouse.get_pos(); item_name = get_display_name(self.dragging_item)
            font = self._get_font('normal', 20); text_surface = font.render(item_name, True, (255, 255, 255)); text_rect = text_surface.get_rect(center=mouse_pos)
            bg_rect = text_rect.inflate(20, 12); pygame.draw.rect(surface, (40, 50, 80, 220), bg_rect, border_radius=8); pygame.draw.rect(surface, (255, 215, 0), bg_rect, width=2, border_radius=8); surface.blit(text_surface, text_rect)


================================================================================
### 文件路径: states\base.py
================================================================================

# states/base.py
class BaseState:
    def __init__(self, game):
        self.game = game

    def handle_event(self, event):
        """处理该状态下的单个事件"""
        pass

    def update(self):
        """更新该状态下的逻辑（非事件驱动）"""
        pass

    def draw(self, surface):
        """绘制该状态的画面"""
        pass


================================================================================
### 文件路径: states\choice_screen.py
================================================================================

# states/choice_screen.py (已修正)
import pygame
import inspect
from .base import BaseState
from ui import Button, draw_panel, draw_text
from settings import *

# states/choice_screen.py (修改这个函数)

class ChoiceScreen(BaseState):
    def __init__(self, game, item_choices, origin_room):
        super().__init__(game)
        self.is_overlay = True
        self.item_choices = item_choices
        self.origin_room = origin_room
        self.choice_buttons = []

        # --- 关键修复 3: 初始化“门锁” ---
        # 初始状态下，门是“未上锁”的，允许玩家做出选择。
        self.choice_made = False

        self._setup_ui()

    def _setup_ui(self):
        # ... (此方法无需修改) ...
        num_choices = len(self.item_choices)
        panel_width = 350 * num_choices + 100; panel_height = 500
        panel_rect = pygame.Rect(0, 0, panel_width, panel_height); panel_rect.center = (SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2)
        self.panel_rect = panel_rect
        card_width, card_height, spacing = 300, 400, 50
        start_x = panel_rect.centerx - (card_width * num_choices + spacing * (num_choices - 1)) / 2
        for i, item in enumerate(self.item_choices):
            card_x = start_x + i * (card_width + spacing)
            card_rect = pygame.Rect(panel_rect.y + 80, card_x,  card_width, card_height); card_rect.topleft = (card_x, panel_rect.y + 80)
            button = Button(card_rect, "", self.game.fonts['normal']); self.choice_buttons.append((button, item))

# states/choice_screen.py (替换这个函数)

def handle_event(self, event):
    # 如果门已经“锁上”，则不处理任何后续的点击事件，防止重复触发
    if self.choice_made:
        return

    for button, item in self.choice_buttons:
        # 检查按钮是否被点击
        if button.handle_event(event):

            # --- 关键修复 1: 立刻“上锁”！ ---
            # 一旦玩家做出选择，马上设置标志位，防止任何后续的重复点击。
            self.choice_made = True 

            # 执行拾取物品的逻辑
            feedback = self.game.player.pickup_item(item)
            if feedback:
                from .notification_screen import NotificationScreen
                self.game.state_stack.append(NotificationScreen(self.game, feedback))

            print(f"玩家选择了: {getattr(item, 'display_name', item.__class__.__name__)}")

            # 将房间标记为“已清理”
            self.origin_room.is_cleared = True

            # 更新底层的地牢界面，让门显示出来
            from .dungeon_screen import DungeonScreen
            # 安全地检查状态栈，确保前一个界面是 DungeonScreen
            if len(self.game.state_stack) > 1:
                prev_state = self.game.state_stack[-2]
                if isinstance(prev_state, DungeonScreen):
                    prev_state.door_rects = prev_state._generate_doors()

            # --- 关键修复 2: “演员”退场！ ---
            # 在所有逻辑处理完毕后，将自己从状态栈中弹出。
            self.game.state_stack.pop() 

            # 因为已经处理完并退出了，直接 return 结束该函数
            return
    # ... (draw 方法无需修改) ...
    def draw(self, surface):
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA); overlay.fill((0, 0, 0, 180)); surface.blit(overlay, (0, 0))
        draw_panel(surface, self.panel_rect, "二选一", self.game.fonts['large'])
        for button, item in self.choice_buttons:
            bg_color = PANEL_BORDER_COLOR if button.is_hovered else PANEL_BG_COLOR
            pygame.draw.rect(surface, bg_color, button.rect, border_radius=10); pygame.draw.rect(surface, PANEL_BORDER_COLOR, button.rect, 2, border_radius=10)
            name = getattr(item, 'display_name', item.__class__.__name__); rarity = getattr(item, 'rarity', 'common'); color = RARITY_COLORS.get(rarity, RARITY_COLORS['common'])
            name_surf = self.game.fonts['normal'].render(f"[ {name} ]", True, color)
            name_rect = name_surf.get_rect(centerx=button.rect.centerx, top=button.rect.top + 20); surface.blit(name_surf, name_rect)
            line_y = name_rect.bottom + 10; pygame.draw.line(surface, PANEL_BORDER_COLOR, (button.rect.left + 20, line_y), (button.rect.right - 20, line_y))
            doc = inspect.getdoc(item) or "效果未知。"; text_rect = button.rect.inflate(-40, -120); text_rect.top = line_y + 15
            draw_text(surface, doc, self.game.fonts['small'], TEXT_COLOR, text_rect)


================================================================================
### 文件路径: states\combat.py
================================================================================

# states/combat.py (已更新)
import pygame
import time
import random # 导入 random
from .base import BaseState
from ui import draw_character_panel, BattleLog, TooltipManager, Button, draw_panel
from settings import *
from Character import Character
import Talents

class CombatScreen(BaseState):
    def __init__(self, game, enemy_id, origin_identifier=None):
        super().__init__(game)
        self.enemy_id = enemy_id
        self.origin_id = origin_identifier
        
        self._initialize_combat()
        self.tooltip_manager = TooltipManager(self.game.fonts['small'])
        self.player_ui_elements, self.enemy_ui_elements = {}, {}
        self.is_paused = False
        pause_button_rect = pygame.Rect(SCREEN_WIDTH - 60, 10, 50, 50)
        self.pause_button = Button(pause_button_rect, "||", self.game.fonts['normal'])

    def _initialize_combat(self):
        enemy_preset = self.game.enemy_data[self.enemy_id]
        
        # --- 核心改动：敌人的随机天赋生成逻辑 ---
        rolled_talents = []
        possible_talents = enemy_preset.get("possible_talents", [])
        for talent_info in possible_talents:
            if random.random() < talent_info["chance"]:
                talent_class_name = talent_info["talent_class_name"]
                if hasattr(Talents, talent_class_name):
                    print(f"敌人 {enemy_preset['name']} 获得了天赋: {talent_class_name}")
                    talent_class = getattr(Talents, talent_class_name)
                    rolled_talents.append(talent_class())
        
        # 使用随机生成的天赋来创建敌人实例
        self.enemy = Character(
            id=self.enemy_id, # <-- 增加这一行，把从json读到的id传给Character
            name=enemy_preset["name"], 
            talents=rolled_talents, 
            **enemy_preset["stats"]
        )
        
        # --- 后续逻辑不变 ---
        self.game.player.on_enter_combat(); self.enemy.on_enter_combat()
        for eq in self.game.player.all_equipment: eq.on_battle_start(self.game.player)
        for eq in self.enemy.all_equipment: eq.on_battle_start(self.enemy)
        self.last_update_time = time.time()
        self.battle_log = BattleLog(BATTLE_LOG_RECT, self.game.fonts['small'])
        self.battle_log.add_message(f"战斗开始！遭遇了 {self.enemy.name}！")

    # 在 states/combat.py 文件中，找到并替换这个函数

    def _on_victory(self):
        """战斗胜利后的处理逻辑"""
        from .dungeon_screen import DungeonScreen
        from .loot import LootScreen
        from .title import TitleScreen

        next_story_stage_id = None
        # 判断战斗来源
        if len(self.game.state_stack) > 1 and isinstance(self.game.state_stack[-2], DungeonScreen):
            # --- 地牢战斗 ---
            dungeon_screen = self.game.state_stack[-2]
            if self.origin_id:
                dungeon_screen.on_monster_defeated(self.origin_id)
        else:
            # --- 剧情战斗 ---
            print("主线剧情战斗胜利！")
            current_stage_data = self.game.story_data.get(self.game.current_stage, {})
            next_story_stage_id = current_stage_data.get("next_win")

        # 弹出自己 (CombatScreen)
        self.game.state_stack.pop()

        # --- 核心修改在这里 ---
        # 之前我们传递的是 self.enemy_id (一个字符串)
        # 现在我们传递整个 self.enemy 对象，它包含了敌人的所有实时信息！
        self.game.state_stack.append(LootScreen(self.game, self.enemy, next_story_stage=next_story_stage_id))
        
    def update(self):
        if self.is_paused: return
        from .title import TitleScreen
        now = time.time(); dt = now - self.last_update_time; self.last_update_time = now
        for msg in self.game.player.update(dt): self.battle_log.add_message(msg)
        for msg in self.enemy.update(dt): self.battle_log.add_message(msg)
        player_res = self.game.player.try_attack(self.enemy, dt)
        if player_res: main, extra = player_res; self.battle_log.add_message(main); [self.battle_log.add_message(f"  └ {e}") for e in extra]
        enemy_res = self.enemy.try_attack(self.game.player, dt)
        if enemy_res: main, extra = enemy_res; self.battle_log.add_message(main); [self.battle_log.add_message(f"  └ {e}") for e in extra]
        self._update_hovers()
        if self.enemy.hp <= 0: self._on_victory()
        elif self.game.player.hp <= 0: self.game.state_stack = [TitleScreen(self.game)]
    def _update_hovers(self):
        mouse_pos = pygame.mouse.get_pos(); hovered_object = None
        all_elements = self.player_ui_elements.get('talents', []) + self.player_ui_elements.get('buffs', []) + \
                       self.enemy_ui_elements.get('talents', []) + self.enemy_ui_elements.get('buffs', [])
        for rect, obj in all_elements:
            if rect.collidepoint(mouse_pos): hovered_object = obj; break
        self.tooltip_manager.update(hovered_object)
    def draw(self, surface):
        surface.fill(BG_COLOR)
        self.player_ui_elements = draw_character_panel(surface, self.game.player, PLAYER_PANEL_RECT, self.game.fonts)
        self.enemy_ui_elements = draw_character_panel(surface, self.enemy, ENEMY_PANEL_RECT, self.game.fonts)
        self.battle_log.draw(surface); self.pause_button.draw(surface)
        if self.is_paused:
            overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA); overlay.fill((0, 0, 0, 180)); surface.blit(overlay, (0, 0))
            paused_rect = pygame.Rect(0, 0, 400, 200); paused_rect.center = (SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2)
            draw_panel(surface, paused_rect, "游戏已暂停", self.game.fonts['large'])
        self.tooltip_manager.draw(surface)
    def handle_event(self, event):
        if self.pause_button.handle_event(event) or (event.type == pygame.KEYDOWN and event.key == pygame.K_p):
            self.is_paused = not self.is_paused;
            if not self.is_paused: self.last_update_time = time.time()
            return
        if self.is_paused: return
        from .confirm_dialog import ConfirmDialog; from .title import TitleScreen
        if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
            def on_confirm_action(): self.game.state_stack = [TitleScreen(self.game)]
            confirm_dialog = ConfirmDialog(self.game, "所有战斗进度都将丢失，确定要返回主菜单吗？", on_confirm_action)
            self.game.state_stack.append(confirm_dialog)


================================================================================
### 文件路径: states\combat_victory.py
================================================================================

# states/combat_victory.py
import pygame
from .base import BaseState
# <-- 导入新的UI工具
from ui import draw_character_panel, draw_panel, Button
from settings import *

class CombatVictoryScreen(BaseState):
    def __init__(self, game, final_enemy):
        super().__init__(game)
        self.final_enemy = final_enemy
        # <-- 新增：创建一个继续按钮
        self.continue_button = Button(
            (SCREEN_WIDTH / 2 - 150, SCREEN_HEIGHT - 100, 300, 60),
            "进入结算",
            self.game.fonts['normal']
        )

    def handle_event(self, event):
        from states.loot import LootScreen
        # <-- 使用按钮的 handle_event 方法
        if self.continue_button.handle_event(event) or \
           (event.type == pygame.KEYDOWN and event.key in [pygame.K_RETURN, pygame.K_SPACE]):
            self.game.state_stack.pop()
            self.game.state_stack.append(LootScreen(self.game))

    def draw(self, surface):
        surface.fill(BG_COLOR)
        # <-- 保持风格统一，继续使用角色面板显示最终状态
        draw_character_panel(surface, self.game.player, PLAYER_PANEL_RECT, self.game.fonts)
        draw_character_panel(surface, self.final_enemy, ENEMY_PANEL_RECT, self.game.fonts)

        # <-- 使用一个面板来显示胜利信息，更有仪式感
        victory_panel_rect = pygame.Rect(SCREEN_WIDTH * 0.25, SCREEN_HEIGHT / 2 - 100, SCREEN_WIDTH * 0.5, 200)
        draw_panel(surface, victory_panel_rect, "战斗胜利！", self.game.fonts['large'])
        
        # <-- 绘制按钮
        self.continue_button.draw(surface)


================================================================================
### 文件路径: states\confirm_dialog.py
================================================================================

# states/confirm_dialog.py
import pygame
from .base import BaseState
from ui import Button, draw_text, draw_panel
from settings import *

class ConfirmDialog(BaseState):
    def __init__(self, game, text, on_confirm):
        super().__init__(game)
        self.is_overlay = True
        self.text = text
        self.on_confirm = on_confirm # 接受一个“确认”后要执行的函数

        # 定义UI元素
        panel_w, panel_h = 600, 300
        self.panel_rect = pygame.Rect((SCREEN_WIDTH - panel_w) / 2, (SCREEN_HEIGHT - panel_h) / 2, panel_w, panel_h)
        
        btn_w, btn_h = 150, 60
        self.yes_button = Button((self.panel_rect.centerx - btn_w - 20, self.panel_rect.bottom - 100, btn_w, btn_h), "确认", self.game.fonts['normal'])
        self.no_button = Button((self.panel_rect.centerx + 20, self.panel_rect.bottom - 100, btn_w, btn_h), "取消", self.game.fonts['normal'])

    def handle_event(self, event):
        if self.yes_button.handle_event(event):
            self.on_confirm() # 执行确认操作
        
        if self.no_button.handle_event(event):
            self.game.state_stack.pop() # 点击“取消”，只弹出自己

        if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
            self.game.state_stack.pop() # 按ESC也视为取消

    def draw(self, surface):
        
        
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))

        # 2. 绘制对话框面板
        draw_panel(surface, self.panel_rect, "请确认", self.game.fonts['large'])
        
        # 3. 绘制提示文字
        text_rect = self.panel_rect.inflate(-80, -80)
        text_rect.h = 100 # 限制文字区域高度
        draw_text(surface, self.text, self.game.fonts['normal'], TEXT_COLOR, text_rect)

        # 4. 绘制按钮
        self.yes_button.draw(surface)
        self.no_button.draw(surface)


================================================================================
### 文件路径: states\dungeon_screen.py
================================================================================

import pygame
import random
from .base import BaseState
from dungeon_generator import Floor
from player_sprite import Player
from monster_sprite import Monster
from treasure_sprite import TreasureChest
import Equips
from settings import *
from ui import Button

NODE_STYLE = {"start": {"color": (100, 255, 100)},"combat": {"color": (200, 200, 200)}, "event": {"color": (255, 255, 100)},"treasure": {"color": (255, 215, 0)},"elite": {"color": (255, 50, 50)},"boss": {"color": (160, 32, 240)},"rest": {"color": (100, 200, 255)},"shop": {"color": (100, 255, 200)},"forge": {"color": (150, 150, 150)}}

# File: states/dungeon_screen.py

class DungeonScreen(BaseState):
    def __init__(self, game, dungeon_id="sunstone_ruins", floor_number=1):
        super().__init__(game)

        self.dungeon_id = dungeon_id
        self.floor_number = floor_number
        self.dungeon_data = self.game.dungeon_data[dungeon_id]

        # Find the correct data pool for the current floor
        self.current_floor_data = None
        for pool in self.dungeon_data.get("floor_pools", []):
            if self.floor_number in pool["floors"]:
                self.current_floor_data = pool
                break

        self.floor = Floor()
        # Pass the floor data to the generator
        self.floor.generate_floor(num_rooms=8, floor_data=self.current_floor_data)

        self.player = Player(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2)
        self.player_group = pygame.sprite.GroupSingle(self.player)
        self.monster_group, self.chest_group = pygame.sprite.Group(), pygame.sprite.GroupSingle()
        self.door_rects, self.exit_portal_button = {}, None
        self.current_room = self.floor.start_room
        self._enter_room(self.current_room)

        # UI Buttons
        backpack_button_rect = pygame.Rect(SCREEN_WIDTH - 160, 10, 140, 50)
        self.backpack_button = Button(backpack_button_rect, "背包 (B)", self.game.fonts['small'])

        talents_button_rect = pygame.Rect(backpack_button_rect.left - 150, 10, 140, 50)
        self.talents_button = Button(talents_button_rect, "天赋 (T)", self.game.fonts['small'])

    # 文件: states/dungeon_screen.py (替换这个函数)

    def _enter_room(self, room):
        self.current_room = room
        if not (self.current_room.type == 'boss' and self.current_room.is_cleared):
            self.exit_portal_button = None
        print(f"进入房间 ({room.x}, {room.y}), 类型: {room.type}")

        # --- 核心改动在这里 ---
        room_type = self.current_room.type
        is_cleared = self.current_room.is_cleared

        # 只有未清理过的特殊房间才会触发一次性事件
        if not is_cleared:
            if room_type == "event":
                from .event_screen import EventScreen
                event_id = random.choice(list(self.game.event_data.keys()))
                self.game.state_stack.append(EventScreen(self.game, event_id, self.current_room))
            elif room_type == "shop":
                from .shop_screen import ShopScreen
                self.game.state_stack.append(ShopScreen(self.game, self.current_room))
            
            # --- 新增的分支 ---
            elif room_type == "rest":
                from .rest_screen import RestScreen # 导入我们刚创建的休息界面
                # 弹出休息界面，并把当前房间信息传过去
                self.game.state_stack.append(RestScreen(self.game, self.current_room))

        self._sync_sprites()
        self.door_rects = self._generate_doors()

    def _generate_doors(self):
        if not self.current_room.is_cleared: return {}
        doors = {}; door_size, margin = 60, 10
        if self.current_room.doors["N"]: doors["N"] = pygame.Rect(SCREEN_WIDTH/2 - door_size/2, 0, door_size, margin)
        if self.current_room.doors["S"]: doors["S"] = pygame.Rect(SCREEN_WIDTH/2 - door_size/2, SCREEN_HEIGHT - margin, door_size, margin)
        if self.current_room.doors["W"]: doors["W"] = pygame.Rect(0, SCREEN_HEIGHT/2 - door_size/2, margin, door_size)
        if self.current_room.doors["E"]: doors["E"] = pygame.Rect(SCREEN_WIDTH - margin, SCREEN_HEIGHT/2 - door_size/2, margin, door_size)
        return doors
        
    def _sync_sprites(self):
        self.monster_group.empty()
        self.chest_group.empty()

        if not self.current_room.is_cleared:
            if self.current_room.type in ["combat", "elite", "boss"]:
                for monster_data in self.current_room.monsters:
                    self.monster_group.add(Monster(monster_data))
            elif self.current_room.type == "treasure":
                self.chest_group.add(TreasureChest(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2))

    def _open_treasure_chest(self, chest_sprite):
        """打开宝箱，并根据当前楼层配置(JSON)生成选项"""
        print("打开宝-箱！")
        
        # --- 核心逻辑：从当前楼层数据中，读取宝箱的配置 ---
        # self.current_floor_data 是在 __init__ 中从JSON加载的
        if not self.current_floor_data or "treasure_loot" not in self.current_floor_data:
            print("错误：在dungeon_data.json中未找到当前楼层的 treasure_loot 配置！")
            # 即使出错，也要清理现场，防止玩家卡住
            self.current_room.is_cleared = True
            self.door_rects = self._generate_doors()
            chest_sprite.kill()
            return

        loot_config = self.current_floor_data["treasure_loot"]
        rarity_weights = loot_config.get("rarity_weights", {"common": 100})
        item_count = loot_config.get("item_count", 2)
        
        # 1. 创建一个所有装备的“数据库”，按品质分类
        item_pool = {rarity: [] for rarity in rarity_weights.keys()}
        all_item_classes = [getattr(Equips, name) for name in dir(Equips) if 
                            isinstance(getattr(Equips, name), type) and 
                            issubclass(getattr(Equips, name), Equips.Equipment) and 
                            getattr(Equips, name) is not Equips.Equipment]
        
        for item_class in all_item_classes:
            temp_item = item_class()
            if hasattr(temp_item, 'rarity') and temp_item.rarity in item_pool:
                item_pool[temp_item.rarity].append(item_class)

        # 2. 根据从JSON读来的权重，随机选择品质
        rarities_to_spawn = random.choices(
            list(rarity_weights.keys()), 
            weights=list(rarity_weights.values()), 
            k=item_count
        )

        # 3. 从对应品质的池子里，随机挑选物品
        choices = []
        for rarity in rarities_to_spawn:
            if item_pool.get(rarity):
                item_class = random.choice(item_pool[rarity])
                choices.append(item_class())

        # 4. 如果未能生成任何物品，则给出提示并退出
        if not choices:
            print("错误: 物品池为空或未能根据规则生成任何物品！")
            self.current_room.is_cleared = True
            self.door_rects = self._generate_doors()
            chest_sprite.kill()
            return

        # 5. 弹出选择界面
        from .choice_screen import ChoiceScreen
        self.game.state_stack.append(ChoiceScreen(self.game, choices, self.current_room))
        
        chest_sprite.kill()
        
    def on_monster_defeated(self, defeated_monster_uid):
        self.current_room.monsters = [m for m in self.current_room.monsters if m['uid'] != defeated_monster_uid]
        self._sync_sprites()
        if not self.current_room.monsters:
            self.current_room.is_cleared = True; self.door_rects = self._generate_doors()
            if self.current_room.type == "boss":
                portal_rect = pygame.Rect(0,0,200,80); portal_rect.center = (SCREEN_WIDTH/2, SCREEN_HEIGHT/2)
                self.exit_portal_button = Button(portal_rect, "前往下一层", self.game.fonts['normal'])

    def update(self):
        self.player_group.update()
        if not self.current_room.is_cleared:
            self.monster_group.update()
            collided_monster = pygame.sprite.spritecollideany(self.player, self.monster_group)
            if collided_monster:
                from .combat import CombatScreen
                self.game.state_stack.append(CombatScreen(self.game, collided_monster.enemy_id, collided_monster.uid))
                self.monster_group.empty(); return
        else:
            for direction, door_rect in self.door_rects.items():
                if self.player.rect.colliderect(door_rect):
                    self._change_room(direction); break
    
    def _change_room(self, direction):
        x, y = self.current_room.x, self.current_room.y; next_room_coord = None
        if direction == "N": next_room_coord = (x, y - 1)
        if direction == "S": next_room_coord = (x, y + 1)
        if direction == "W": next_room_coord = (x - 1, y)
        if direction == "E": next_room_coord = (x + 1, y)
        if next_room_coord in self.floor.rooms:
            next_room = self.floor.rooms[next_room_coord]; self._enter_room(next_room)
            if direction == "N": self.player.rect.bottom = SCREEN_HEIGHT - 15
            if direction == "S": self.player.rect.top = 15
            if direction == "W": self.player.rect.right = SCREEN_WIDTH - 15
            if direction == "E": self.player.rect.left = 15

    def draw(self, surface):
        surface.fill(BG_COLOR)
        for door_rect in self.door_rects.values(): pygame.draw.rect(surface, (100, 200, 100), door_rect)
        if self.exit_portal_button: self.exit_portal_button.draw(surface)
        self.monster_group.draw(surface); self.chest_group.draw(surface)
        self.player_group.draw(surface)
        self._draw_minimap(surface)
        self.backpack_button.draw(surface)
        self.talents_button.draw(surface) # <-- 新增：绘制天赋按钮
        
    def _draw_minimap(self, surface):
        minimap_rect = pygame.Rect(10, 10, 230, 230)
        pygame.draw.rect(surface, PANEL_BG_COLOR, minimap_rect); pygame.draw.rect(surface, PANEL_BORDER_COLOR, minimap_rect, 2)
        cell_size = 15
        for (x, y), room in self.floor.rooms.items():
            map_x, map_y = minimap_rect.x + x*cell_size + 5, minimap_rect.y + y*cell_size + 5
            cell_rect = pygame.Rect(map_x, map_y, cell_size - 1, cell_size - 1)
            base_color = NODE_STYLE.get(room.type, {"color": (255,255,255)})["color"]
            final_color = base_color
            if not room.is_cleared and room.type != "start":
                final_color = (base_color[0] // 2, base_color[1] // 2, base_color[2] // 2)
            pygame.draw.rect(surface, final_color, cell_rect)
            if room is self.current_room:
                p1 = (cell_rect.centerx, cell_rect.top + 3); p2 = (cell_rect.left + 3, cell_rect.bottom - 3); p3 = (cell_rect.right - 3, cell_rect.bottom - 3)
                pygame.draw.polygon(surface, (255, 255, 255, 200), [p1, p2, p3])


================================================================================
### 文件路径: states\event_screen.py
================================================================================

# states/event_screen.py
import pygame
import random
from .base import BaseState
from ui import Button, draw_panel, draw_text
from settings import *
import Talents # 导入天赋模块

class EventScreen(BaseState):
    def __init__(self, game, event_id, origin_room):
        super().__init__(game)
        self.is_overlay = True
        self.event_data = self.game.event_data[event_id]
        self.origin_room = origin_room
        
        # 界面状态管理：'choosing' (选择中) 或 'showing_result' (显示结果)
        self.view_mode = 'choosing' 
        self.result_text = ""
        
        self._setup_ui()

    def _setup_ui(self):
        # 面板
        panel_w, panel_h = 800, 500
        self.panel_rect = pygame.Rect((SCREEN_WIDTH - panel_w) / 2, (SCREEN_HEIGHT - panel_h) / 2, panel_w, panel_h)
        
        # 选项按钮
        self.choice_buttons = []
        btn_w, btn_h = 600, 60
        num_choices = len(self.event_data["choices"])
        start_y = self.panel_rect.bottom - (btn_h + 20) * num_choices - 20
        
        for i, choice in enumerate(self.event_data["choices"]):
            rect = pygame.Rect(self.panel_rect.centerx - btn_w / 2, start_y + i * (btn_h + 20), btn_w, btn_h)
            self.choice_buttons.append(Button(rect, choice["text"], self.game.fonts['normal']))
            
        # “继续”按钮（用于显示结果后）
        self.continue_button = Button(self.choice_buttons[-1].rect, "继续...", self.game.fonts['normal'])

    def handle_event(self, event):
        if self.view_mode == 'choosing':
            for i, button in enumerate(self.choice_buttons):
                if button.handle_event(event):
                    self._process_choice(i)
                    return
        elif self.view_mode == 'showing_result':
            if self.continue_button.handle_event(event):
                self._leave_event()

    # 在 states/event_screen.py 文件中，找到并替换这个函数

    def _process_choice(self, choice_index):
        """处理玩家的选择并计算结果"""
        choice_data = self.event_data["choices"][choice_index]
        outcomes = choice_data["outcomes"]
        
        rand_val = random.random()
        cumulative_chance = 0.0
        selected_outcome = None
        for outcome in outcomes:
            cumulative_chance += outcome.get("chance", 1.0)
            if rand_val < cumulative_chance:
                selected_outcome = outcome
                break
        
        if not selected_outcome: return

        outcome_type = selected_outcome["type"]
        self.result_text = selected_outcome["result_text"]
        
        player = self.game.player
        if outcome_type == "HEAL":
            if selected_outcome["amount"] == "full":
                player.hp = player.max_hp
        
        elif outcome_type == "WEAPON_UPGRADE":
            player.base_attack += 5
            player.attack += 5
        
        elif outcome_type == "WEAPON_CURSE":
            player.base_attack = max(1, player.base_attack - 3)
            player.attack = max(1, player.attack - 3)
            
        # --- 核心修复：使用新的天赋学习和装备逻辑 ---
        elif outcome_type == "GAIN_TALENT":
            talent_class_name = selected_outcome["talent_class_name"]
            if hasattr(Talents, talent_class_name):
                talent_instance = getattr(Talents, talent_class_name)()
                
                # 1. 尝试学习新天赋
                was_new = player.learn_talent(talent_instance)
                
                if was_new:
                    # 2. 如果是新学会的，尝试自动装备它
                    was_equipped = player.equip_talent(talent_instance)
                    if not was_equipped:
                        self.result_text += " (天赋槽已满，请在天赋界面(T)手动装备)"
                else:
                    self.result_text = "你似乎已经领悟过类似的能力了..."

        elif outcome_type == "TRIGGER_COMBAT":
            from .combat import CombatScreen
            enemy_id = selected_outcome["enemy_id"]
            self._leave_event()
            # 剧情战斗不需要 origin_id
            self.game.state_stack.append(CombatScreen(self.game, enemy_id)) 
            return
            
        self.view_mode = 'showing_result'

    def _leave_event(self):
        """离开事件，更新地图并关闭界面"""
        from .dungeon_screen import DungeonScreen
        self.origin_room.is_cleared = True
        if len(self.game.state_stack) > 1:
            prev_state = self.game.state_stack[-2]
            if isinstance(prev_state, DungeonScreen):
                prev_state.door_rects = prev_state._generate_doors()
        self.game.state_stack.pop()

    def draw(self, surface):
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180)); surface.blit(overlay, (0, 0))
        
        draw_panel(surface, self.panel_rect, self.event_data["title"], self.game.fonts['large'])
        
        if self.view_mode == 'choosing':
            desc_rect = self.panel_rect.inflate(-80, -250)
            desc_rect.top = self.panel_rect.top + 100
            draw_text(surface, self.event_data["description"], self.game.fonts['normal'], TEXT_COLOR, desc_rect)
            for button in self.choice_buttons:
                button.draw(surface)
        elif self.view_mode == 'showing_result':
            result_rect = self.panel_rect.inflate(-80, -250)
            result_rect.top = self.panel_rect.top + 150
            draw_text(surface, self.result_text, self.game.fonts['normal'], HOVER_COLOR, result_rect)
            self.continue_button.draw(surface)


================================================================================
### 文件路径: states\loading.py
================================================================================

# states/loading.py
import pygame
import time
from .base import BaseState
from ui import draw_text, Button
from settings import *

class LoadScreen(BaseState):
    def __init__(self, game):
        super().__init__(game)
        self.back_button = Button((SCREEN_WIDTH / 2 - 150, SCREEN_HEIGHT - 100, 300, 60), "返回", self.game.fonts['normal'])
        self.slot_rects = [pygame.Rect(100, 120 + i * 50, SCREEN_WIDTH - 200, 50) for i in range(10)]
        self.load_fail_message = None

    def handle_event(self, event):
        if self.back_button.handle_event(event) or (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
            self.game.state_stack.pop()
            return

        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            for i, rect in enumerate(self.slot_rects):
                if rect.collidepoint(event.pos):
                    # --- 这是核心修复 ---
                    # load_from_slot 会更新 self.game 的 player, current_stage 等
                    if self.game.load_from_slot(i):
                        from states.story import StoryScreen
                        # 清空整个状态栈，然后压入一个新的、基于已加载数据的 StoryScreen
                        self.game.state_stack = [StoryScreen(self.game)]
                    else:
                        self.load_fail_message = f"槽位 {i} 为空或损坏！"
                    return
                    # --- 修复结束 ---

    def draw(self, surface):
        surface.fill(BG_COLOR)
        title_font = self.game.fonts['large']
        draw_text(surface, "选择要加载的存档", title_font, TEXT_COLOR, pygame.Rect(0, 50, SCREEN_WIDTH, 100))

        for i, rect in enumerate(self.slot_rects):
            slot_data = self.game.peek_save_slot(i)
            is_hovered = rect.collidepoint(pygame.mouse.get_pos())
            if is_hovered:
                pygame.draw.rect(surface, PANEL_BORDER_COLOR, rect.inflate(10, 10), 2, border_radius=5)
            
            text = f"{i}. " + ("(自动)" if i == 0 else "")
            if slot_data and slot_data.get("player"):
                player = slot_data["player"]
                save_time = time.strftime('%Y-%m-%d %H:%M', time.localtime(slot_data.get("timestamp", 0)))
                text += f"{player.name} - 等级 {player.level} ({save_time})"
            else:
                text += "-- 空 --"
            draw_text(surface, text, self.game.fonts['normal'], TEXT_COLOR, rect)

        if self.load_fail_message:
            fail_rect = pygame.Rect(0, SCREEN_HEIGHT - 150, SCREEN_WIDTH, 40)
            draw_text(surface, self.load_fail_message, self.game.fonts['normal'], (255, 100, 100), fail_rect)

        self.back_button.draw(surface)


================================================================================
### 文件路径: states\loot.py
================================================================================

# states/loot.py (已修正)
import pygame
import random
from .base import BaseState
from ui import draw_panel, draw_text
from settings import *
import Equips
from Character import Character # 需要导入Character类用于类型检查

class LootScreen(BaseState):
    def __init__(self, game, defeated_enemy_object=None, next_story_stage=None):
        super().__init__(game)
        self.is_overlay = True

        # --- 核心修改在这里 ---
        # defeated_enemy_object 现在是完整的敌人对象
        self.defeated_enemy_object = defeated_enemy_object
        # 我们仍然需要 enemy_id 来查询装备掉落表
        self.defeated_enemy_id = defeated_enemy_object.id if isinstance(defeated_enemy_object, Character) else None

        self.next_story_stage = next_story_stage

        panel_w = SCREEN_WIDTH * 0.7
        panel_h = SCREEN_HEIGHT * 0.7
        self.panel_rect = pygame.Rect(
            (SCREEN_WIDTH - panel_w) / 2,
            (SCREEN_HEIGHT - panel_h) / 2,
            panel_w, panel_h
        )
        self._process_rewards()
        # ------------------------------------

        self._process_rewards()

    def _process_rewards(self):
        self.exp_messages = []
        if self.defeated_enemy_id:
            enemy_preset = self.game.enemy_data.get(self.defeated_enemy_id, {})
            self.exp_messages = self.game.player.add_exp(enemy_preset.get("exp_reward", 0))
        
        self.loot_messages = self._generate_loot()
        self.game.save_to_slot(0)
        


    def _generate_loot(self):
        messages = []
        found_any_loot = False

        # --- Part 1: 装备掉落逻辑 (现在使用 self.defeated_enemy_id) ---
        if self.defeated_enemy_id: # 确保ID存在
            equipment_drops = self.game.loot_data.get(self.defeated_enemy_id, [])
            if equipment_drops:
                messages.append("--- 战利品 ---")
                for drop_info in equipment_drops:
                    if random.random() < drop_info.get("chance", 1.0):
                        found_any_loot = True
                        item_class_name = drop_info["item_class_name"]
                        try:
                            item_class = getattr(Equips, item_class_name)
                            new_item = item_class()
                            display_name = getattr(new_item, 'display_name', item_class_name)
                            feedback = self.game.player.pickup_item(new_item)
                            if "放入你的背包" in feedback:
                                messages.append(f"获得了装备：{display_name}！")
                            else:
                                messages.append(feedback)
                        except AttributeError:
                            messages.append(f"错误：未找到物品 {item_class_name}。")

        # --- Part 2: 全新的、更精确的天赋掉落逻辑 ---
        import Talents

        # 直接从传递过来的敌人对象中获取它实际拥有的天赋列表！
        if self.defeated_enemy_object and self.defeated_enemy_object.equipped_talents:
            messages.append("--- 能力领悟 ---")

            # 遍历这个敌人在战斗中真正拥有的每一个天赋
            for possessed_talent in self.defeated_enemy_object.equipped_talents:
                # 在这里设置一个固定的天赋掉落率，比如 15%
                TALENT_DROP_CHANCE = 0.15 

                if random.random() < TALENT_DROP_CHANCE:
                    # 尝试让玩家学习这个天赋
                    was_new = self.game.player.learn_talent(possessed_talent)

                    if was_new:
                        found_any_loot = True
                        messages.append(f"你从敌人身上领悟了「{possessed_talent.display_name}」！")

        # --- Part 3: 最终总结 ---
        if not found_any_loot:
            messages.append("敌人没有留下任何有价值的东西。")

        return messages

    def handle_event(self, event):
        if (event.type == pygame.MOUSEBUTTONDOWN and event.button == 1) or \
           (event.type == pygame.KEYDOWN and event.key in [pygame.K_RETURN, pygame.K_SPACE]):
            
            if self.next_story_stage:
                from .story import StoryScreen
                self.game.current_stage = self.next_story_stage
                self.game.state_stack.pop()
                if self.game.state_stack and isinstance(self.game.state_stack[-1], StoryScreen):
                    self.game.state_stack.pop()
                self.game.state_stack.append(StoryScreen(self.game))
            else:
                self.game.state_stack.pop()

    def draw(self, surface):
        # 绘制底层界面
        if len(self.game.state_stack) > 1:
            self.game.state_stack[-2].draw(surface)
        
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180)); surface.blit(overlay, (0, 0))
        
        # --- 核心修复：使用 self.panel_rect ---
        title = "战斗胜利" if self.defeated_enemy_id else "打开宝箱"
        draw_panel(surface, self.panel_rect, title, self.game.fonts['large'])
        
        all_messages = self.exp_messages + self.loot_messages
        current_y = self.panel_rect.top + 120
        for line in all_messages:
            clean_line = line.replace("🎉 ", "")
            text_surf = self.game.fonts['normal'].render(clean_line, True, TEXT_COLOR)
            text_rect = text_surf.get_rect(center=(self.panel_rect.centerx, current_y))
            surface.blit(text_surf, text_rect); current_y += 35
            
        prompt_surf = self.game.fonts['small'].render("点击任意处继续...", True, TEXT_COLOR)
        prompt_rect = prompt_surf.get_rect(center=(self.panel_rect.centerx, self.panel_rect.bottom - 40))
        surface.blit(prompt_surf, prompt_rect)


================================================================================
### 文件路径: states\notification_screen.py
================================================================================

# states/notification_screen.py
import pygame
from .base import BaseState
from ui import draw_text
from settings import *

class NotificationScreen(BaseState):
    def __init__(self, game, message, duration=2.0):
        super().__init__(game)
        self.is_overlay = True
        self.message = message
        self.duration = duration # 秒
        self.start_time = pygame.time.get_ticks()

    def update(self):
        # 计时结束，自动关闭
        if pygame.time.get_ticks() - self.start_time > self.duration * 1000:
            self.game.state_stack.pop()

    def draw(self, surface):
        # 创建一个位于屏幕底部中央的对话框
        box_width = 600
        box_height = 80
        box_rect = pygame.Rect(
            (SCREEN_WIDTH - box_width) / 2,
            SCREEN_HEIGHT - box_height - 30, # 离底部30像素
            box_width,
            box_height
        )
        
        # 绘制半透明背景
        bg_surface = pygame.Surface(box_rect.size, pygame.SRCALPHA)
        bg_surface.fill((20, 35, 50, 200)) # 使用面板背景色，带透明度
        surface.blit(bg_surface, box_rect.topleft)
        pygame.draw.rect(surface, PANEL_BORDER_COLOR, box_rect, 2, border_radius=10)

        # 绘制消息文本
        draw_text(surface, self.message, self.game.fonts['normal'], TEXT_COLOR, box_rect)


================================================================================
### 文件路径: states\rest_screen.py
================================================================================

# 文件: states/rest_screen.py (新文件)

import pygame
import random
from .base import BaseState
from ui import Button, draw_panel, draw_text
from settings import *

class RestScreen(BaseState):

    def __init__(self, game, origin_room):
        super().__init__(game)
        self.is_overlay = True
        self.origin_room = origin_room

        self.rest_used = False
        self.forge_used = False
        self.feedback_message = ""

        # --- 核心修改在这里 ---
        from Equips import UPGRADE_MAP 

        # 1. 创建一个包含玩家所有物品（已装备的 + 背包里的）的总列表
        all_player_items = self.game.player.all_equipment + self.game.player.backpack

        # 2. 从这个总列表中，筛选出所有可以被升级的物品
        self.upgradable_items = [
            item for item in all_player_items
            if item.__class__ in UPGRADE_MAP
        ]

        self._setup_ui()

    def _setup_ui(self):
        """初始化用户界面元素"""
        panel_w, panel_h = 800, 500
        self.panel_rect = pygame.Rect((SCREEN_WIDTH - panel_w) / 2, (SCREEN_HEIGHT - panel_h) / 2, panel_w, panel_h)

        # 定义两个核心选项按钮的位置
        btn_w, btn_h = 300, 180
        spacing = 50
        start_x = self.panel_rect.centerx - (btn_w * 2 + spacing) / 2

        self.rest_button = Button(
            (start_x, self.panel_rect.centery - btn_h/2, btn_w, btn_h),
            "休息", # 按钮的初始文字
            self.game.fonts['large']
        )
        self.forge_button = Button(
            (start_x + btn_w + spacing, self.panel_rect.centery - btn_h/2, btn_w, btn_h),
            "锻造",
            self.game.fonts['large']
        )
        
        # 离开按钮
        self.leave_button = Button(
            (self.panel_rect.centerx - 150, self.panel_rect.bottom - 100, 300, 60),
            "离开",
            self.game.fonts['normal']
        )

    def handle_event(self, event):
        """处理玩家的输入事件"""
        # --- 休息按钮的逻辑 (不变) ---
        if not self.rest_used and self.rest_button.handle_event(event):
            self.rest_used = True
            heal_amount = int(self.game.player.max_hp * 0.3)
            self.game.player.heal(heal_amount)
            self.feedback_message = f"你恢复了 {heal_amount} 点生命！"
            self.forge_used = True # 休息和锻造二选一
            return

        # --- 全新的、更强大的锻造逻辑 ---
        if not self.forge_used and len(self.upgradable_items) > 0 and self.forge_button.handle_event(event):
            self.forge_used = True
            self.rest_used = True # 休息和锻造二选一

            player = self.game.player

            # 1. 从可升级列表中随机选一件 (现在这个列表包含了背包物品)
            item_to_upgrade = random.choice(self.upgradable_items)
            item_name = getattr(item_to_upgrade, 'display_name', '装备')

            from Equips import UPGRADE_MAP
            upgraded_class = UPGRADE_MAP.get(item_to_upgrade.__class__)

            if upgraded_class:
                # 2. 创建升级后的新装备实例
                upgraded_item = upgraded_class()

                # 3. 从原来的位置移除旧装备
                #    检查它是在身上还是在背包里
                if item_to_upgrade in player.all_equipment:
                    player.unequip(item_to_upgrade)
                elif item_to_upgrade in player.backpack:
                    player.backpack.remove(item_to_upgrade)

                # 4. 将锻造好的新装备放入背包
                #    我们使用 pickup_item 方法，因为它能自动处理重复物品转化为金币的逻辑
                feedback = player.pickup_item(upgraded_item)
                if "放入你的背包" in feedback:
                    self.feedback_message = f"锻造成功！新的「{upgraded_item.display_name}」已放入你的背包！"
                else: # 如果玩家已经有升级版的装备了，会自动转化成金币
                    self.feedback_message = f"锻造成功！但你已拥有同名装备，转化为金币！"

            else:
                self.feedback_message = f"「{item_name}」似乎无法被强化..."

            return

        # --- 处理离开按钮 (不变) ---
        if self.leave_button.handle_event(event):
            self._leave_room()
            
    def _leave_room(self):
        """处理离开休息室的逻辑"""
        from .dungeon_screen import DungeonScreen
        # 标记这个房间为“已探索完毕”
        self.origin_room.is_cleared = True
        
        # 更新地牢界面，让出口的门显示出来
        if len(self.game.state_stack) > 1:
            prev_state = self.game.state_stack[-2]
            if isinstance(prev_state, DungeonScreen):
                prev_state.door_rects = prev_state._generate_doors()
        
        # 将自己从状态栈中弹出，返回地牢界面
        self.game.state_stack.pop()

    def draw(self, surface):
        """绘制所有UI元素到屏幕上"""
        # 绘制半透明的背景遮罩
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))

        # 绘制主面板
        draw_panel(surface, self.panel_rect, "篝火旁的쉼터", self.game.fonts['large'])

        # --- 绘制休息按钮和描述 ---
        self.rest_button.draw(surface)
        rest_desc = "恢复30%最大生命值"
        rest_desc_rect = self.rest_button.rect.copy()
        rest_desc_rect.y += 190 # 调整描述文本的位置
        draw_text(surface, rest_desc, self.game.fonts['small'], TEXT_COLOR, rest_desc_rect)
        if self.rest_used: # 如果已使用，绘制一个遮罩
            s = pygame.Surface(self.rest_button.rect.size, pygame.SRCALPHA)
            s.fill((50,50,50,180))
            surface.blit(s, self.rest_button.rect.topleft)

        # --- 绘制锻造按钮和描述 ---
        self.forge_button.draw(surface)
        forge_desc = "随机强化一件装备"
        if len(self.upgradable_items) == 0:
            forge_desc = "没有可强化的装备"
        forge_desc_rect = self.forge_button.rect.copy()
        forge_desc_rect.y += 190
        draw_text(surface, forge_desc, self.game.fonts['small'], TEXT_COLOR, forge_desc_rect)
        if self.forge_used or len(self.upgradable_items) == 0: # 如果已使用或没有装备，绘制遮罩
            s = pygame.Surface(self.forge_button.rect.size, pygame.SRCALPHA)
            s.fill((50,50,50,180))
            surface.blit(s, self.forge_button.rect.topleft)

        # 绘制操作反馈信息
        if self.feedback_message:
            feedback_rect = pygame.Rect(0, self.panel_rect.top + 100, self.panel_rect.width, 40)
            feedback_rect.centerx = self.panel_rect.centerx
            draw_text(surface, self.feedback_message, self.game.fonts['normal'], HOVER_COLOR, feedback_rect)

        # 绘制离开按钮
        self.leave_button.draw(surface)


================================================================================
### 文件路径: states\saving.py
================================================================================

# states/saving.py
import pygame
import time
from .base import BaseState
from ui import draw_text, Button
from settings import *

class SaveScreen(BaseState):
    def __init__(self, game):
        super().__init__(game)
        self.back_button = Button((SCREEN_WIDTH / 2 - 150, SCREEN_HEIGHT - 100, 300, 60), "返回", self.game.fonts['normal'])
        self.slot_rects = [pygame.Rect(100, 120 + (i-1) * 50, SCREEN_WIDTH - 200, 50) for i in range(1, 10)]
        self.feedback_message = None
        self.feedback_timer = 0

    def update(self):
        if self.feedback_message and pygame.time.get_ticks() - self.feedback_timer > 2000:
            self.feedback_message = None

    def handle_event(self, event):
        if self.back_button.handle_event(event) or (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
            self.game.state_stack.pop()
            return

        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            for i, rect in enumerate(self.slot_rects, 1):
                if rect.collidepoint(event.pos):
                    self.feedback_message = self.game.save_to_slot(i)
                    self.feedback_timer = pygame.time.get_ticks()
                    return

    def draw(self, surface):
        surface.fill(BG_COLOR)
        title_font = self.game.fonts['large']
        draw_text(surface, "选择要覆盖的存档槽", title_font, TEXT_COLOR, pygame.Rect(0, 50, SCREEN_WIDTH, 100))

        for i, rect in enumerate(self.slot_rects, 1):
            slot_data = self.game.peek_save_slot(i) # <-- 使用 peek_save_slot
            is_hovered = rect.collidepoint(pygame.mouse.get_pos())
            if is_hovered:
                pygame.draw.rect(surface, PANEL_BORDER_COLOR, rect.inflate(10, 10), 2, border_radius=5)
            
            text = f"{i}. "
            if slot_data and slot_data.get("player"):
                player = slot_data["player"]
                save_time = time.strftime('%Y-%m-%d %H:%M', time.localtime(slot_data.get("timestamp", 0)))
                text += f"{player.name} - 等级 {player.level} ({save_time})"
            else:
                text += "-- 空 --"
            draw_text(surface, text, self.game.fonts['normal'], TEXT_COLOR, rect)

        if self.feedback_message:
            feedback_rect = pygame.Rect(0, SCREEN_HEIGHT - 150, SCREEN_WIDTH, 40)
            draw_text(surface, self.feedback_message, self.game.fonts['normal'], (100, 255, 100), feedback_rect)
        
        self.back_button.draw(surface)


================================================================================
### 文件路径: states\shop_screen.py
================================================================================

# states/shop_screen.py (已更新)
import pygame
import random
import inspect # <-- 1. 导入 inspect 模块 (Tooltip 需要)
from .base import BaseState
from ui import Button, draw_panel, draw_text, TooltipManager # <-- 2. 导入 TooltipManager
from settings import *
import Equips

RARITY_PRICES = {"common": 50, "uncommon": 100, "rare": 250, "epic": 500, "legendary": 1000}

class ShopScreen(BaseState):
    def __init__(self, game, origin_room):
        super().__init__(game)
        self.is_overlay = True
        self.origin_room = origin_room
        self.shop_items = []
        self.feedback_message = ""
        self.feedback_timer = 0
        
        # <-- 3. 在 __init__ 中，初始化 TooltipManager -->
        self.tooltip_manager = TooltipManager(self.game.fonts['small'])
        
        self._generate_inventory()
        self._setup_ui()

    def _generate_inventory(self):
        all_item_classes = [getattr(Equips, name) for name in dir(Equips) if isinstance(getattr(Equips, name), type) and issubclass(getattr(Equips, name), Equips.Equipment) and getattr(Equips, name) is not Equips.Equipment]
        choices = random.sample(all_item_classes, min(3, len(all_item_classes)))
        for item_class in choices:
            item = item_class()
            rarity = getattr(item, 'rarity', 'common')
            price = RARITY_PRICES.get(rarity, 9999)
            self.shop_items.append([None, item, price, False])

    def _setup_ui(self):
        panel_w, panel_h = 900, 600
        self.panel_rect = pygame.Rect((SCREEN_WIDTH - panel_w) / 2, (SCREEN_HEIGHT - panel_h) / 2, panel_w, panel_h)
        card_w, card_h, spacing = 250, 400, 25
        start_x = self.panel_rect.centerx - (card_w * len(self.shop_items) + spacing * (len(self.shop_items) - 1)) / 2
        
        for i, item_tuple in enumerate(self.shop_items):
            card_x = start_x + i * (card_w + spacing)
            card_rect = pygame.Rect(card_x, self.panel_rect.y + 120, card_w, card_h)
            button = Button(card_rect, "", self.game.fonts['normal'])
            item_tuple[0] = button
            
        leave_rect = pygame.Rect(self.panel_rect.centerx - 150, self.panel_rect.bottom - 80, 300, 60)
        self.leave_button = Button(leave_rect, "离开商店", self.game.fonts['normal'])

    def handle_event(self, event):
        # ... (handle_event 逻辑保持不变) ...
        if self.leave_button.handle_event(event):
            self.origin_room.is_cleared = True
            from .dungeon_screen import DungeonScreen
            if len(self.game.state_stack) > 1 and isinstance(self.game.state_stack[-2], DungeonScreen):
                self.game.state_stack[-2].door_rects = self.game.state_stack[-2]._generate_doors()
            self.game.state_stack.pop()
            return
        for button, item, price, is_sold in self.shop_items:
            if not is_sold and button.handle_event(event):
                if self.game.player.gold >= price:
                    self.game.player.gold -= price
                    feedback = self.game.player.pickup_item(item)
                    if feedback:
                        from .notification_screen import NotificationScreen
                        self.game.state_stack.append(NotificationScreen(self.game, feedback))
                    self.feedback_message = f"成功购买 {getattr(item, 'display_name', '物品')}！"
                    self.shop_items[self.shop_items.index([button, item, price, is_sold])][3] = True
                else:
                    self.feedback_message = "金币不足！"
                self.feedback_timer = pygame.time.get_ticks()
                return

    def update(self):
        if self.feedback_message and pygame.time.get_ticks() - self.feedback_timer > 2000:
            self.feedback_message = ""

        # <-- 4. 在 update 中，添加悬停检测逻辑 -->
        hovered_item = None
        mouse_pos = pygame.mouse.get_pos()
        for button, item, price, is_sold in self.shop_items:
            if button.rect.collidepoint(mouse_pos):
                hovered_item = item
                break
        self.tooltip_manager.update(hovered_item)


    def draw(self, surface):
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180)); surface.blit(overlay, (0, 0))
        draw_panel(surface, self.panel_rect, "神秘商店", self.game.fonts['large'])
        
        gold_text = f"你的金币: {self.game.player.gold} G"
        gold_surf = self.game.fonts['normal'].render(gold_text, True, (255, 215, 0))
        gold_rect = gold_surf.get_rect(right=self.panel_rect.right - 30, top=self.panel_rect.top + 20)
        surface.blit(gold_surf, gold_rect)

        for button, item, price, is_sold in self.shop_items:
            rarity = getattr(item, 'rarity', 'common')
            color = RARITY_COLORS.get(rarity, (255,255,255))
            
            bg_color = PANEL_BORDER_COLOR if button.is_hovered and not is_sold else PANEL_BG_COLOR
            pygame.draw.rect(surface, bg_color, button.rect, border_radius=10)
            pygame.draw.rect(surface, color if not is_sold else (80,80,80), button.rect, 2, border_radius=10)
            
            name = getattr(item, 'display_name', '物品')
            name_surf = self.game.fonts['normal'].render(name, True, color if not is_sold else (120,120,120))
            name_rect = name_surf.get_rect(centerx=button.rect.centerx, top=button.rect.top + 20)
            surface.blit(name_surf, name_rect)

            # 绘制物品描述（这里用 tooltip 代替，所以可以留空或画个图）
            
            price_text = "已售罄" if is_sold else f"购买 ({price} G)"
            price_color = (150,150,150) if is_sold else TEXT_COLOR
            price_rect_area = pygame.Rect(button.rect.x, button.rect.bottom - 70, button.rect.width, 70)
            draw_text(surface, price_text, self.game.fonts['normal'], price_color, price_rect_area)

        self.leave_button.draw(surface)
        if self.feedback_message:
             feedback_rect = pygame.Rect(0, self.panel_rect.top + 80, self.panel_rect.width, 30)
             feedback_rect.centerx = self.panel_rect.centerx
             draw_text(surface, self.feedback_message, self.game.fonts['small'], HOVER_COLOR, feedback_rect)

        # <-- 5. 在 draw 的末尾，绘制悬停提示 -->
        self.tooltip_manager.draw(surface)


================================================================================
### 文件路径: states\story.py
================================================================================

# states/story.py (已更新)
import pygame
from .base import BaseState
from .dungeon_screen import DungeonScreen
from .saving import SaveScreen
from .loading import LoadScreen
# <-- 导入 Button 类
from ui import draw_text, Button
from settings import *

class StoryScreen(BaseState):
    def __init__(self, game):
        super().__init__(game)
        # <-- 重新布局，为“背包”按钮腾出空间
        button_w, button_h = 120, 40
        padding = 15
        # 从右往左依次是 保存 -> 加载 -> 背包
        save_rect = pygame.Rect(SCREEN_WIDTH - padding - button_w, SCREEN_HEIGHT - padding - button_h - 250, button_w, button_h)
        load_rect = pygame.Rect(save_rect.left - padding - button_w, save_rect.top, button_w, button_h)
        # <-- 新增背包按钮的位置
        backpack_rect = pygame.Rect(load_rect.left - padding - button_w, load_rect.top, button_w, button_h)
        
        self.buttons = {
            "save": Button(save_rect, "保存(S)", self.game.fonts['small']),
            "load": Button(load_rect, "加载(L)", self.game.fonts['small']),
            # <-- 将新按钮添加到字典中
            "backpack": Button(backpack_rect, "背包(B)", self.game.fonts['small'])
        }
        self._initialize_story()

    def _initialize_story(self):
        # ... (此方法保持不变)
        start_index = getattr(self.game, "loaded_dialogue_index", 0)
        self.dialogue_index = start_index
        self.displayed_chars = 0
        self.typing_complete = False
        self.last_char_time = 0
        self.typewriter_speed = 30
        self.game.loaded_dialogue_index = 0

    def update(self):
        # ... (此方法保持不变)
        if not self.typing_complete:
            now = pygame.time.get_ticks()
            if now - self.last_char_time > self.typewriter_speed:
                stage_data = self.game.story_data.get(self.game.current_stage, {})
                dialogue_list = stage_data.get("text", [])
                if not dialogue_list or self.dialogue_index >= len(dialogue_list):
                    self.typing_complete = True
                    return
                line = dialogue_list[self.dialogue_index].get("line", "")
                if self.displayed_chars < len(line):
                    self.displayed_chars += 1
                    self.last_char_time = now
                else:
                    self.typing_complete = True
    
    def handle_event(self, event):
        from states.backpack import BackpackScreen # <-- 确保导入
        
        # <-- 现在可以直接调用按钮的 handle_event 方法
        if self.buttons['save'].handle_event(event):
            self.game.state_stack.append(SaveScreen(self.game))
            return
        if self.buttons['load'].handle_event(event):
            self.game.state_stack.append(LoadScreen(self.game))
            return
        # <-- 新增：处理背包按钮点击事件
        if self.buttons['backpack'].handle_event(event):
            self.game.state_stack.append(BackpackScreen(self.game))
            return

        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            # 避免点击按钮时也触发对话前进
            is_over_button = any(btn.rect.collidepoint(event.pos) for btn in self.buttons.values())
            if not is_over_button:
                self._advance_dialogue()
        
        if event.type == pygame.KEYDOWN:
            if event.key in [pygame.K_RETURN, pygame.K_SPACE]:
                self._advance_dialogue()
            elif event.key == pygame.K_s:
                self.game.state_stack.append(SaveScreen(self.game))
            elif event.key == pygame.K_l:
                self.game.state_stack.append(LoadScreen(self.game))
            elif event.key == pygame.K_b:
                self.game.state_stack.append(BackpackScreen(self.game))
    
# 在 states/story.py 文件中，找到并替换这个函数

    def _advance_dialogue(self):
        from states.combat import CombatScreen
        from states.title import TitleScreen
        from states.dungeon_screen import DungeonScreen

        stage_data = self.game.story_data.get(self.game.current_stage)
        if not stage_data:
            print(f"错误: 找不到剧情ID: {self.game.current_stage}")
            self.game.state_stack = [TitleScreen(self.game)]
            return
            
        dialogue_list = stage_data.get("text", [])

        # 如果打字机效果还没结束，就立刻完成它
        if not self.typing_complete:
            self.typing_complete = True
            # 安全检查，防止空对话列表
            if self.dialogue_index < len(dialogue_list):
                current_line = dialogue_list[self.dialogue_index].get("line", "")
                self.displayed_chars = len(current_line)
            return

        # --- 核心修复：先检查是否应该推进，再处理 ---
        # 检查当前对话行是否有action
        if self.dialogue_index < len(dialogue_list):
            current_dialogue = dialogue_list[self.dialogue_index]
            # 文件: states/story.py (_advance_dialogue 方法内)
            action = current_dialogue.get("action")
            if action == "start_trial":
                self.game.state_stack.pop()
                # --- 核心修改在这里 ---
                # 旧代码: self.game.state_stack.append(DungeonScreen(self.game))
                # 新代码：明确告诉DungeonScreen要加载哪个地牢的第1层
                self.game.state_stack.append(DungeonScreen(self.game, "sunstone_ruins", 1))
                return

        # 推进到下一句对话
        self.dialogue_index += 1

        # --- 在这里检查是否结束 ---
        if self.dialogue_index >= len(dialogue_list):
            # 所有对话都结束了，进入下一个stage
            self.game.current_stage = stage_data.get("next", "quit")
            if self.game.current_stage == "quit":
                self.game.state_stack = [TitleScreen(self.game)]
                return
            
            next_stage_data = self.game.story_data.get(self.game.current_stage, {})
            if next_stage_data.get("type") == "combat":
                enemy_id = next_stage_data.get("enemy_id", "slime")
                self.game.state_stack.pop()
                self.game.state_stack.append(CombatScreen(self.game, enemy_id))
            else:
                self._initialize_story() # 重置对话状态以准备下一个story stage
        else:
            # 如果还有下一句，则重置打字机
            self.displayed_chars = 0
            self.typing_complete = False
            self.last_char_time = 0

    def draw(self, surface):
        surface.fill(BG_COLOR)
        dialogue_box_rect = pygame.Rect(50, SCREEN_HEIGHT - 250, SCREEN_WIDTH - 100, 200)
        pygame.draw.rect(surface, PANEL_BG_COLOR, dialogue_box_rect, border_radius=10)
        pygame.draw.rect(surface, PANEL_BORDER_COLOR, dialogue_box_rect, 3, border_radius=10)

        # ... (对话框和文本绘制逻辑保持不变) ...
        stage_data = self.game.story_data.get(self.game.current_stage, {})
        dialogue_list = stage_data.get("text", [{"speaker": "错误", "line": "未找到剧情文本"}])
        safe_index = min(self.dialogue_index, len(dialogue_list) - 1)
        dialogue = dialogue_list[safe_index]
        speaker, full_line = dialogue["speaker"], dialogue["line"]
        if speaker != "旁白":
            speaker_text_surf = self.game.fonts['normal'].render(speaker, True, TEXT_COLOR)
            speaker_panel_rect = speaker_text_surf.get_rect(topleft=(dialogue_box_rect.left + 30, dialogue_box_rect.top - 35))
            speaker_panel_rect.inflate_ip(20, 10)
            pygame.draw.rect(surface, PANEL_BG_COLOR, speaker_panel_rect, border_radius=5)
            pygame.draw.rect(surface, PANEL_BORDER_COLOR, speaker_panel_rect, 2, border_radius=5)
            surface.blit(speaker_text_surf, (speaker_panel_rect.x + 10, speaker_panel_rect.y + 5))
        text_to_render = full_line[:self.displayed_chars]
        text_rect = dialogue_box_rect.inflate(-40, -40)
        draw_text(surface, text_to_render, self.game.fonts['normal'], TEXT_COLOR, text_rect)
        if self.typing_complete:
            prompt_pos = (dialogue_box_rect.right - 40, dialogue_box_rect.bottom - 40)
            pygame.draw.polygon(surface, TEXT_COLOR, [prompt_pos, (prompt_pos[0] - 20, prompt_pos[1]), (prompt_pos[0] - 10, prompt_pos[1] - 15)])
        
        # <-- 绘制会自动包含新按钮，无需修改
        for button in self.buttons.values():
            button.draw(surface)


================================================================================
### 文件路径: states\talents_screen.py
================================================================================

# states/talents_screen.py
import pygame
import inspect
from .base import BaseState
from ui import draw_panel, draw_text, Button, get_display_name, TooltipManager
from settings import *

class TalentsScreen(BaseState):
    def __init__(self, game):
        super().__init__(game)
        self.is_overlay = True
        self.dragging_talent = None
        self.dragging_from = None # 'equipped' or 'learned'
        
        self._setup_layout()
        self.tooltip_manager = TooltipManager(self.game.fonts['small'])

    def _setup_layout(self):
        """设置UI布局，分为左右两个区域"""
        margin, header_height = 40, 80
        self.container_rect = pygame.Rect(margin, margin, SCREEN_WIDTH - 2*margin, SCREEN_HEIGHT - 2*margin)
        self.header_rect = pygame.Rect(self.container_rect.x, self.container_rect.y, self.container_rect.width, header_height)
        
        content_y = self.header_rect.bottom + 10
        content_height = self.container_rect.height - header_height - 10
        
        # 左侧：已装备天赋
        self.equipped_panel_rect = pygame.Rect(self.container_rect.x, content_y, 350, content_height)
        # 右侧：天赋库
        self.learned_panel_rect = pygame.Rect(self.equipped_panel_rect.right + 10, content_y, self.container_rect.right - self.equipped_panel_rect.right - 10, content_height)
        
        self.close_button = Button(pygame.Rect(self.container_rect.right - 45, self.container_rect.top + 10, 35, 35), "X", self.game.fonts['normal'])

    def handle_event(self, event):
        if self.close_button.handle_event(event) or (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
            if self.dragging_talent: self._return_dragging_talent()
            self.game.state_stack.pop(); return
            
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1: self._handle_mouse_down(event.pos)
        if event.type == pygame.MOUSEBUTTONUP and event.button == 1: self._handle_mouse_up(event.pos)

    def _handle_mouse_down(self, pos):
        """处理鼠标按下事件，负责“拾起”天赋"""
        if self.dragging_talent: return
        
        # 检查是否从“已装备”区域拾起
        for i, talent in enumerate(self.game.player.equipped_talents):
            rect = self._get_talent_rect(i, 'equipped')
            if rect.collidepoint(pos):
                self.dragging_talent, self.dragging_from = talent, 'equipped'
                self.game.player.unequip_talent(talent) # 拾起时立刻卸下
                return
        
        # 检查是否从“天赋库”区域拾起
        unequipped = [t for t in self.game.player.learned_talents if t not in self.game.player.equipped_talents]
        for i, talent in enumerate(unequipped):
            rect = self._get_talent_rect(i, 'learned')
            if rect.collidepoint(pos):
                self.dragging_talent, self.dragging_from = talent, 'learned'
                return

    # 文件: states/talents_screen.py (替换这个函数)

    def _handle_mouse_up(self, pos):
        if not self.dragging_talent: return

        talent_to_place = self.dragging_talent
        source_type = self.dragging_from
        self.dragging_talent, self.dragging_from = None, None

        # 检查是否放置在“已装备”区域
        for i in range(self.game.player.max_talent_slots):
            rect = self._get_talent_rect(i, 'equipped')
            if rect.collidepoint(pos):

                # 获取目标槽位原有的天赋
                target_talent = None
                if i < len(self.game.player.equipped_talents):
                    target_talent = self.game.player.equipped_talents[i]

                # 如果目标槽位有天赋，先卸下它
                if target_talent:
                    self.game.player.unequip_talent(target_talent)

                # 尝试装备正在拖拽的天赋
                success = self.game.player.equip_talent(talent_to_place)

                if success:
                    # 如果装备成功，并且原目标槽位有天赋，并且拖拽的天赋来自已装备区
                    # 那么这就是一次“交换”，把目标天赋装备回去 (equip_talent会自动找到空位)
                    if target_talent and source_type == 'equipped':
                        self.game.player.equip_talent(target_talent)
                else:
                    # 如果装备失败，把所有东西都送回原处
                    self._return_dragging_talent(talent_to_place) # 送回拖拽天赋
                    if target_talent: # 送回目标天赋
                        self.game.player.equip_talent(target_talent)

                self.game.player.recalculate_stats()
                return

        # 如果放在其他任何地方，视为卸下 (即返回原处)
        self._return_dragging_talent(talent_to_place)
        self.game.player.recalculate_stats()
        
    def _return_dragging_talent(self, talent):
        """在拖拽被取消或失败时，将天赋送回原处"""
        if self.dragging_from == 'equipped':
            self.game.player.equip_talent(talent)

    def update(self):
        """更新悬浮提示"""
        if self.dragging_talent: self.tooltip_manager.update(None); return
        hovered_talent = None
        mouse_pos = pygame.mouse.get_pos()
        
        all_panels = [('equipped', self.game.player.equipped_talents), 
                      ('learned', [t for t in self.game.player.learned_talents if t not in self.game.player.equipped_talents])]

        for panel_type, talent_list in all_panels:
            for i, talent in enumerate(talent_list):
                rect = self._get_talent_rect(i, panel_type)
                if rect.collidepoint(mouse_pos):
                    hovered_talent = talent; break
            if hovered_talent: break
        
        self.tooltip_manager.update(hovered_talent)

    def _get_talent_rect(self, index, panel_type):
        """计算指定索引的天赋在哪个位置"""
        panel_rect = self.equipped_panel_rect if panel_type == 'equipped' else self.learned_panel_rect
        padding = 20
        item_size, spacing = 60, 10
        cols = (panel_rect.width - 2 * padding + spacing) // (item_size + spacing)
        
        col = index % cols
        row = index // cols
        
        x = panel_rect.left + padding + col * (item_size + spacing)
        y = panel_rect.top + 100 + row * (item_size + spacing)
        return pygame.Rect(x, y, item_size, item_size)

    def draw(self, surface):
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA); overlay.fill((0, 0, 0, 180)); surface.blit(overlay, (0, 0))
        draw_panel(surface, self.container_rect, "天赋管理", self.game.fonts['large'])
        
        self._draw_equipped_panel(surface)
        self._draw_learned_panel(surface)
        self._draw_dragging_talent(surface)
        
        self.close_button.draw(surface)
        self.tooltip_manager.draw(surface)

    def _draw_equipped_panel(self, surface):
        player = self.game.player
        title = f"已装备 ({len(player.equipped_talents)}/{player.max_talent_slots})"
        title_rect = self.equipped_panel_rect.copy(); title_rect.height = 50; title_rect.move_ip(0, 40)
        draw_text(surface, title, self.game.fonts['normal'], TEXT_COLOR, title_rect)

        for i in range(player.max_talent_slots):
            rect = self._get_talent_rect(i, 'equipped')
            pygame.draw.rect(surface, (20, 30, 40, 150), rect, border_radius=8)
            pygame.draw.rect(surface, (70, 80, 100, 180), rect, 2, border_radius=8)
            
            if i < len(player.equipped_talents):
                talent = player.equipped_talents[i]
                if talent is not self.dragging_talent:
                    talent_text = talent.display_name[:2] # 显示天赋前两个字
                    draw_text(surface, talent_text, self.game.fonts['normal'], TEXT_COLOR, rect)

    def _draw_learned_panel(self, surface):
        title_rect = self.learned_panel_rect.copy(); title_rect.height = 50; title_rect.move_ip(0, 40)
        draw_text(surface, "天赋库", self.game.fonts['normal'], TEXT_COLOR, title_rect)
        
        unequipped = [t for t in self.game.player.learned_talents if t not in self.game.player.equipped_talents]
        
        # 绘制所有已学习的天赋格子
        for i, talent in enumerate(unequipped):
            if talent is not self.dragging_talent:
                rect = self._get_talent_rect(i, 'learned')
                pygame.draw.rect(surface, PANEL_BG_COLOR, rect, border_radius=8)
                pygame.draw.rect(surface, PANEL_BORDER_COLOR, rect, 2, border_radius=8)
                talent_text = talent.display_name[:2]
                draw_text(surface, talent_text, self.game.fonts['normal'], TEXT_COLOR, rect)

    def _draw_dragging_talent(self, surface):
        if self.dragging_talent:
            mouse_pos = pygame.mouse.get_pos()
            name = get_display_name(self.dragging_talent)
            font = self.game.fonts['normal']
            text_surf = font.render(name, True, TEXT_COLOR)
            rect = text_surf.get_rect(center=mouse_pos)
            
            bg_rect = rect.inflate(20, 12)
            pygame.draw.rect(surface, PANEL_BG_COLOR, bg_rect, border_radius=8)
            pygame.draw.rect(surface, PANEL_BORDER_COLOR, bg_rect, 2, border_radius=8)
            surface.blit(text_surf, rect)


================================================================================
### 文件路径: states\title.py
================================================================================

# states/title.py
import pygame
from .base import BaseState
from .loading import LoadScreen
from ui import Button
from settings import *

class TitleScreen(BaseState):
    def __init__(self, game):
        super().__init__(game)
        self.buttons = {
            "new_game": Button((SCREEN_WIDTH / 2 - 150, 300, 300, 60), "新游戏", self.game.fonts['normal']),
            "continue_game": Button((SCREEN_WIDTH / 2 - 150, 400, 300, 60), "继续游戏", self.game.fonts['normal']),
            "load_game": Button((SCREEN_WIDTH / 2 - 150, 500, 300, 60), "加载游戏", self.game.fonts['normal']),
        }
    
    def handle_event(self, event):
        from states.story import StoryScreen # <-- Import 移至此处
        if self.buttons['new_game'].handle_event(event):
            self.game.start_new_game()
            self.game.state_stack.append(StoryScreen(self.game))
        
        elif self.buttons['continue_game'].handle_event(event):
            if self.game.load_from_slot(0):
                self.game.state_stack.append(StoryScreen(self.game))
            else:
                self.game.start_new_game()
                self.game.state_stack.append(StoryScreen(self.game))

        elif self.buttons['load_game'].handle_event(event):
            self.game.state_stack.append(LoadScreen(self.game))

        if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
            self.game.running = False # 在主菜单按ESC则退出

    def draw(self, surface):
        surface.fill(BG_COLOR)
        title_surf = self.game.fonts['large'].render("我的战斗游戏", True, TEXT_COLOR)
        title_rect = title_surf.get_rect(center=(SCREEN_WIDTH / 2, 150))
        surface.blit(title_surf, title_rect)
        for button in self.buttons.values():
            button.draw(surface)



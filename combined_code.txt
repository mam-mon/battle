--- 代码合集生成于: 2025-09-04 17:02:17 ---
--- 根目录: C:\Users\User\Desktop\private\battle ---

================================================================================
### 文件路径: battle_logger.py
================================================================================

# 文件: battle_logger.py (新文件)

class BattleLogger:
    def __init__(self):
        self._renderer = None

    def register_renderer(self, renderer_instance):
        """战斗开始时，由战斗界面调用，用于注册日志显示器"""
        print("[BattleLogger] 日志显示器已注册。")
        self._renderer = renderer_instance

    def unregister_renderer(self):
        """战斗结束时调用，用于注销显示器"""
        print("[BattleLogger] 日志显示器已注销。")
        self._renderer = None

    def log(self, parts, color=None):
        """
        全局日志接口。
        任何地方都可以调用这个函数来发送日志。
        """
        if self._renderer:
            # 直接调用显示器的 add_message 方法
            self._renderer.add_message(parts, color=color)
        else:
            # 如果没有注册显示器（比如非战斗状态），则在控制台打印
            if isinstance(parts, list):
                # 如果是富文本列表，拼接后打印
                print("".join([p[0] for p in parts]))
            else:
                print(parts)

# 创建一个全局唯一的播报员实例
battle_logger = BattleLogger()


================================================================================
### 文件路径: Buffs.py
================================================================================

from damage import DamagePacket, DamageType
from abc import ABC
import collections
from collections import defaultdict
from rich.console import Console, Group
from rich.live import Live
from rich.table import Table
from rich.panel import Panel
from rich.text import Text
import time
import random
from rich.text import Text
from rich.progress import BarColumn  # 可选：也可以直接用 Text
import math
from collections import Counter
#import pygame
import sys
from battle_logger import battle_logger
from ui import format_damage_log


class Buff(ABC):
    """通用 Buff/DeBuff 基类，所有状态继承此类。"""
    display_name     = None      # 界面显示名
    max_stacks       = 1         # 最大叠层数；1 表示不可叠加
    dispellable      = False     # 是否可被驱散
    duration         = None      # 持续秒数；None 或 0 表示无限
    hidden           = False     # 是否在界面隐藏
    is_debuff        = False     # 是否为负面状态
    priority         = 0         # 执行顺序，越大越先执行
    disable_attack   = False     # 是否禁止攻击（如眩晕、不灭二阶段）

    def __init__(self, stacks: int = 1, duration_override: float = None):
        self.stacks = min(stacks, self.max_stacks)
        self.remaining = duration_override if duration_override is not None else self.duration
        self._accum = 0.0

    def on_apply(self, wearer):
        """Buff 被添加到角色时触发"""
        pass

    def on_remove(self, wearer):
        """Buff 被移除时触发"""
        pass

    def on_tick(self, wearer, dt):
        """
        每帧或定时触发，用于持续性效果。
        返回字符串则表示有飘字。
        """
        return None

    def before_take_damage(self, wearer, dmg):
        """受到伤害前触发，可修改 dmg"""
        return dmg

    def on_attacked(self, wearer, attacker, dmg):
        """每次被攻击后触发"""
        pass

    def on_fatal(self, wearer):
        """
        临界（hp<=0）时触发一次，自救或其他
        返回 True 则移除自身 Buff
        """
        return False


class SteelHeartBuff(Buff):
    """刚毅：受到致命伤时自救一次，可叠加"""
    display_name = "刚毅"
    dispellable  = False
    max_stacks   = 99  # ✅ 允许叠加

    def __init__(self, uses: int = 1):
        super().__init__(stacks=uses)

    def on_fatal(self, wearer):
        if self.stacks > 0:
            self.stacks -= 1
            wearer.hp = 1
            wearer.shield += int(wearer.max_hp * 0.3)
            return self.stacks == 0  # 最后1次后移除
        return False


class RegenerationBuff(Buff):
    """
    再生：每层每秒回复 1 点 HP，持续存在（无限）。
    """
    display_name = "再生"
    dispellable  = True
    max_stacks   = 99
    is_debuff    = False

    def __init__(self, stacks: int = 1):
        super().__init__(stacks=stacks)
        self._timer = 0.0  # 新增：秒计时器

    def on_tick(self, wearer, dt):
        self._timer += dt  # 累加每帧的时间
        
        # 当计时器超过或等于1秒时，执行回血
        while self._timer >= 1.0:
            amount = self.stacks  # 每秒回复量 = 层数
            
            # ### 最终修复：从 current_opponent 获取目标，并作为 combat_target 传入 ###
            opponent = getattr(wearer, "current_opponent", None)
            wearer.heal(amount, combat_target=opponent)
            
            self._timer -= 1.0  # 计时器减去1秒，准备下一次计时
        return None


class PoisonDebuff(Buff):
    """
    毒：每层每秒对角色造成 1 点毒系伤害；优先消耗护盾
    """
    display_name = "毒"
    dispellable  = True
    max_stacks   = 99
    is_debuff    = True

    def __init__(self, stacks: int = 1):
        super().__init__(stacks=stacks)
        self._timer = 0.0

    def on_tick(self, wearer, dt):
        self._timer += dt
        while self._timer >= 1.0:
            dmg = self.stacks
            # <-- 核心修改：创建并发送一个伤害信息包 -->
            packet = DamagePacket(
                amount=dmg, 
                damage_type=DamageType.POISON, # 类型是毒
                is_dot=True,                   # 标记为持续伤害
                is_sourceless=True             # 标记为无来源伤害
            )
            wearer.take_damage(packet)
            self._timer -= 1.0
        return None


class AttackDisabledBuff(Buff):
    """通用：禁止角色普攻"""
    display_name    = "无法攻击"
    dispellable     = False
    is_debuff       = True
    hidden          = True
    disable_attack  = True

    def __init__(self, duration: float):
        super().__init__(stacks=1)
        self.remaining = duration

    def on_tick(self, wearer, dt):
        if self.remaining is None:
            return None
        self.remaining -= dt
        if self.remaining <= 0:
            wearer.remove_buff(self)
        return None

class StunDebuff(Buff):
    """
    眩晕：禁止普攻，不可叠加，不可驱散
    """
    display_name    = "眩晕"
    max_stacks      = 1
    dispellable     = False
    is_debuff       = True
    disable_attack  = True
    duration        = 2.0

    def __init__(self, duration=2.0):
        super().__init__(duration_override=duration)

    def on_apply(self, wearer):
        for b in wearer.buffs:
            if b is not self and isinstance(b, StunDebuff):
                b.remaining = max(b.remaining, self.remaining)
                wearer.remove_buff(self)
                return

    def on_tick(self, wearer, dt):
        self.remaining -= dt
        if self.remaining <= 0:
            wearer.remove_buff(self)
        return None


# 替换 Buffs.py 中的 ThornsBuff 类
class ThornsBuff(Buff):
    """荆棘：被攻击时反弹当前层数的真实伤害给攻击者"""
    display_name  = "荆棘"
    dispellable   = True
    is_debuff     = False
    max_stacks    = 99

    def on_attacked(self, wearer, attacker, dmg):
        if attacker is not None and self.stacks > 0 and attacker.hp > 0:
            # 创建一个真实伤害、无来源的伤害包进行反伤
            thorns_packet = DamagePacket(
                amount=self.stacks,
                damage_type=DamageType.TRUE,
                source=wearer,
                is_sourceless=True
            )
            attacker.take_damage(thorns_packet)

class PhoenixCrownStage1Buff(Buff):
    """不灭·觉醒（Stage1）：防御→攻击+攻速"""
    display_name  = "不灭·觉醒"
    dispellable   = False
    is_debuff     = False

    def __init__(self):
        super().__init__(stacks=1)
        self._boosted = False

    def on_apply(self, wearer):
        bm = wearer.base_max_hp
        wearer.max_hp = bm * 2
        wearer.hp     = min(wearer.hp + bm, wearer.max_hp)

    def on_tick(self, wearer, dt):
        if not self._boosted:
            bd = wearer.base_defense
            ba = wearer.base_attack
            bs = wearer.base_attack_speed
            wearer.attack = ba + bd
            wearer.attack_speed = bs + bd * 0.05
            wearer.attack_interval = 6.0 / wearer.attack_speed
            wearer.defense = 0
            self._boosted = True
        if wearer.hp / wearer.max_hp <= 0.2:
            wearer.remove_buff(self)
            wearer.add_buff(PhoenixCrownStage2Buff())
        return None


# 文件: Buffs.py (完整替换 PhoenixCrownStage2Buff 这个类)

class PhoenixCrownStage2Buff(Buff):
    """不灭·第二阶段：禁手+回血反击"""
    display_name    = "不灭"
    dispellable     = False
    is_debuff       = False
    disable_attack  = True

    def __init__(self):
        super().__init__(stacks=1)
        # ### 核心修改 1：不再使用 _healed_total，改为 _damage_to_deal ###
        self._damage_to_deal = 0.0
        self._rec_atk        = None
        self._rec_def        = None
        self._rec_as         = None
        self._rec_dr         = None
        self._timer          = 0.0

    def on_apply(self, wearer):
        # ### 核心修改 2：在Buff生效时，立刻计算并储存应造成的总伤害 ###
        # 这个伤害值等于角色当时已损失的生命值。
        self._damage_to_deal = wearer.max_hp - wearer.hp
        
        # 保存角色属性 (这部分不变)
        self._rec_atk  = wearer.attack
        self._rec_def  = wearer.defense
        self._rec_as   = wearer.attack_speed
        self._rec_dr   = wearer.damage_resistance
        wearer.damage_resistance = self._rec_dr + 0.5

    # 文件: Buffs.py (在 PhoenixCrownStage2Buff 类中，替换 on_tick 方法)
    def on_tick(self, wearer, dt):
        self._timer += dt

        if self._timer >= 1.0:
            if wearer.hp < wearer.max_hp:
                heal_amount = wearer.max_hp * 0.1
                # ### 核心修改：从 current_opponent 获取目标 ###
                opponent = getattr(wearer, "current_opponent", None)
                wearer.heal(heal_amount, combat_target=opponent)
            self._timer -= 1.0

        if wearer.hp >= wearer.max_hp:
            total = int(self._damage_to_deal)
            # ### 核心修改：从 current_opponent 获取目标 ###
            opponent = getattr(wearer, "current_opponent", None)

            if opponent and opponent.hp > 0:
                # ... (后续的伤害和日志逻辑不变, 只是把 attacker 换成了 opponent)
                from damage import DamagePacket, DamageType
                from ui import format_damage_log
                packet = DamagePacket(total, DamageType.TRUE, source=wearer, is_sourceless=True)
                damage_details = opponent.take_damage(packet)
                log_parts = format_damage_log(damage_details, action_name="不灭反击")
                battle_logger.log(log_parts)

            # ... (恢复属性的部分不变) ...
            wearer.remove_buff(self)
            return None

        return None



class BleedDebuff(Buff):
    """
    流血 (可叠加, 可驱散)
    每层每秒对目标造成 1 点真实伤害（无视防御）。
    """
    display_name = "流血"
    dispellable  = True
    is_debuff    = True
    max_stacks   = 99

    def __init__(self, stacks: int = 1, duration: float = 5.0):
        super().__init__(stacks=stacks, duration_override=duration)
        self._timer = 0.0

    def on_tick(self, wearer, dt):
        self._timer += dt
        if self._timer >= 1.0:
            dmg = self.stacks
            # <-- 核心修改：创建并发送一个伤害信息包 -->
            packet = DamagePacket(
                amount=dmg,
                damage_type=DamageType.TRUE, # 类型是真实伤害
                is_dot=True,
                is_sourceless=True
            )
            wearer.take_damage(packet)
            self._timer -= 1.0
        
        self.remaining -= dt
        if self.remaining <= 0:
            wearer.remove_buff(self)
        return None

class BlockBuff(Buff):
    """格挡：每层可以完全抵挡一次任意来源的伤害。"""
    display_name = "格挡"
    max_stacks   = 99

    def before_take_damage(self, wearer, packet: DamagePacket): # <-- 参数改为 packet
        if self.stacks > 0 and packet.amount > 0:
            print(f"[格挡] 效果触发！抵挡了 {int(packet.amount)} 点伤害。")
            self.stacks -= 1
            if self.stacks <= 0:
                wearer.remove_buff(self)
            
            packet.amount = 0 # 将伤害包的数值清零


class DragonSoulBuff(Buff):
    """【龙魂】：一种特殊的能量资源，可被消耗。"""
    display_name = "龙魂"
    max_stacks   = 10 # 龙魂上限为10层
    is_debuff    = False

class SunstoneBrandDebuff(Buff):
    """【日之烙印】：一种可被引爆的印记。"""
    display_name = "日之烙印"
    is_debuff    = True
    max_stacks   = 99

class SunderDebuff(Buff):
    """【破甲】(Debuff): 每层使目标的防御力降低1点。"""
    display_name = "破甲"
    is_debuff    = True
    max_stacks   = 99

class VitalityBloomBuff(Buff):
    """【生机绽放】(Buff): 受到伤害时，恢复等同于 层数 * 1% 最大生命值的生命。"""
    display_name = "生机绽放"
    max_stacks   = 99

    def on_attacked(self, wearer, attacker, dmg):
        if dmg > 0:
            heal_amount = wearer.max_hp * (self.stacks * 0.01)
            # ### 核心修复：将攻击者 attacker 作为 combat_target 传入 ###
            wearer.heal(heal_amount, combat_target=attacker)

class WitheredCurseDebuff(Buff):
    """【凋零咒印】(Debuff): 持续期间，受到的所有治疗效果转变为等量真实伤害。"""
    display_name = "凋零咒印"
    is_debuff    = True
    duration     = 5.0 # 假设持续5秒

    def on_tick(self, wearer, dt):
        # 持续时间递减
        self.remaining -= dt
        if self.remaining <= 0:
            wearer.remove_buff(self)

    def before_healed(self, wearer, amount):
        """这是一个新的自定义钩子，会在Character.heal中被调用"""
        if amount > 0:
            print(f"[凋零咒印] {wearer.name} 的治疗被转化为了伤害！")
            from damage import DamagePacket, DamageType
            packet = DamagePacket(amount, DamageType.TRUE, is_sourceless=True)
            wearer.take_damage(packet)
        return 0 # 返回0，阻止本次治疗

class FrenzyBuff(Buff):
    """【狂热】(Buff): 持续期间，攻击速度翻倍。"""
    display_name = "狂热"
    duration     = 8.0 # 假设持续8秒

    def on_tick(self, wearer, dt):
        self.remaining -= dt
        if self.remaining <= 0:
            wearer.remove_buff(self)
            wearer.recalculate_stats() # Buff消失后，需要重算属性

class SunfireAuraDebuff(Buff):
    """【日炎灼烧】(Debuff): 每秒受到施加者最大生命值5%的真实伤害。"""
    display_name = "日炎灼烧"
    is_debuff    = True

    def __init__(self, source_char):
        super().__init__()
        self.source = source_char # 需要知道是谁施加的
        self._timer = 0.0

    def on_tick(self, wearer, dt):
        self._timer += dt
        if self._timer >= 1.0:
            self._timer -= 1.0
            from damage import DamagePacket, DamageType
            damage = self.source.max_hp * 0.05
            packet = DamagePacket(damage, DamageType.TRUE, source=self.source, is_dot=True)
            wearer.take_damage(packet)

class CovenantOfFateBuff(Buff):
    """【命运契约】(Buff): 持续期间，你受到伤害时，攻击者也会受到等量的真实伤害。"""
    display_name = "命运契约"
    duration     = 10.0 # 假设持续10秒

    def on_tick(self, wearer, dt):
        self.remaining -= dt
        if self.remaining <= 0:
            wearer.remove_buff(self)

    def on_attacked(self, wearer, attacker, dmg):
        if attacker and attacker.hp > 0 and dmg > 0:
            from damage import DamagePacket, DamageType
            print(f"[命运契约] 对 {attacker.name} 反弹了 {int(dmg)} 点真实伤害！")
            packet = DamagePacket(dmg, DamageType.TRUE, source=wearer)
            attacker.take_damage(packet)
            
class StormDebuff(Buff):
    """【风暴印记】(Debuff): 每次受到伤害时，额外承受等同于风暴印记层数的伤害。"""
    display_name = "风暴"
    dispellable  = True
    is_debuff    = True
    max_stacks   = 99

    def before_take_damage(self, wearer, packet: DamagePacket):
        if packet.amount > 0:
            print(f"[风暴印记] 额外造成 {self.stacks} 点伤害！")
            packet.amount += self.stacks


================================================================================
### 文件路径: Character.py
================================================================================

# Character.py (最终完整版)
import pygame
import sys
import time
import collections
import math
import random
# from rich.console import Console  <- No longer needed
# console = Console()

import Buffs
import Talents
import Equips
from damage import DamagePacket, DamageType
from settings import RARITY_COLORS
from ui import format_damage_log

RARITY_GOLD_VALUE = {"common": 10, "uncommon": 25, "rare": 60, "epic": 150, "legendary": 400, "mythic": 1000}

class Character:
    DEFAULT_SLOT_CAPACITY = {"weapon": 1, "offhand": 1, "helmet": 1, "armor": 1, "pants": 1, "accessory": 4}

    # File: Character.py (Replace this method)
    def __init__(self, name, hp, defense, magic_resist, attack, attack_speed,
                equipment=None, talents=None, id=None):

        self.id = id or name
        self.name, self.level, self.gold = name, 1, 0
        self.exp, self.exp_to_next_level, self.backpack = 0, 100, []
        self.SLOT_CAPACITY = self.DEFAULT_SLOT_CAPACITY.copy()
        self.max_talent_slots = 3
        self.learned_talents = talents or []
        
        # --- CORE FIX: Initialize equipped_talents with None placeholders ---
        self.equipped_talents = [None] * self.max_talent_slots
        
        self.buffs = []
        self.shield = 0
        self._cd = 0.0
        self.crit_chance = 0.0
        self.crit_multiplier = 1.5
        self.last_damage = 0
        self.last_hits = collections.deque(maxlen=5)
        self.damage_resistance = 0.0

        self._innate_max_hp, self._innate_defense, self._innate_attack, self._innate_attack_speed = hp, defense, attack, attack_speed
        self.magic_resist = magic_resist
        
        self.slots = {
            slot: [None] * capacity for slot, capacity in self.SLOT_CAPACITY.items()
        }
        
        for eq in (equipment or []):
            self.equip(eq)

        self.base_max_hp, self.base_defense, self.base_attack, self.base_attack_speed = 0, 0, 0, 0
        
        # Temporarily store learned talents to equip them after stats are ready
        initial_talents_to_equip = self.learned_talents[:]
        self.learned_talents = [] # Clear and re-learn to ensure no duplicates
        
        for talent in initial_talents_to_equip:
            self.learn_talent(talent)
            self.equip_talent(talent) # This will now work correctly

        # Final stat calculation after initial equipment and talents
        self.recalculate_stats()
        self.hp = self.max_hp
            
    def add_gold(self, amount, source=""):
        if amount <= 0: return None
        self.gold += amount
        source_text = f" ({source})" if source else ""
        return f"获得了 {amount} G！{source_text} (当前: {self.gold} G)"

    # 文件: Character.py (替换这个函数)

    def pickup_item(self, item_to_pickup):
        """拾取物品，包含更完善的重复判定和调试信息。"""
        from Equips import UPGRADE_MAP
        
        item_name = getattr(item_to_pickup, 'display_name', item_to_pickup.__class__.__name__)
        print(f"\n--- 正在尝试拾取: {item_name} ---")

        all_current_items = self.backpack + self.all_equipment
        
        # 判定规则 1: 是否已存在同名物品
        is_duplicate_by_name = any(getattr(item, 'display_name', '') == item_name for item in all_current_items)
        if is_duplicate_by_name:
            print(f"调试信息: 发现同名物品 '{item_name}'，判定为重复。")

        # 判定规则 2: 是否已拥有该物品的升级版 (新功能)
        is_inferior_version = False
        item_class = item_to_pickup.__class__
        if item_class in UPGRADE_MAP:
            upgraded_class = UPGRADE_MAP[item_class]
            if any(isinstance(item, upgraded_class) for item in all_current_items):
                is_inferior_version = True
                print(f"调试信息: 已拥有 '{item_name}' 的升级版，判定为重复。")

        # 最终判定
        is_duplicate = is_duplicate_by_name or is_inferior_version
        print(f"最终判定结果: is_duplicate = {is_duplicate}")

        if is_duplicate:
            print("执行操作: 转化为金币。")
            rarity = getattr(item_to_pickup, 'rarity', 'common')
            gold_value = RARITY_GOLD_VALUE.get(rarity, 5)
            return self.add_gold(gold_value, source=f"转化({item_name})")
        else:
            print("执行操作: 放入背包。")
            self.backpack.append(item_to_pickup)
            return f"物品「{item_name}」已放入你的背包。"
        
    # ... (其他所有方法都保持不变)
    def learn_talent(self, talent_to_learn):
        if not any(isinstance(t, talent_to_learn.__class__) for t in self.learned_talents):
            self.learned_talents.append(talent_to_learn)
            print(f"学会了新天赋: {talent_to_learn.display_name}")
            return True
        return False

    # File: Character.py (Replace this method)
    def equip_talent(self, talent_to_equip, specific_index=None):
        if talent_to_equip not in self.learned_talents:
            print("尚未学会该天赋！")
            return False
        if talent_to_equip in self.equipped_talents:
            print("该天赋已被装备。")
            return False

        # If a specific slot is targeted
        if specific_index is not None:
            if 0 <= specific_index < self.max_talent_slots:
                if self.equipped_talents[specific_index] is None:
                    self.equipped_talents[specific_index] = talent_to_equip
                    self.recalculate_stats()
                    print(f"已装备天赋: {talent_to_equip.display_name} 到槽位 {specific_index}")
                    return True
                else: # Slot is occupied, this should be handled by swap logic in the UI
                    return False 
        
        # If no specific slot, find the first empty one
        else:
            try:
                empty_index = self.equipped_talents.index(None)
                self.equipped_talents[empty_index] = talent_to_equip
                self.recalculate_stats()
                print(f"已装备天赋: {talent_to_equip.display_name} 到槽位 {empty_index}")
                return True
            except ValueError:
                print("天赋槽已满！")
                return False
            
    # File: Character.py (Replace this method)
    def unequip_talent(self, talent_to_unequip):
        if talent_to_unequip not in self.equipped_talents:
            return
        # Find the talent and replace it with None, instead of removing it
        index = self.equipped_talents.index(talent_to_unequip)
        self.equipped_talents[index] = None
        self.recalculate_stats()
        print(f"已卸下天赋: {talent_to_unequip.display_name}")
        
    def on_enter_combat(self):
        self.buffs.clear(); self.hp = self.max_hp; self.shield = 0; self._cd = 0.0;

        # 新增逻辑：重置装备的战斗内状态
        for eq in self.all_equipment:
            if isinstance(eq, Equips.AdventurersPouch):
                eq.atk_bonus = 0 # 战斗准备时，将钱袋的加成清零

        # 重置完后再重算一次属性，确保一个干净的状态
        self.recalculate_stats() 
        print(f"{self.name} 已进入战斗准备状态！")

    # 文件: Character.py (请用这个新版本替换整个 update 函数)

    # 文件: Character.py (还原 update 函数)
    def update(self, dt) -> list[str]:
        texts = []
        for buff in list(self.buffs):
            if hasattr(buff, "on_tick"):
                res = buff.on_tick(self, dt)
                if isinstance(res, str) and res:
                    texts.append(res) # 恢复成只处理字符串
        for eq in self.all_equipment:
            if hasattr(eq, "on_tick"):
                res = eq.on_tick(self, dt)
                if isinstance(res, str) and res:
                    texts.append(res)
        return texts

    def recalculate_stats(self):
        hp_percent = self.hp / self.max_hp if hasattr(self, 'max_hp') and self.max_hp > 0 else 1
        self.base_max_hp = self._innate_max_hp
        self.base_defense = self._innate_defense
        self.base_attack = self._innate_attack
        self.base_attack_speed = self._innate_attack_speed
        all_eq = self.all_equipment
        self.base_max_hp += sum(getattr(eq, "hp_bonus", 0) for eq in all_eq)
        self.base_defense += sum(getattr(eq, "def_bonus", 0) for eq in all_eq)
        self.base_attack += sum(getattr(eq, "atk_bonus", 0) for eq in all_eq)
        self.base_attack_speed += sum(getattr(eq, "as_bonus", 0) for eq in all_eq)
        self.max_hp = self.base_max_hp
        self.defense = self.base_defense
        self.attack = self.base_attack
        self.attack_speed = self.base_attack_speed
        self.crit_chance = 0.0 
        self.magic_resist = 3 
        self.damage_resistance = 0.0
        self.SLOT_CAPACITY = self.DEFAULT_SLOT_CAPACITY.copy()
        for talent in self.equipped_talents:
            if hasattr(talent, 'on_init'):
                talent.on_init(self)
        for slot, required_capacity in self.SLOT_CAPACITY.items():
            current_slots = self.slots.get(slot, [])
            current_capacity = len(current_slots)
            if current_capacity < required_capacity:
                current_slots.extend([None] * (required_capacity - current_capacity))
            elif current_capacity > required_capacity:
                extra_items = current_slots[required_capacity:]
                for item in extra_items:
                    if item: self.backpack.append(item)
                self.slots[slot] = current_slots[:required_capacity]
        
        # --- 新增：处理特殊Buff和Debuff对属性的直接影响 ---
        self.defense -= sum(b.stacks for b in self.buffs if isinstance(b, Buffs.SunderDebuff))
        self.defense = max(0, self.defense) # 防御不能为负
        if any(isinstance(b, Buffs.FrenzyBuff) for b in self.buffs):
            self.attack_speed *= 2
        # --- 新增结束 ---

        self.magic_resist += sum(getattr(eq, "magic_resist_bonus", 0) for eq in all_eq)
        self.crit_chance += sum(getattr(eq, "crit_bonus", 0) for eq in all_eq)
        self.hp = min(self.max_hp, self.max_hp * hp_percent)
        self.attack_interval = 6.0 / self.attack_speed if self.attack_speed > 0 else 999
        print("角色属性已更新！")

    @property
    def all_equipment(self):
        eqs = []
        for eq_list in self.slots.values():
            # 筛选出不是 None 的真实装备
            eqs.extend([item for item in eq_list if item is not None])
        return eqs

# --- 3. 完整替换 equip 方法 ---
    def equip(self, eq_to_equip, specific_index=None):
        """装备一件物品，可以指定精确的槽位索引。"""
        slot = eq_to_equip.slot
        if slot not in self.SLOT_CAPACITY:
            raise ValueError(f"未知插槽：{slot}")

        # 如果指定了索引
        if specific_index is not None:
            if 0 <= specific_index < self.SLOT_CAPACITY[slot]:
                # 卸下目标槽位原有的物品
                unequipped_item = self.slots[slot][specific_index]
                # 穿上新物品
                self.slots[slot][specific_index] = eq_to_equip
                self.recalculate_stats()
                return unequipped_item # 返回被替换下的物品 (可能是None)
            else:
                return eq_to_equip # 索引无效，装备失败

        # 如果未指定索引，则自动寻找空位
        else:
            try:
                # 找到第一个空槽位 (值为None)
                empty_index = self.slots[slot].index(None)
                self.slots[slot][empty_index] = eq_to_equip
                self.recalculate_stats()
                return None # 成功装备到空槽，没有物品被替换
            except ValueError:
                # 如果找不到None，说明槽位已满
                # 对于单槽位，直接替换
                if self.SLOT_CAPACITY[slot] == 1:
                    unequipped_item = self.slots[slot][0]
                    self.slots[slot][0] = eq_to_equip
                    self.recalculate_stats()
                    return unequipped_item
                else: # 多槽位已满且未指定索引，则失败
                    print(f"警告: {slot} 插槽已满且未指定替换位置")
                    return eq_to_equip

# --- 4. 完整替换 unequip 方法 ---
    def unequip(self, eq_to_unequip):
        """从角色身上卸下指定的装备。"""
        slot = eq_to_unequip.slot
        if eq_to_unequip in self.slots[slot]:
            # 找到物品的索引
            index = self.slots[slot].index(eq_to_unequip)
            # 将该位置设置回 None
            self.slots[slot][index] = None
            self.recalculate_stats()
            return eq_to_unequip # 返回被卸下的物品
        return None

    def take_damage(self, packet: DamagePacket):
        """
        角色受到伤害的核心处理函数。
        增加了“记录最后攻击者”的功能。
        """
        # ### 核心修复 2：记录伤害来源 ###

        # 触发钩子：受到伤害前
        for buff in list(self.buffs):
            if hasattr(buff, 'before_take_damage'): buff.before_take_damage(self, packet)
        for eq in self.all_equipment:
            if hasattr(eq, 'before_take_damage'): eq.before_take_damage(self, packet)

        initial_amount_after_hooks = packet.amount
        final_shield_absorbed = 0

        # 1. 护盾吸收
        if self.shield > 0 and packet.amount > 0:
            absorbed = min(self.shield, packet.amount)
            self.shield -= absorbed
            packet.amount -= absorbed
            final_shield_absorbed = absorbed

        # 2. 计算伤害减免
        final_hp_deduction = 0
        if packet.amount > 0:
            reduction = 0.0
            if packet.damage_type not in [DamageType.TRUE] and not packet.ignores_armor:
                if packet.damage_type == DamageType.PHYSICAL:
                    reduction = self.defense / (self.defense + 100)
                elif packet.damage_type == DamageType.MAGIC:
                    reduction = self.magic_resist / (self.magic_resist + 100)
            final_hp_deduction = packet.amount * (1.0 - reduction)

        # 3. 最终扣血
        final_hp_deduction = max(0, int(final_hp_deduction))
        self.hp -= final_hp_deduction
        if self.hp < 0: self.hp = 0

        # 4. 触发钩子：受到伤害后
        if packet.source:
            self.on_attacked(packet.source, final_hp_deduction)

        # 5. 返回伤害报告
        return {
            "source": packet.source,
            "target": self,
            "final_amount": final_hp_deduction,
            "shield_absorbed": int(final_shield_absorbed),
            "damage_type": packet.damage_type,
            "is_critical": packet.is_critical,
            "is_dot": packet.is_dot,
            "is_fatal": self.hp <= 0,
        }

    # --- 附带修改：确保 on_attacked 也被调用 ---
    # (你的代码中缺少这个函数，请在 take_damage 函数下方添加它)
    def on_attacked(self, attacker, dmg):
        """每次被攻击后触发"""
        for b in self.buffs:
            if hasattr(b, "on_attacked"):
                b.on_attacked(self, attacker, dmg)
        for eq in self.all_equipment:
            if hasattr(eq, "on_attacked"):
                eq.on_attacked(self, attacker, dmg)

    def try_attack(self, target, dt):
        if any(getattr(b, "disable_attack", False) for b in self.buffs): return None
        self._cd += dt
        if self._cd < self.attack_interval or self.hp <= 0: return None

        # ... (准备伤害包裹和调用钩子的部分保持不变) ...
        is_crit = (random.random() < self.crit_chance)
        damage = self.attack * self.crit_multiplier if is_crit else self.attack
        packet = DamagePacket(amount=damage, damage_type=DamageType.PHYSICAL, source=self, is_critical=is_crit)
        
        for t in self.equipped_talents:
            if t and hasattr(t, "before_attack"): t.before_attack(self, target, packet)
        for eq in self.all_equipment:
            if hasattr(eq, "before_attack"): eq.before_attack(self, target, packet)

        damage_details = target.take_damage(packet)
        actual_dmg = damage_details["final_amount"]
        
        # ... (攻击后钩子逻辑保持不变) ...
        extra_texts = []
        for t in self.equipped_talents:
            if t and hasattr(t, "on_attack"):
                out = t.on_attack(self, target, actual_dmg)
                if out: extra_texts.extend(out)
        self._cd -= self.attack_interval

        log_parts = format_damage_log(damage_details, action_name="普攻")

        # 4. 返回这个富文本列表和额外信息
        return (log_parts, extra_texts)


    def perform_extra_attack(self, target):
        """
        执行一次标准化的额外攻击。
        这个方法现在会自己处理伤害计算和日志记录。
        """
        from battle_logger import battle_logger, format_damage_log
        
        # 1. 准备伤害包裹 (与 try_attack 逻辑一致)
        is_crit = (random.random() < self.crit_chance)
        damage = self.attack * self.crit_multiplier if is_crit else self.attack
        packet = DamagePacket(amount=damage, damage_type=DamageType.PHYSICAL, source=self, is_critical=is_crit)
        
        # 2. 触发攻击前钩子
        for eq in self.all_equipment:
            if hasattr(eq, "before_attack"): eq.before_attack(self, target, packet)
        
        # 3. 造成伤害并获取伤害报告
        damage_details = target.take_damage(packet)
        actual_dmg = damage_details["final_amount"]
        
        # 4. 使用标准工具格式化日志并播报
        log_parts = format_damage_log(damage_details, action_name="额外攻击")
        battle_logger.log(log_parts)
        
        # 5. 触发攻击后钩子
        for eq in self.all_equipment:
            if hasattr(eq, "after_attack"): eq.after_attack(self, target, actual_dmg)
        if is_crit:
            for eq in self.all_equipment:
                if hasattr(eq, "on_critical"): eq.on_critical(self, target, actual_dmg)
        else:
            for eq in self.all_equipment:
                if hasattr(eq, "on_non_critical"): eq.on_non_critical(self, target, actual_dmg)
                

    
    def heal(self, amount: float, combat_target=None) -> float:
        # 钩子：治疗前
        for buff in list(self.buffs):
            if hasattr(buff, 'before_healed'):
                amount = buff.before_healed(self, amount)

        healed = min(self.max_hp - self.hp, amount)
        if healed <= 0: return 0.0
        self.hp += healed

        # 钩子：治疗后
        for talent in list(self.equipped_talents):
            if talent and hasattr(talent, 'on_healed'):
                talent.on_healed(self, healed, combat_target)

        return healed
        
    def add_status(self, status: Buffs.Buff, *, source: "Character" = None):
        final_buff = None
        added_stacks = status.stacks
        for b in self.buffs:
            if isinstance(b, status.__class__):
                if b.max_stacks == 1:
                    b.remaining = b.duration
                else:
                    b.stacks = min(b.stacks + status.stacks, b.max_stacks)
                final_buff = b
                break
        if final_buff is None:
            final_buff = status
            self.buffs.append(status)
            status.on_apply(self)
        
        # --- 新增的钩子 ---
        # 触发装备的 on_buff_applied 效果
        for eq in self.all_equipment:
            if hasattr(eq, 'on_buff_applied'):
                eq.on_buff_applied(self, final_buff)
        # --- 钩子结束 ---

        if source is not None and source is not self and getattr(final_buff, "is_debuff", False):
            for t in source.equipped_talents: # 注意：这里检查的是 source 的天赋
                if hasattr(t, "on_inflict_debuff"):
                    t.on_inflict_debuff(source, self, final_buff, added_stacks)
        if getattr(final_buff, "dispellable", False) and getattr(final_buff, "is_debuff", False):
            for t in self.equipped_talents:
                if hasattr(t, "on_debuff_applied"):
                    t.on_debuff_applied(self, final_buff)
                    
    add_buff, add_debuff = add_status, add_status

    def remove_buff(self, buff): self.buffs.remove(buff); buff.on_remove(self)

    def add_exp(self, amount):
        if self.hp <= 0: return []
        
        original_amount = amount
        if any(isinstance(t, Talents.Adventurer) for t in self.equipped_talents):
            bonus_amount = int(original_amount * 0.5)
            amount += bonus_amount
            print(f"[冒险者] 天赋触发！额外获得 {bonus_amount} 点经验！")
        self.exp += amount
        messages = [f"获得了 {amount} 点经验！ (当前: {self.exp}/{self.exp_to_next_level})"]
        if self.exp >= self.exp_to_next_level:
            messages.extend(self.level_up())
        return messages

    def level_up(self):
        level_up_messages = []
        while self.exp >= self.exp_to_next_level:
            self.level += 1; self.exp -= self.exp_to_next_level; self.exp_to_next_level = int(self.exp_to_next_level * 1.5)
            self._innate_max_hp += 10; self._innate_attack += 2; self._innate_defense += 1
            self.recalculate_stats()
            level_up_messages.append(f"🎉 等级提升！现在是 {self.level} 级！"); level_up_messages.append("   生命+10，攻击+2，防御+1")
        return level_up_messages
    
    def gain_level(self, levels=1):
        """(沙盒专用) 提升等级并增加基础属性"""
        self.level += levels
        # 按照 level_up 的标准增加固有属性
        self._innate_max_hp += 10 * levels
        self._innate_attack += 2 * levels
        self._innate_defense += 1 * levels
        self.recalculate_stats()
        self.hp = self.max_hp # 升级后回满血
        print(f"等级提升至 {self.level} 级。")

    def lose_level(self, levels=1):
        """(沙盒专用) 降低等级并减少基础属性"""
        # 防止降到1级以下
        actual_levels_lost = min(levels, self.level - 1)
        if actual_levels_lost <= 0:
            return
            
        self.level -= actual_levels_lost
        self._innate_max_hp -= 10 * actual_levels_lost
        self._innate_attack -= 2 * actual_levels_lost
        self._innate_defense -= 1 * actual_levels_lost
        self.recalculate_stats()
        self.hp = self.max_hp # 降级后也回满血
        print(f"等级降低至 {self.level} 级。")


================================================================================
### 文件路径: combine_code.py
================================================================================

import os
import datetime

# --- 配置 ---
# 要搜索的根文件夹 ('.' 代表当前文件夹)
ROOT_DIR = '.'
# 要包含的文件扩展名
FILE_EXTENSIONS = ('.py', '.json')
# 输出文件名
OUTPUT_FILE = 'combined_code.txt'
# --- 结束配置 ---

def combine_files():
    """
    遍历指定目录及其子目录，将特定扩展名的文件内容合并到一个文件中。
    """
    print(f"开始扫描文件夹: {os.path.abspath(ROOT_DIR)}")
    print(f"将要合并的文件类型: {FILE_EXTENSIONS}")
    
    # 使用 with 语句确保文件被正确关闭
    with open(OUTPUT_FILE, 'w', encoding='utf-8') as outfile:
        # 写入文件头部信息
        outfile.write(f"--- 代码合集生成于: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')} ---\n")
        outfile.write(f"--- 根目录: {os.path.abspath(ROOT_DIR)} ---\n\n")
        
        # os.walk() 会递归地遍历目录
        for dirpath, _, filenames in os.walk(ROOT_DIR):
            for filename in filenames:
                # 检查文件扩展名是否符合要求
                if filename.endswith(FILE_EXTENSIONS):
                    # 构建完整的文件路径
                    file_path = os.path.join(dirpath, filename)
                    # 获取相对路径，这样更清晰
                    relative_path = os.path.relpath(file_path, ROOT_DIR)
                    
                    print(f"正在添加文件: {relative_path}")
                    
                    # 写入文件分隔符和路径信息
                    outfile.write("=" * 80 + "\n")
                    outfile.write(f"### 文件路径: {relative_path}\n")
                    outfile.write("=" * 80 + "\n\n")
                    
                    try:
                        # 读取源文件内容并写入输出文件
                        with open(file_path, 'r', encoding='utf-8') as infile:
                            outfile.write(infile.read())
                        outfile.write("\n\n\n") # 在文件末尾添加一些空行以作区分
                    except Exception as e:
                        # 如果文件读取失败（例如因为编码问题），则记录错误信息
                        outfile.write(f"*** 无法读取文件: {relative_path} | 错误: {e} ***\n\n\n")

    print(f"\n成功！所有代码已整合到文件: {OUTPUT_FILE}")

if __name__ == '__main__':
    combine_files()


================================================================================
### 文件路径: damage.py
================================================================================

# damage.py
from enum import Enum, auto

class DamageType(Enum):
    PHYSICAL = auto()      # 普通物理伤害
    MAGIC = auto()         # 魔法伤害
    TRUE = auto()          # 真实伤害
    POISON = auto()        # 毒系伤害
    DRAGON_SOURCE = auto() # 龙源伤害

class DamagePacket:
    """一个用来封装所有伤害信息的数据结构"""
    def __init__(self, amount, damage_type, source=None,
                 is_critical=False, is_dot=False, 
                 is_sourceless=False, ignores_armor=False):
        
        self.amount = amount               # 基础伤害数值
        self.damage_type = damage_type     # 伤害类型 (物理, 魔法, 真实...)
        self.source = source               # 伤害来源 (哪个角色)
        
        # --- 各种标志 (Flags) ---
        self.is_critical = is_critical         # 是否暴击
        self.is_dot = is_dot                   # 是否为持续伤害(DOT)
        self.is_sourceless = is_sourceless     # 是否为无来源伤害 (如环境、反伤)
        self.ignores_armor = ignores_armor     # 是否穿甲 (无视防御)

    def copy(self):
        """创建一个副本，方便在计算过程中修改而不影响原始包"""
        return DamagePacket(
            self.amount, self.damage_type, self.source,
            self.is_critical, self.is_dot, self.is_sourceless, self.ignores_armor
        )


================================================================================
### 文件路径: dungeon_generator.py
================================================================================

# 文件: dungeon_generator.py (完整替换)

import random
from settings import SCREEN_WIDTH, SCREEN_HEIGHT

class Room:
    def __init__(self, x, y, room_type="combat"):
        self.x, self.y, self.type = x, y, room_type
        self.doors = {"N": False, "S": False, "E": False, "W": False}
        self.is_cleared = False
        self.monsters = []
        # 你还可以添加 event_id, treasure_contents 等字段

class Floor:
    def __init__(self, width=21, height=21):
        self.width, self.height = width, height
        self.rooms, self.start_room, self.boss_room = {}, None, None

    def generate_floor(self, num_rooms=8, floor_data=None):
        """
        使用传入的 floor_data 动态生成楼层内容
        """
        self.rooms.clear()
        grid = [[None for _ in range(self.width)] for _ in range(self.height)]
        
        # 1. 创建房间布局 (这部分逻辑不变)
        sx, sy = self.width // 2, self.height // 2
        start_room = Room(sx, sy, "start")
        start_room.is_cleared = True
        grid[sy][sx] = start_room
        self.rooms[(sx, sy)] = start_room
        
        frontier = [(sx, sy)]
        
        while len(self.rooms) < num_rooms and frontier:
            px, py = random.choice(frontier)
            possible_neighbors = []
            directions = [(0, -1, "N", "S"), (0, 1, "S", "N"), (1, 0, "E", "W"), (-1, 0, "W", "E")]
            for dx, dy, door, opposite_door in directions:
                nx, ny = px + dx, py + dy
                if 0 <= nx < self.width and 0 <= ny < self.height and not grid[ny][nx]:
                    possible_neighbors.append((nx, ny, door, opposite_door))
            
            if possible_neighbors:
                nx, ny, door, opposite_door = random.choice(possible_neighbors)
                new_room = Room(nx, ny)
                grid[ny][nx] = new_room
                self.rooms[(nx, ny)] = new_room
                frontier.append((nx, ny))
                grid[py][px].doors[door] = True
                new_room.doors[opposite_door] = True
            else:
                frontier.remove((px, py))

        # --- 2. 核心修改：根据 floor_data 填充房间内容 ---
        if not floor_data:
            print("错误: 未提供楼层数据，无法填充内容！")
            return

        # 定位Boss房间 (逻辑不变)
        self.start_room = self.rooms[(sx, sy)]
        farthest_dist = -1
        boss_coord = (sx, sy)
        for coord in self.rooms.keys():
            dist = abs(coord[0] - sx) + abs(coord[1] - sy)
            if dist > farthest_dist and self.rooms[coord] is not self.start_room:
                farthest_dist = dist
                boss_coord = coord
        self.boss_room = self.rooms[boss_coord]
        self.boss_room.type = "boss"
        
        # 确定特殊房间类型和数量 (逻辑不变)
        room_type_pool = ["combat"] * 4 + ["event"] * 2 + ["treasure"]*2 + ["shop", "rest", "elite"]
        special_room_candidates = [r for r in self.rooms.values() if r.type == "combat"]
        for room_type in ["event", "treasure", "shop", "rest", "elite"]:
            if special_room_candidates:
                candidate = random.choice(special_room_candidates)
                candidate.type = room_type
                special_room_candidates.remove(candidate)

        # 动态填充怪物
        m_uid = 0
        for room in self.rooms.values():
            if room.type in ["combat", "elite", "boss"]:
                num = 1
                e_id = "slime" # 默认值

                if room.type == "boss":
                    num = 1
                    e_id = floor_data.get("boss_id", "ruin_golem")
                elif room.type == "elite":
                    num = random.randint(2, 3)
                    if floor_data.get("elite_pool"):
                        e_id = random.choice(floor_data["elite_pool"])
                else: # 普通战斗
                    num = random.randint(1, 3)
                    if floor_data.get("monster_pool"):
                        e_id = random.choice(floor_data["monster_pool"])
                
                for _ in range(num):
                    px, py = random.randint(100, SCREEN_WIDTH - 100), random.randint(100, SCREEN_HEIGHT - 100)
                    room.monsters.append({'id': e_id, 'pos': (px, py), 'uid': f'm_{m_uid}'})
                    m_uid += 1


================================================================================
### 文件路径: enemies.json
================================================================================

{
    "slime": {
        "name": "史莱姆",
        "stats": {
            "hp": 20,
            "defense": 2,
            "magic_resist": 0,
            "attack": 5,
            "attack_speed": 1.0
        },
        "exp_reward": 5,
        "possible_talents": [{"talent_class_name": "PoisonousTalent", "chance": 0.5}]
    },
    "goblin": {
        "name": "哥布林",
        "stats": {
            "hp": 40,
            "defense": 4,
            "magic_resist": 2,
            "attack": 8,
            "attack_speed": 1.2
        },
        "exp_reward": 8,
        "possible_talents": [{"talent_class_name": "DualWieldTalent", "chance": 0.5}]
        
    },
    "goblin_archer": {
        "name": "哥布林弓箭手", "exp_reward": 30,
        "stats": {"hp": 60, "defense": 2, "magic_resist": 1, "attack": 10, "attack_speed": 1.8},
        "possible_talents": [{"talent_class_name": "FirstStrike", "chance": 0.15}]
    },
    "goblin_captain": {
        "name": "哥布林队长", "exp_reward": 80,
        "stats": {"hp": 150, "defense": 8, "magic_resist": 5, "attack": 18, "attack_speed": 1.2},
        "possible_talents": [{"talent_class_name": "Brawler", "chance": 0.5}]
    },
    "armored_skeleton": {
        "name": "重甲骷髅", "exp_reward": 40,
        "stats": {"hp": 100, "defense": 20, "magic_resist": 5, "attack": 15, "attack_speed": 0.8}
    },
    "giant_bat": {
        "name": "巨型蝙蝠", "exp_reward": 35,
        "stats": {"hp": 70, "defense": 3, "magic_resist": 3, "attack": 10, "attack_speed": 2.5}
    },
    "wild_boar": {
        "name": "狂野野猪", "exp_reward": 50,
        "stats": {"hp": 200, "defense": 5, "magic_resist": 2, "attack": 20, "attack_speed": 1.0}
    },
    "forest_spirit": {
        "name": "森林之灵", "exp_reward": 60,
        "stats": {"hp": 120, "defense": 5, "magic_resist": 15, "attack": 15, "attack_speed": 1.1},
        "possible_talents": [{"talent_class_name": "MagicShield", "chance": 1.0}]
    },
    "rock_golem": {
        "name": "岩石傀儡", "exp_reward": 70,
        "stats": {"hp": 300, "defense": 15, "magic_resist": 10, "attack": 22, "attack_speed": 0.7},
        "possible_talents": [{"talent_class_name": "Giant", "chance": 1.0}]
    },
    "ruin_golem": {
        "name": "遗迹守护者", "exp_reward": 200,
        "stats": {"hp": 500, "defense": 25, "magic_resist": 15, "attack": 30, "attack_speed": 0.9},
        "possible_talents": [{"talent_class_name": "LastStand", "chance": 1.0}]
    },
    "mimic": {
        "name": "宝箱怪", "exp_reward": 100,
        "stats": {"hp": 150, "defense": 10, "magic_resist": 10, "attack": 25, "attack_speed": 1.5}

    },
    "fire_elemental": {
        "name": "火焰元素", "exp_reward": 120,
        "stats": {"hp": 180, "defense": 8, "magic_resist": 20, "attack": 28, "attack_speed": 1.3},
        "possible_talents": [{"talent_class_name": "FlameAura", "chance": 1.0}]
    },
    "ice_elemental": {
        "name": "冰霜元素", "exp_reward": 120,
        "stats": {"hp": 180, "defense": 8, "magic_resist": 20, "attack": 28, "attack_speed": 1.3},
        "possible_talents": [{"talent_class_name": "FrostAura", "chance": 1.0}]
    },
    "orc_warrior": {
        "name": "兽人战士", "exp_reward": 150,
        "stats": {"hp": 250, "defense": 12, "magic_resist": 5, "attack": 35, "attack_speed": 1.0},
        "possible_talents": [{"talent_class_name": "Berserker", "chance": 0.5}]
    },
    "orc_shaman": {
        "name": "兽人萨满", "exp_reward": 150,
        "stats": {"hp": 200, "defense": 8, "magic_resist": 15, "attack": 30, "attack_speed": 1.2},
        "possible_talents": [{"talent_class_name": "HealingWave", "chance": 0.5}]
    },
    "dark_knight": {
        "name": "黑暗骑士", "exp_reward": 300,
        "stats": {"hp": 400, "defense": 20, "magic_resist": 10, "attack": 50, "attack_speed": 1.0},
        "possible_talents": [{"talent_class_name": "Executioner", "chance": 1.0}]
    },
    "necromancer": {
        "name": "死灵法师", "exp_reward": 250,
        "stats": {"hp": 300, "defense": 10, "magic_resist": 25, "attack": 40, "attack_speed": 1.1},
        "possible_talents": [{"talent_class_name": "SummonSkeletons", "chance": 1.0}]
    },
    "poisonDragon": {
        "name": "毒龙",
        "stats": {
            "hp": 1800,
            "defense": 20,
            "magic_resist": 3,
            "attack": 18,
            "attack_speed": 1.5
        },
        "talents": [
            "PoisonousTalent",
            "BambooLeafTalent"
        ],
        "exp_reward": 800
    }
}


================================================================================
### 文件路径: Equips.py
================================================================================

import Buffs
import Talents
from damage import DamagePacket, DamageType
from abc import ABC
import collections
from collections import defaultdict
from rich.console import Console, Group
from rich.live import Live
from rich.table import Table
from rich.panel import Panel
from rich.text import Text
import time
import random
from rich.text import Text
from rich.progress import BarColumn
import math
from collections import Counter
import sys

class Equipment:
    slot = None
    def on_battle_start(self, wearer): pass
    def before_attack(self, wearer, target, dmg): return dmg
    def after_attack(self, wearer, target, dmg): pass
    def before_take_damage(self, wearer, dmg): return dmg
    def on_critical(self, wearer, target, dmg): pass
    def on_non_critical(self, wearer, target, dmg): pass

class WoodenShield(Equipment):
    """木盾：副手插槽；+2 防御；战斗开始时获得 10 护盾"""
    slot = "offhand"
    display_name    = "木盾"

    def __init__(self):
        self.type = "armor"
        self.def_bonus    = 2
        self.shield_bonus = 10

    def on_battle_start(self, wearer):
        # 防御是永久属性，由Character.__init__处理
        wearer.shield  += self.shield_bonus

class WoodenSword(Equipment):
    """木剑：武器插槽；+3 攻击；每普攻 3 次，第 4 次普攻造成双倍伤害"""
    slot = "weapon"
    display_name    = "木剑"

    def __init__(self):
        self.type = "weapon"
        self.rarity = "common"
        self.atk_bonus = 3
        self._count    = 0
    
    # on_battle_start 已被移除，因为攻击是永久属性

    def before_attack(self, wearer, target, packet: DamagePacket):
        # 效果现在修改的是伤害包的数值
        if self._count >= 3:
            packet.amount *= 2
            self._count = 0

    def after_attack(self, wearer, target, actual_dmg):
        # 这里的dmg是造成伤害后的最终数值，可以直接使用
        if actual_dmg <= wearer.base_attack:
            self._count += 1

class WoodenSword_Star(Equipment):
    """木剑⭐：武器插槽；+6 攻击；现在每攻击 2 次，第 3 次普攻造成双倍伤害。"""
    slot = "weapon"
    display_name = "木剑⭐"
    
    def __init__(self):
        self.type = "weapon"
        self.rarity = "uncommon" # 升级后，品质也提升了
        self.atk_bonus = 6       # 基础攻击更高
        self._count = 0

    def before_attack(self, wearer, target, packet: DamagePacket):
        # 效果增强：从3次触发改为2次触发
        if self._count >= 2:
            packet.amount *= 2
            self._count = 0

    def after_attack(self, wearer, target, actual_dmg):
        # 这里的dmg是造成伤害后的最终数值，可以直接使用
        self._count += 1

class WoodenArmor(Equipment):
    """木铠甲：护甲插槽；+2 防御；30% 概率额外减免 30% 点物理伤害"""
    slot = "armor"
    display_name    = "木铠甲"

    def __init__(self):
        self.type = "armor"
        self.rarity = "common"
        self.def_bonus = 2

    # on_battle_start 已被移除，因为防御是永久属性

    def before_take_damage(self, wearer, packet: DamagePacket):
        # 效果现在只对物理伤害生效
        if packet.damage_type == DamageType.PHYSICAL and random.random() < 0.3:
            packet.amount = max(0, packet.amount * 0.7)

class WoodenArmor_Star(Equipment):
    """木铠甲⭐：护甲插槽；+5 防御；50% 概率额外减免 50% 点物理伤害"""
    slot = "armor"
    display_name = "木铠甲⭐"

    def __init__(self):
        self.type = "armor"
        self.rarity = "uncommon"
        self.def_bonus = 5 # 基础防御更高

    def before_take_damage(self, wearer, packet: DamagePacket):
        # 效果现在只对物理伤害生效
        if packet.damage_type == DamageType.PHYSICAL and random.random() < 0.5:
            packet.amount = max(0, packet.amount * 0.5)

class IronSword(Equipment):
    """铁剑：武器插槽；+5 攻击；基础 +5% 暴击率；未暴击时，下次普攻暴击率 +5%，最多 8 层；暴击后清除"""
    slot = "weapon"
    display_name = "铁剑"
    def __init__(self):
        self.rarity = "common"
        self.type = "weapon"
        self.atk_bonus = 5
        self.base_crit_bonus = 0.05
        self.max_stacks = 8
        self._stacks = 0
    def on_battle_start(self, wearer):
        # 攻击和暴击都是永久属性
        # 但暴击率需要在战斗中动态变化，所以我们需要在战前设置初始值
        wearer.crit_chance += self.base_crit_bonus
    def on_critical(self, wearer, target, dmg):
        wearer.crit_chance -= self._stacks * self.base_crit_bonus
        self._stacks = 0
    def on_non_critical(self, wearer, target, dmg):
        if self._stacks < self.max_stacks:
            self._stacks += 1
            wearer.crit_chance += self.base_crit_bonus

class IronRing(Equipment):
    """铁戒指：饰品槽；+5% 暴击；+10% 爆伤；赠送两层“刚毅”Buff"""
    slot = "accessory"
    display_name = "铁戒指"
    def __init__(self):
        self.rarity = "common"
        self.type = "misc" # 添加类型
        self.crit_bonus = 0.05
        self.crit_dmg_bonus = 0.10
    def on_battle_start(self, wearer):
        # 暴击和爆伤是永久属性
        # 只保留战斗开始时的效果
        wearer.add_status(Buffs.SteelHeartBuff(uses=2))

class IronHammer(Equipment):
    """铁锤：武器槽；+8 攻击；+5% 暴击；20% 概率眩晕敌人 2 秒"""
    slot = "weapon"
    display_name = "铁锤"
    def __init__(self):
        self.rarity = "uncommon"
        self.type = "weapon"
        self.atk_bonus = 8
        self.crit_chance_bonus = 0.05
        self.stun_chance = 0.20
        self.stun_duration = 2.0
    def on_battle_start(self, wearer):
        # 攻击和暴击是永久属性
        pass
    def after_attack(self, wearer, target, dmg):
        if random.random() < self.stun_chance:
            target.add_status(Buffs.StunDebuff(self.stun_duration), source=wearer)

class NaturalNecklace(Equipment):
    """自然项链：饰品槽；最大 HP +20；提供 2 层“再生”Buff"""
    slot = "accessory"
    display_name = "自然项链"
    def __init__(self):
        self.rarity = "uncommon"
        self.type = "misc" # 添加类型
        self.hp_bonus = 20
    def on_battle_start(self, wearer):
        # HP是永久属性
        # 只保留战斗开始时的效果
        wearer.add_status(Buffs.RegenerationBuff(stacks=2))

class ThornsRing(Equipment):
    """荆棘环：饰品槽；+0.2 攻速；+10% 爆伤；战斗开始时提供 3 层 荆棘"""
    slot = "accessory"
    display_name = "荆棘环"
    def __init__(self):
        self.rarity = "uncommon"
        self.type = "misc" # 添加类型
        self.atk_speed_bonus = 0.2
        self.crit_damage_bonus = 0.10
        self.thorns_stacks = 3
    def on_battle_start(self, wearer):
        # 攻速和爆伤是永久属性
        # 只保留战斗开始时的效果
        wearer.add_status(Buffs.ThornsBuff(stacks=self.thorns_stacks))

class PhoenixCrown(Equipment):
    """紫金冠：头盔槽；无基础属性；附加“不灭”效果"""
    slot = "helmet"
    display_name = "紫金冠"
    def __init__(self):
        self.rarity = "legendary"
        self.type = "armor" # 添加类型
    def on_battle_start(self, wearer):
        # 这个设计是完美的，只添加Buff
        wearer.add_buff(Buffs.PhoenixCrownStage1Buff())

class SlimeSword(Equipment):
    """史莱姆之剑：武器；+6 攻击；攻击时有15%概率使敌人中毒1层"""
    slot = "weapon"
    display_name = "史莱姆之剑"
    def __init__(self):
        self.rarity = "common"
        self.type = "weapon"
        self.atk_bonus = 6
        self.poison_chance = 0.15
    def on_battle_start(self, wearer):
        # 攻击是永久属性
        pass
    def after_attack(self, wearer, target, dmg):
        if random.random() < self.poison_chance:
            target.add_debuff(Buffs.PoisonDebuff(stacks=1), source=wearer)


class VampiresFang(Equipment):
    """吸血鬼之牙：饰品槽；攻击造成10%生命偷取，生命低于50%时效果翻倍。"""
    slot = "accessory"
    display_name = "吸血鬼之牙"
    def __init__(self):
        self.rarity, self.type = "rare", "misc"
        self.lifesteal_ratio = 0.10

    def after_attack(self, wearer, target, actual_dmg):
        ratio = self.lifesteal_ratio
        if wearer.hp / wearer.max_hp < 0.5:
            ratio *= 2
        
        healed_amount = actual_dmg * ratio
        if healed_amount > 0:
            # ### 核心修复：将被攻击的 target 作为 combat_target 传入 ###
            wearer.heal(healed_amount, combat_target=target)

class HourglassOfTime(Equipment):
    """时光沙漏：副手槽；暴击时有40%几率立即重置攻击冷却。"""
    slot = "offhand"
    display_name = "时光沙漏"
    def __init__(self):
        self.rarity, self.type = "uncommon", "armor" # 副手算防具
        self.proc_chance = 0.4

    def on_critical(self, wearer, target, dmg):
        if random.random() < self.proc_chance:
            print("[时光沙漏] 效果触发！")
            # 直接将攻击冷却充满
            wearer._cd = wearer.attack_interval

class Stormcaller(Equipment):
    """风暴召唤者：武器槽；+15攻击；每攻击4次，为敌人附加一层【风暴】印记。"""
    slot = "weapon"
    display_name = "风暴召唤者"
    def __init__(self):
        self.rarity, self.type = "legendary", "weapon"
        self.atk_bonus = 15
        self._attack_count = 0

    def after_attack(self, wearer, target, dmg):
        self._attack_count += 1
        if self._attack_count >= 4:
            self._attack_count = 0
            print("[风暴召唤者] 附加了风暴印记！")
            target.add_debuff(Buffs.StormDebuff(), source=wearer)
# --- 白色 (Common) 品质新装备 ---

class LeatherGloves(Equipment):
    """皮手套：副手槽；+0.3 攻击速度。"""
    slot = "offhand"
    display_name = "皮手套"
    def __init__(self):
        self.rarity, self.type = "common", "armor"
        self.atk_speed_bonus = 0.3

class RustyHelmet(Equipment):
    """生锈的头盔：头盔槽；+30 最大生命值。"""
    slot = "helmet"
    display_name = "生锈的头盔"
    def __init__(self):
        self.rarity, self.type = "common", "armor"
        self.hp_bonus = 30

# --- 绿色 (Uncommon) 品质新装备 ---

class BarbedAxe(Equipment):
    """倒钩斧：武器槽；+5攻击；攻击时有30%几率使敌人【流血】5秒。"""
    slot = "weapon"
    display_name = "倒钩斧"
    def __init__(self):
        self.rarity, self.type = "uncommon", "weapon"
        self.atk_bonus = 5
        self.bleed_chance = 0.3
    def after_attack(self, wearer, target, dmg):
        if random.random() < self.bleed_chance:
            target.add_debuff(Buffs.BleedDebuff(stacks=1), source=wearer)

# 在 Equips.py 文件中，找到并替换 TowerShield 类

class TowerShield(Equipment):
    """塔盾：副手槽；+3防御；战斗开始时，获得3层【格挡】。"""
    slot = "offhand"
    display_name = "塔盾"
    def __init__(self):
        self.rarity, self.type = "uncommon", "armor"
        self.def_bonus = 3
        self.block_stacks = 3

    def on_battle_start(self, wearer):
        wearer.add_buff(Buffs.BlockBuff(stacks=self.block_stacks))
    

# --- 蓝色 (Rare) 品质新装备 ---


class AdventurersPouch(Equipment):
    """冒险家的钱袋：饰品槽；每拥有20金币，就为你提供+1攻击力。（战斗开始时结算）"""
    slot = "accessory"
    display_name = "冒险家的钱袋"
    def __init__(self):
        self.rarity, self.type = "rare", "misc"
        self.atk_bonus = 0 # 初始攻击力加成为0

    def on_battle_start(self, wearer):
        # 在战斗开始时，只计算应该加多少攻击力，并存到自己的属性里
        gold = getattr(wearer, 'gold', 0)
        self.atk_bonus = gold // 20
        if self.atk_bonus > 0:
            print(f"[冒险家的钱袋] 你获得了 {self.atk_bonus} 点额外攻击力！")
            # 重新计算一次总属性，让这个新的atk_bonus生效
            wearer.recalculate_stats()

class ShadowCloak(Equipment):
    """暗影斗篷：护甲槽；+5防御；受到暴击伤害时，有30%概率免疫该次伤害。"""
    slot = "armor"
    display_name = "暗影斗篷"
    def __init__(self):
        self.rarity, self.type = "rare", "armor"
        self.def_bonus = 5
        self.crit_immunity_chance = 0.3
    def before_take_damage(self, wearer, packet: DamagePacket):
        if packet.damage_type == DamageType.PHYSICAL and packet.is_critical:
            if random.random() < self.crit_immunity_chance:
                print("[暗影斗篷] 免疫了暴击伤害！")
                packet.amount = 0

# 在 Equips.py 文件末尾添加

# --- “烙印”体系示例 ---

class SunScorchedBlade(Equipment):
    """日灼之刃 [武器-稀有]：攻击速度+0.5；命中时附加一层【日之烙印】。"""
    slot, display_name = "weapon", "日灼之刃"
    def __init__(self):
        self.rarity, self.type = "rare", "weapon"
        self.atk_speed_bonus = 0.5
    def after_attack(self, wearer, target, actual_dmg):
        target.add_debuff(Buffs.SunstoneBrandDebuff(stacks=1), source=wearer)

class Avalanche(Equipment):
    """山崩 [武器-史诗]：攻击力+20；暴击时引爆目标所有【日之烙印】，每层造成20额外真实伤害。"""
    slot, display_name = "weapon", "山崩"
    def __init__(self):
        self.rarity, self.type = "epic", "weapon"
        self.atk_bonus = 20
    def on_critical(self, wearer, target, actual_dmg):
        # 寻找目标身上的烙印
        brand_debuff = next((b for b in target.buffs if isinstance(b, Buffs.SunstoneBrandDebuff)), None)
        if brand_debuff:
            stacks = brand_debuff.stacks
            print(f"[山崩] 引爆了 {stacks} 层烙印！")
            # 造成额外伤害
            extra_dmg = stacks * 20
            packet = DamagePacket(amount=extra_dmg, damage_type=DamageType.TRUE, source=wearer)
            target.take_damage(packet)
            # 移除烙印
            target.remove_buff(brand_debuff)

# --- “龙魂”体系示例 ---

class DragonBloodChalice(Equipment):
    """龙血酒杯 [饰品-史诗]：每秒失去5点生命，但获得1层【龙魂】。"""
    slot, display_name = "accessory", "龙血酒杯"
    def __init__(self):
        self.rarity, self.type = "epic", "misc"
        self._timer = 0.0
    def on_battle_start(self, wearer):
        self._timer = 0.0 # 重置计时器
    def on_tick(self, wearer, dt): # 需要在 Character.update 中调用 on_tick
        self._timer += dt
        if self._timer >= 1.0:
            self._timer -= 1.0
            # 扣血
            packet = DamagePacket(amount=5, damage_type=DamageType.TRUE, is_sourceless=True)
            wearer.take_damage(packet)
            # 获得龙魂
            wearer.add_buff(Buffs.DragonSoulBuff(stacks=1))

class DragonscaleWard(Equipment):
    """龙鳞盾 [副手-稀有]：战斗开始时，消耗所有【龙魂】，每层提供15点护盾。"""
    slot, display_name = "offhand", "龙鳞盾"
    def __init__(self):
        self.rarity, self.type = "rare", "armor"
    def on_battle_start(self, wearer):
        soul_buff = next((b for b in wearer.buffs if isinstance(b, Buffs.DragonSoulBuff)), None)
        if soul_buff:
            stacks = soul_buff.stacks
            shield_gain = stacks * 15
            print(f"[龙鳞盾] 消耗了 {stacks} 层龙魂，获得了 {shield_gain} 点护盾！")
            wearer.shield += shield_gain
            wearer.remove_buff(soul_buff)

# 文件: Equips.py (追加到文件末尾，但在UPGRADE_MAP之前)

class Plaguebringer(Equipment):
    """瘟疫使者: 武器; 攻击时引爆目标身上的所有【毒】层数，每层造成1点额外毒性伤害。"""
    slot, display_name = "weapon", "瘟疫使者"
    def __init__(self):
        self.rarity, self.type = "rare", "weapon"
        self.atk_bonus = 8

    def after_attack(self, wearer, target, actual_dmg):
        poison_debuff = next((b for b in target.buffs if isinstance(b, Buffs.PoisonDebuff)), None)
        if poison_debuff:
            stacks = poison_debuff.stacks
            print(f"[瘟疫使者] 引爆了 {stacks} 层毒！")
            # 造成额外伤害
            packet = DamagePacket(amount=stacks, damage_type=DamageType.POISON, source=wearer)
            target.take_damage(packet)
            # 移除毒
            target.remove_buff(poison_debuff)

class ArmorSunderer(Equipment):
    """碎甲战斧: 武器; 攻击时为目标叠加1层【破甲】。当目标防御为0时，你的攻击造成双倍伤害。"""
    slot, display_name = "weapon", "碎甲战斧"
    def __init__(self):
        self.rarity, self.type = "epic", "weapon"
        self.atk_bonus = 15

    def before_attack(self, wearer, target, packet: DamagePacket):
        if target.defense <= 0:
            packet.amount *= 2

    def after_attack(self, wearer, target, actual_dmg):
        target.add_debuff(Buffs.SunderDebuff(stacks=1), source=wearer)

class Windshear(Equipment):
    """风切: 武器; 攻击有50%概率分裂成两次50%伤害的攻击，分裂的攻击有减半的概率继续分裂。"""
    slot, display_name = "weapon", "风切"
    def __init__(self):
        self.rarity, self.type = "legendary", "weapon"
        self.atk_bonus = 10

    def after_attack(self, wearer, target, actual_dmg):
        split_chance = 0.5
        while random.random() < split_chance:
            print("[风切] 攻击分裂！")
            # 造成一次50%伤害的额外攻击
            packet = DamagePacket(amount=wearer.attack * 0.5, damage_type=DamageType.PHYSICAL, source=wearer)
            target.take_damage(packet)
            split_chance /= 2 # 概率减半

class RingOfFlourishing(Equipment):
    """繁盛指环: 饰品; 当你获得任意Buff时，有30%概率额外获得一层【生机绽放】。"""
    slot, display_name = "accessory", "繁盛指环"
    def __init__(self):
        self.rarity, self.type = "rare", "misc"

    def on_buff_applied(self, wearer, buff_applied):
        """这是一个新的自定义钩子，会在Character.add_status中被调用"""
        
        if not buff_applied.is_debuff and not isinstance(buff_applied, Buffs.VitalityBloomBuff) and random.random() < 0.3:
            print("[繁盛指环] 效果触发！")
            wearer.add_buff(Buffs.VitalityBloomBuff(stacks=1))


class RuneBlade(Equipment):
    """符文之刃 [武器-稀有]
    +12 攻击力。
    你的所有普通攻击都会造成魔法伤害，伤害值取决于你的攻击力。
    """
    slot = "weapon"
    display_name = "符文之刃"

    def __init__(self):
        self.rarity = "rare"  # 稀有品质
        self.type = "weapon"
        self.atk_bonus = 12

    def before_attack(self, wearer, target, packet: DamagePacket):
        """
        在攻击伤害包（packet）被最终计算前进行修改。
        这个钩子函数在 Character.try_attack 中被调用。
        """
        # ### 核心效果：将伤害类型从默认的物理伤害改为魔法伤害 ###
        packet.damage_type = DamageType.MAGIC


UPGRADE_MAP = {
    WoodenSword: WoodenSword_Star,
    WoodenArmor: WoodenArmor_Star,
    # 在这里继续为你其他的装备添加升级配方...
    # 例如:
    # IronSword: IronSword_Star, 
}


================================================================================
### 文件路径: events.json
================================================================================

{
    "fountain_of_power": {
        "title": "力量源泉",
        "description": "你发现一个散发着微光的源泉。泉水似乎蕴含着奇特的力量，你可以从中感受到生命与毁灭的气息。",
        "choices": [
            {
                "text": "喝一口 (恢复全部生命)",
                "outcomes": [
                    { "type": "HEAL", "amount": "full", "result_text": "泉水让你精神焕发，所有伤痛都消失了！" }
                ]
            },
            {
                "text": "将武器浸入 (风险与机遇)",
                "outcomes": [
                    { "type": "WEAPON_UPGRADE", "chance": 0.6, "result_text": "你的武器吸收了源泉的力量，变得更加锋利了！(攻击力+5)" },
                    { "type": "WEAPON_CURSE", "chance": 0.4, "result_text": "武器无法承受这股力量，反而变得迟钝了...(攻击力-3)" }
                ]
            }
        ]
    },
    "wandering_spirit": {
        "title": "迷途的古代灵魂",
        "description": "一个半透明的灵魂在你面前徘徊，它似乎在寻求帮助，又像是在守护着什么。",
        "choices": [
            {
                "text": "帮助它安息 (获得天赋)",
                "outcomes": [
                    { "type": "GAIN_TALENT", "talent_class_name": "HeartOfHealingTalent", "result_text": "灵魂感激地消散了，你从中领悟了「治愈之心」！" }
                ]
            },
            {
                "text": "攻击它 (触发战斗)",
                "outcomes": [
                    { "type": "TRIGGER_COMBAT", "enemy_id": "goblin_captain", "result_text": "灵魂发出了尖啸，化作一个强大的敌人向你袭来！" }
                ]
            }
        ]
    }
}


================================================================================
### 文件路径: game.py
================================================================================

# game.py (已更新)
import pygame
import pickle
import os
import time
import json
import sys
from settings import *
# <-- 导入 ui 模块，而不仅仅是 init_fonts
import ui
from Character import Character
import Equips
import Talents

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("我的游戏")
        self.clock = pygame.time.Clock()
        self.running = True
        self.fonts = ui.init_fonts()
        self.state_stack = []

        # <-- 核心改动：在游戏启动时加载所有Buff图标资源 -->
        #ui.load_buff_icons()

        self.player = None
        self.current_stage = "1"
        self.loaded_dialogue_index = 0

        self.story_data = self._load_json("story.json")
        self.enemy_data = self._load_json("enemies.json")
        self.loot_data = self._load_json("loot_tables.json")
        self.event_data = self._load_json("events.json")

        self.dungeon_data = {}
        dungeon_folder = 'dungeons'
        for filename in os.listdir(dungeon_folder):
            if filename.endswith('.json'):
                dungeon_id = filename.split('.')[0]
                self.dungeon_data[dungeon_id] = self._load_json(os.path.join(dungeon_folder, filename))

    def run(self):
        from states.title import TitleScreen
        self.state_stack.append(TitleScreen(self))

        while self.running and self.state_stack:
            self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(60)
        
        pygame.quit()
        sys.exit()

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            if self.state_stack:
                self.state_stack[-1].handle_event(event)

    def update(self):
        if self.state_stack:
            self.state_stack[-1].update()

    def draw(self):
        # --- 全新的分层绘制逻辑 ---
        if not self.state_stack:
            pygame.display.flip()
            return

        # 1. 找到最底部的非弹窗界面
        base_state_index = -1
        for i in range(len(self.state_stack) - 1, -1, -1):
            if not getattr(self.state_stack[i], 'is_overlay', False):
                base_state_index = i
                break
        
        # 2. 绘制所有底层界面 (通常只有一个)
        if base_state_index != -1:
            for i in range(base_state_index + 1):
                 self.state_stack[i].draw(self.screen)

        # 3. 逐个绘制所有弹窗界面
        for i in range(base_state_index + 1, len(self.state_stack)):
            self.state_stack[i].draw(self.screen)
        
        pygame.display.flip()

    def _load_json(self, filename):
        try:
            with open(filename, 'r', encoding='utf-8') as f: return json.load(f)
        except Exception as e:
            print(f"ERROR: Could not load {filename}: {e}")
            return None

    def get_save_filename(self, slot_number):
        return f"save_slot_{slot_number}.dat"

    def peek_save_slot(self, slot_number):
        filename = self.get_save_filename(slot_number)
        if not os.path.exists(filename): return None
        try:
            with open(filename, "rb") as f: return pickle.load(f)
        except Exception: return None

    def save_to_slot(self, slot_number):
        filename = self.get_save_filename(slot_number)
        try:
            dialogue_index = 0
            from states.story import StoryScreen
            for state in reversed(self.state_stack):
                if isinstance(state, StoryScreen):
                    dialogue_index = state.dialogue_index; break
            data_to_save = {
                "player": self.player, "current_stage": self.current_stage,
                "dialogue_index": dialogue_index, "timestamp": time.time()
            }
            with open(filename, "wb") as f: pickle.dump(data_to_save, f)
            print(f"Game saved to slot {slot_number}")
            return f"成功保存到槽位 {slot_number}！"
        except Exception as e:
            print(f"Save failed: {e}"); return "存档失败！"

    def load_from_slot(self, slot_number):
        data = self.peek_save_slot(slot_number)
        if data:
            self.player = data["player"]
            self.current_stage = data["current_stage"]
            self.loaded_dialogue_index = data.get("dialogue_index", 0)
            return True
        return False
   
    # 文件: game.py (替换这个函数)

    def start_new_game(self):
        player_eq = [Equips.WoodenSword(), Equips.WoodenArmor(), Equips.NaturalNecklace(), Equips.IronRing()]
        player_talents = [
            Talents.HeartOfHealingTalent(),
            Talents.DualWieldTalent(),
            Talents.Adventurer()
        ]
        
        # --- 核心修改：使用从 settings.py 导入的 PLAYER_BASE_STATS ---
        # **PLAYER_BASE_STATS 是一种简便写法，它会自动把字典里的所有键值对作为参数传入
        self.player = Character(
            "玩家", 
            **PLAYER_BASE_STATS, # <-- 使用我们定义的标准属性
            equipment=player_eq,
            talents=player_talents
        )
        self.current_stage = "1"
        self.loaded_dialogue_index = 0


================================================================================
### 文件路径: loot_tables.json
================================================================================

{
    "slime": [
        {
            "item_class_name": "SlimeSword",
            "chance": 0.99
        }
    ],
    "goblin": [
        {
            "item_class_name": "IronSword",
            "chance": 0.2
        },
        {
            "item_class_name": "WoodenShield",
            "chance": 0.2
        }
    ],
    "goblin_captain": [
        { "item_class_name": "IronHammer", "chance": 0.25 },
        { "item_class_name": "IronRing", "chance": 0.15 }
    ]
}


================================================================================
### 文件路径: main.py
================================================================================

# main.py
from game import Game
import Equips
print(f"DEBUG: 正在从这个路径加载 Equips.py -> {Equips.__file__}")


if __name__ == "__main__":
    g = Game()
    g.run()


================================================================================
### 文件路径: monster_sprite.py
================================================================================

# monster_sprite.py (已更新)
import pygame
from settings import *

class Monster(pygame.sprite.Sprite):
    def __init__(self, monster_data): # <-- 改为接收整个 data 字典
        super().__init__()
        self.enemy_id = monster_data['id']
        self.uid = monster_data['uid'] # <-- 新增：记录自己的 uid
        
        self.image = pygame.Surface([30, 30])
        color = (255, 0, 0)
        if self.enemy_id == "slime": color = (100, 200, 100)
        elif self.enemy_id == "goblin": color = (200, 150, 50)
        elif self.enemy_id == "ruin_golem": # Boss用大一点的方块和不同颜色
            self.image = pygame.Surface([60, 60])
            color = (150, 50, 200)
        
        self.image.fill(color)
        self.rect = self.image.get_rect(center=monster_data['pos'])

    def update(self):
        pass


================================================================================
### 文件路径: player_sprite.py
================================================================================

# player_sprite.py
import pygame
from settings import *

class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.image = pygame.Surface([40, 40])
        self.image.fill(TEXT_COLOR) # 暂时用一个白色方块代表玩家
        self.rect = self.image.get_rect(center=(x, y))
        self.speed = 5

    def update(self):
        """根据按键更新玩家位置"""
        keys = pygame.key.get_pressed()
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.rect.x -= self.speed
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.rect.x += self.speed
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.rect.y -= self.speed
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.rect.y += self.speed

        # 简单的边界限制，防止跑出屏幕
        if self.rect.left < 0: self.rect.left = 0
        if self.rect.right > SCREEN_WIDTH: self.rect.right = SCREEN_WIDTH
        if self.rect.top < 0: self.rect.top = 0
        if self.rect.bottom > SCREEN_HEIGHT: self.rect.bottom = SCREEN_HEIGHT


================================================================================
### 文件路径: portal_sprite.py
================================================================================

# 文件: portal_sprite.py (新文件)

import pygame
from settings import *

class PortalSprite(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        
        # 创建一个可视化的传送门外观
        self.image = pygame.Surface([120, 120], pygame.SRCALPHA)
        # 画一个紫色的外圈
        pygame.draw.circle(self.image, (160, 32, 240), (60, 60), 60)
        # 画一个深紫色的内圈
        pygame.draw.circle(self.image, (50, 10, 80), (60, 60), 50)
        self.rect = self.image.get_rect(center=(x, y))


================================================================================
### 文件路径: settings.py
================================================================================

# settings.py
import pygame
SCREEN_WIDTH = 1280
SCREEN_HEIGHT = 720
BG_COLOR = (10, 20, 30)
TEXT_COLOR = (230, 230, 230)
HOVER_COLOR = (200, 220, 255) # 鼠标悬停颜色
PANEL_BG_COLOR = (20, 35, 50)
PANEL_BORDER_COLOR = (100, 180, 255)
HP_BAR_GREEN = (0, 200, 0)
SHIELD_BAR_GREY = (150, 150, 150)
FONT_SIZE_NORMAL = 28
FONT_SIZE_SMALL = 22
FONT_SIZE_LARGE = 48
FONT_NAME_CN = 'Microsoft YaHei'
FONT_NAME_EN = 'Consolas'

# --- 新增颜色和尺寸 ---
XP_BAR_COLOR = (150, 100, 255)      # 经验条颜色
LOG_TEXT_COLOR = (200, 200, 200)    # 战斗日志文字颜色
LOG_BG_COLOR = (30, 45, 60, 200)    # 战斗日志背景色 (带透明度)
BUTTON_CLICK_COLOR = (150, 200, 255) # 按钮点击颜色

# Buff/Debuff 图标尺寸
BUFF_ICON_SIZE = (32, 32)

# --- 布局位置 ---
# (这些是建议值，你可以随时调整)
PLAYER_PANEL_RECT = pygame.Rect(50, 450, 500, 250)
ENEMY_PANEL_RECT = pygame.Rect(SCREEN_WIDTH - 550, 50, 500, 250)
BATTLE_LOG_RECT = pygame.Rect(50, 50, SCREEN_WIDTH - 650, 350)
PLAYER_ACTION_PANEL_RECT = pygame.Rect(PLAYER_PANEL_RECT.right + 20, PLAYER_PANEL_RECT.top, 200, PLAYER_PANEL_RECT.height)


# --- 物品品质颜色 ---
RARITY_COLORS = {
    "common":    (255, 255, 255),  # 白色
    "uncommon":  (30, 255, 30),    # 绿色
    "rare":      (0, 150, 255),   # 蓝色
    "epic":      (180, 50, 255),   # 紫色
    "legendary": (255, 150, 0),    # 橙色
    "mythic":    (255, 50, 50),    # 红色
}

# --- 玩家角色配置 ---
PLAYER_BASE_STATS = {
    "hp": 100,
    "defense": 3,
    "magic_resist": 3,
    "attack": 10,
    "attack_speed": 1.2,
}

# 文件: settings.py (在文件末尾追加)

# --- 新增：伤害类型颜色 ---
DAMAGE_TYPE_COLORS = {
    "PHYSICAL":      (220, 220, 220), # 物理伤害 - 亮灰色
    "MAGIC":         (138, 43, 226),  # 魔法伤害 - 紫罗兰色
    "TRUE":          (255, 255, 255), # 真实伤害 - 纯白色
    "POISON":        (0, 255, 0),     # 剧毒伤害 - 绿色
    "DRAGON_SOURCE": (255, 165, 0),   # 龙源伤害 - 橙色
    "HEAL":          (144, 238, 144), # 治疗效果 - 亮绿色
}

# --- 新增：伤害类型中文名 ---
DAMAGE_TYPE_NAMES_CN = {
    "PHYSICAL":      "物理伤害",
    "MAGIC":         "魔法伤害",
    "TRUE":          "真实伤害",
    "POISON":        "毒素伤害",
    "DRAGON_SOURCE": "龙源伤害",
}
# 文件: settings.py (追加)
CRIT_COLOR = (255, 215, 0)          # 暴击文字颜色 - 金色



================================================================================
### 文件路径: story.json
================================================================================

{
    "1": {
        "type": "story",
        "text": [
            { "speaker": "旁白", "line": "你睁开眼睛，发现自己身处一片宁静的森林之中。" },
            { "speaker": "旁白", "line": "阳光透过树叶的缝隙洒下，空气中弥漫着青草的气息。" },
            { "speaker": "旁白", "line": "突然，一阵“咕叽咕叽”的声音传来，一只果冻状的生物出现在你面前！" }
        ],
        "next": "2"
    },
    "2": {
        "type": "combat",
        "enemy_id": "slime",
        "next_win": "3",
        "next_lose": "game_over"
    },
    "3": {
        "type": "story",
        "text": [
            { "speaker": "旁白", "line": "你轻松地战胜了史莱姆。" },
            { "speaker": "你", "line": "看来这里的生物并没有想象中那么强大。" },
            { "speaker": "你", "line": "我决定继续深入森林，探索这个未知的世界..." },
            { "speaker": "旁白", "line": "(未完待续)" }
        ],
        "next": "4"
    },
    "4": {
        "type": "story",
        "text": [
            { "speaker": "猎人", "line": "你的第一个任务，就是独自进入那座『日之石遗迹』..." },
            { "speaker": "猎人", "line": "抵达最深处的圣堂，并带回试炼完成的证明。准备好了吗？" },
            { 
                "speaker": "玩家", 
                "line": "我准备好了。",
                "action": "start_trial"
            }
        ],
        "next": "4" 
    },
    "trial_combat": {
        "type": "combat",
        "enemy_id": "slime", 
        "next_win": "map_return", 
        "next_lose": "title"
    },
    "5": {
        "type": "story",
        "text": [
            { "speaker": "旁白", "line": "……" },
            { "speaker": "旁白", "line": "………………" },
            { "speaker": "你", "line": "……唔……好困…………" },
            { "speaker": "旁白", "line": "我的意識就像被黏在天花板上的口香糖，掙扎著想往下掉，卻怎麼也擺脫不了那股黏膩的睡意。" },
            { "speaker": "旁白", "line": "耳邊是「嘎吱、嘎吱」的木頭呻吟聲，那老舊的木板好像隨時都會散架一樣，還有規律得讓人想打瞌睡的海浪拍打船身的「噗通、噗通」悶響。" },
            { "speaker": "旁白", "line": "鼻腔裡充斥著一股鹹澀的海風，混合著老木頭和一點點說不清道不明的魚腥味，嗯，這就是「海上男兒」的浪漫吧，大概。" },
            { "speaker": "旁白", "line": "眼皮就像灌了鉛一樣沉重，比我期末考試前熬夜看漫畫的眼睛還重。" },
            { "speaker": "你", "line": "「再睡五分鐘，就五分鐘……」我心裡嘀咕著，翻了個身。" },
            { "speaker": "你", "line": "……" },
            { "speaker": "你", "line": "等等！現在是什麼時候了？！" }
        ],
        "next": "quit"
    }
}


================================================================================
### 文件路径: Talents.py
================================================================================

import Buffs
from abc import ABC
import collections
from collections import defaultdict
from rich.console import Console, Group
from rich.live import Live
from rich.table import Table
from rich.panel import Panel
from rich.text import Text
import time
import random
from rich.text import Text
from rich.progress import BarColumn  # 可选：也可以直接用 Text
import math
from collections import Counter
#import pygame
import sys
from rich.console import Console

from damage import DamagePacket, DamageType
from battle_logger import battle_logger
from settings import TEXT_COLOR, DAMAGE_TYPE_COLORS
from ui import format_damage_log

class Talent:
    """天赋基类，之后可扩展更多钩子"""
    display_name = None
    def on_init(self, wearer):
        """角色创建/战前初始化时触发，用于修改槽位之类的属性"""
        pass
    def on_attack(self, wearer, target, dmg):
        """攻击后触发"""
        pass
    def on_debuff_applied(self, wearer, buff):
        """当一个 Debuff 被加到 wearer 上时触发"""
        pass
        
class PoisonousTalent(Talent):
    display_name = "毒物"
    def __init__(self, chance: float = 0.5):
        self.chance = chance

    def on_attack(self, wearer, target, dmg):
        if random.random() < self.chance:
            target.add_debuff(Buffs.PoisonDebuff(stacks=1), source=wearer)

class DualWieldTalent(Talent):
    """二刀流：武器槽提升到 2"""
    display_name = "二刀流"
    def on_init(self, wearer):
        cur = wearer.SLOT_CAPACITY.get("weapon", 1)
        if cur < 2:
            wearer.SLOT_CAPACITY["weapon"] = 2

class TripleWieldTalent(Talent):
    """三刀流：武器槽提升到 3"""
    display_name = "三刀流"
    def on_init(self, wearer):
        cur = wearer.SLOT_CAPACITY.get("weapon", 1)
        if cur < 3:
            wearer.SLOT_CAPACITY["weapon"] = 3

class ThousandWorldTalent(Talent):
    """三千世界：普攻时有 chance 概率立即额外连续普攻 2 次"""
    display_name = "三千世界"

    def __init__(self, chance: float = 0.33):
        self.chance = chance

    # 文件: Talents.py (在 ThousandWorldTalent 类中，替换 on_attack 方法)

    def on_attack(self, wearer, target, dmg):
        """
        额外攻击现在会自己处理日志，所以这里不再需要返回任何东西。
        """
        if random.random() < self.chance:
            # 额外出手两次
            for _ in range(2):
                wearer.perform_extra_attack(target)
        # 不再需要返回 extra_texts

class HeartOfHealingTalent(Talent):
    """治愈之心：被施加可驱散的 Debuff 时，30% 概率驱散此层，并获得 1 层 再生"""
    display_name = "治愈之心"

    def __init__(self, chance: float = 0.3):
        self.chance = chance

    def on_debuff_applied(self, wearer, buff):
        if random.random() < self.chance:
            # 驱散一层
            if hasattr(buff, "stacks"):
                buff.stacks -= 1
                if buff.stacks <= 0:
                    wearer.remove_buff(buff)
            else:
                wearer.remove_buff(buff)
            # 获得 1 层“再生”
            wearer.add_buff(Buffs.RegenerationBuff(stacks=1))

class BambooLeafTalent(Talent):
    display_name = "竹叶青"

    def __init__(self, chance: float = 1.0):
        self.chance = chance
        self._bamboo_atk_bonus = 0  # 上一次总加成
        self._bamboo_spd_bonus = 0

    def on_inflict_debuff(self, wearer, target, buff, added_stacks):
        # 只有是 PoisonDebuff 且概率命中才触发
        if not isinstance(buff, Buffs.PoisonDebuff) or random.random() >= self.chance:
            return

        # ① 给自己加这次相同的层数
        own = next((b for b in wearer.buffs if isinstance(b, Buffs.PoisonDebuff)), None)
        if own:
            own.stacks = min(own.stacks + added_stacks, own.max_stacks)
        else:
            wearer.add_buff(Buffs.PoisonDebuff(stacks=added_stacks))

        # ② 统计当前毒总层数
        total_stacks = next((b.stacks for b in wearer.buffs if isinstance(b, Buffs.PoisonDebuff)), 0)

        # ③ 撤销旧加成
        wearer.attack -= self._bamboo_atk_bonus
        current_as = 6.0 / wearer.attack_interval
        base_as = current_as - self._bamboo_spd_bonus

        # ④ 重新计算加成（基于总毒层数）
        atk_bonus = total_stacks * 1
        spd_bonus = total_stacks * 0.1

        wearer.attack += atk_bonus
        wearer.attack_interval = 6.0 / (base_as + spd_bonus)

        # ⑤ 记录新的加成值
        self._bamboo_atk_bonus = atk_bonus
        self._bamboo_spd_bonus = spd_bonus

class GlassCannon(Talent):
    """【天赋】玻璃大炮：造成的伤害提升50%，受到的伤害也提升30%。"""
    display_name = "玻璃大炮"
    def on_init(self, wearer):
        wearer.attack *= 1.5
        wearer.damage_resistance -= 0.3

class Giant(Talent):
    """【天赋】巨人：最大生命值提升50%，但攻击速度降低20%。"""
    display_name = "巨人"
    def on_init(self, wearer):
        wearer.max_hp *= 1.5
        wearer.hp = wearer.max_hp
        wearer.attack_speed *= 0.8
        wearer.attack_interval = 6.0 / wearer.attack_speed


class Executioner(Talent):
    """【天赋】处决者：立即斩杀生命值低于20%的敌人。"""
    display_name = "处决者"
    
    def on_attack(self, wearer, target, dmg):
        # 这个效果在造成伤害后触发
        if target.hp > 0 and (target.hp / target.max_hp < 0.2):
            print(f"[处决者] 斩杀了 {target.name}！")
            kill_damage = target.hp
            packet = DamagePacket(amount=kill_damage, damage_type=DamageType.TRUE, source=wearer)
            target.take_damage(packet)

class Scavenger(Talent):
    """【天赋】清道夫：击败敌人时获得的金币提升50%。"""
    display_name = "清道夫"
    # (此天赋的逻辑需要在给予金币的地方检查)

class MagicShield(Talent):
    """【天赋】法力护盾：获得+20魔法抗性。"""
    display_name = "法力护盾"
    def on_init(self, wearer):
        wearer.magic_resist += 20

class FirstStrike(Talent):
    """【天赋】先发制人：进入战斗后的第一次攻击必定暴击。"""
    display_name = "先发制人"
    def on_init(self, wearer):
        self._used = False
    def on_attack(self, wearer, target, dmg):
        if not self._used:
            # 这个天赋最好在 before_attack 钩子中实现
            pass 
    
class LastStand(Talent):
    """【天赋】背水一战：生命值低于25%时，获得50%伤害减免。"""
    display_name = "背水一战"
    def on_init(self, wearer):
        wearer.damage_resistance_last_stand = 0.5 # 自定义一个属性
    # (此天赋的逻辑需要在 take_damage 中检查)

class AdrenalineRush(Talent):
    """【天赋】肾上腺素：每次杀死敌人，攻击速度提升10%，持续到战斗结束。"""
    display_name = "肾上腺素"
    # (此天赋逻辑复杂，需要战斗系统支持 on_kill 钩子)

class Brawler(Talent):
    """【天赋】格斗家：你无法装备副手物品，但你的基础攻击力提升30%。"""
    display_name = "格斗家"
    def on_init(self, wearer):
        # 只是修改规则和基础值，不再调用recalculate_stats
        wearer.SLOT_CAPACITY["offhand"] = 0
        wearer.base_attack *= 1.3 
        # 移除下面这两行
        # wearer.attack = wearer.base_attack
        # wearer.recalculate_stats()

class Adventurer(Talent):
    """【天赋】冒险者：获得的经验值提升50%。"""
    display_name = "冒险者"
    # (此天赋的逻辑需要在 add_exp 中检查)

class SacredRetribution(Talent):
    """【神圣报偿】: 每当你恢复生命时，对敌人造成等同于50%恢复量的真实伤害。"""
    display_name = "神圣报偿"

    def on_healed(self, wearer, healed_amount, combat_target):
        if combat_target and combat_target.hp > 0 and healed_amount > 0:
            damage = healed_amount * 0.5
            
            from damage import DamagePacket, DamageType
            packet = DamagePacket(amount=damage, damage_type=DamageType.TRUE, source=wearer)
            
            # ### 核心修改：先获取伤害报告，再用工具格式化日志 ###
            damage_details = combat_target.take_damage(packet)
            log_parts = format_damage_log(damage_details, action_name="神圣报偿")
            battle_logger.log(log_parts)

            # 不再需要返回任何东西


class Overwhelm(Talent):
    """【破势】: 对生命值高于50%的敌人，你的攻击造成200%伤害。"""
    display_name = "破势"

    def before_attack(self, wearer, target, packet: DamagePacket):
        """这是一个新的自定义钩子，会在Character.try_attack中被调用"""
        if target.hp / target.max_hp > 0.5:
            packet.amount *= 2

class SunfireAura(Talent):
    """【日炎光环】: 战斗开始时，对敌人施加【日炎灼烧】效果。"""
    display_name = "日炎光环"

    def on_battle_start(self, wearer, enemy):
        """这是一个新的自定义钩子，会在CombatScreen中被调用"""
        print(f"[{wearer.name}的日炎光环] 对 {enemy.name} 施加了灼烧！")
        enemy.add_debuff(Buffs.SunfireAuraDebuff(source_char=wearer))


================================================================================
### 文件路径: treasure_sprite.py
================================================================================

# treasure_sprite.py
import pygame
from settings import *

class TreasureChest(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        
        # 将来你可以换成漂亮的宝箱图片
        # 现在我们用一个金色的方块代替
        self.image = pygame.Surface([60, 50])
        self.image.fill((255, 215, 0)) # 金色
        self.rect = self.image.get_rect(center=(x, y))


================================================================================
### 文件路径: ui.py
================================================================================

# 文件: ui.py (最终正确版本)

import pygame
import textwrap
import inspect
import os
from collections import deque
from settings import *
from settings import DAMAGE_TYPE_NAMES_CN, DAMAGE_TYPE_COLORS, TEXT_COLOR, CRIT_COLOR

def init_fonts():
    fonts = {}
    try:
        fonts['normal'] = pygame.font.SysFont(FONT_NAME_CN, FONT_SIZE_NORMAL)
        fonts['small'] = pygame.font.SysFont(FONT_NAME_CN, FONT_SIZE_SMALL)
        fonts['large'] = pygame.font.SysFont(FONT_NAME_CN, FONT_SIZE_LARGE)
        fonts['minimap'] = pygame.font.SysFont(FONT_NAME_CN, 16) 
    except pygame.error:
        print("警告: 未找到指定中文字体，将使用默认字体。")
        fonts['normal'] = pygame.font.Font(None, FONT_SIZE_NORMAL + 4)
        fonts['small'] = pygame.font.Font(None, FONT_SIZE_SMALL + 4)
        fonts['large'] = pygame.font.Font(None, FONT_SIZE_LARGE + 4)
        fonts['minimap'] = pygame.font.Font(None, 18)
    return fonts

class Button:
    def __init__(self, rect, text, font):
        self.rect = pygame.Rect(rect)
        self.text = text
        self.font = font
        self.is_hovered = False
        self.is_clicked = False
    def handle_event(self, event):
        action_triggered = False
        if event.type == pygame.MOUSEMOTION:
            self.is_hovered = self.rect.collidepoint(event.pos)
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1 and self.is_hovered:
            self.is_clicked = True
            action_triggered = True
        if event.type == pygame.MOUSEBUTTONUP and event.button == 1:
            self.is_clicked = False
        return action_triggered
    def draw(self, surface):
        button_color = PANEL_BG_COLOR
        if self.is_clicked: button_color = BUTTON_CLICK_COLOR
        elif self.is_hovered: button_color = PANEL_BORDER_COLOR
        pygame.draw.rect(surface, button_color, self.rect, border_radius=10)
        pygame.draw.rect(surface, PANEL_BORDER_COLOR, self.rect, 2, border_radius=10)
        text_surf = self.font.render(self.text, True, TEXT_COLOR)
        text_rect = text_surf.get_rect(center=self.rect.center)
        surface.blit(text_surf, text_rect)

def draw_text(surface, text, font, color, rect, aa=True):
    y = rect.top
    line_spacing = -2
    font_height = font.size("Tg")[1]
    max_chars_per_line = rect.width // font.size("一")[0] if font.size("一")[0] > 0 else 1
    wrapped_text = textwrap.wrap(text, width=max_chars_per_line)
    for line in wrapped_text:
        line_surface = font.render(line, aa, color)
        surface.blit(line_surface, (rect.left, y))
        y += font_height + line_spacing

def draw_panel(surface, rect, title, font):
    pygame.draw.rect(surface, PANEL_BG_COLOR, rect, border_radius=10)
    pygame.draw.rect(surface, PANEL_BORDER_COLOR, rect, 3, border_radius=10)
    title_surf = font.render(title, True, TEXT_COLOR)
    title_rect = title_surf.get_rect(center=(rect.centerx, rect.top + 50))
    surface.blit(title_surf, title_rect)

def get_display_name(obj):
    return getattr(obj, 'display_name', obj.__class__.__name__)

def draw_character_panel(surface, char, rect, fonts):
    ui_elements = {'talents': [], 'buffs': []}
    pygame.draw.rect(surface, PANEL_BG_COLOR, rect, border_radius=15)
    pygame.draw.rect(surface, PANEL_BORDER_COLOR, rect, 3, border_radius=15)
    
    name_surf = fonts['large'].render(char.name, True, TEXT_COLOR)
    level_surf = fonts['normal'].render(f"Lv. {char.level}", True, TEXT_COLOR)
    surface.blit(name_surf, (rect.left + 20, rect.top + 15))
    surface.blit(level_surf, (rect.left + name_surf.get_width() + 30, rect.top + 28))

    hp_bar_rect = pygame.Rect(rect.left + 20, rect.top + 80, rect.width - 40, 30)
    hp_percent = char.hp / char.max_hp if char.max_hp > 0 else 0
    hp_width = (hp_bar_rect.width - 4) * hp_percent
    pygame.draw.rect(surface, (50,50,50), hp_bar_rect, border_radius=5)
    pygame.draw.rect(surface, HP_BAR_GREEN, (hp_bar_rect.left + 2, hp_bar_rect.top + 2, hp_width, hp_bar_rect.height - 4), border_radius=5)
    if char.shield > 0:
        shield_percent = min(char.shield / char.max_hp, 1.0)
        shield_width = (hp_bar_rect.width - 4) * shield_percent
        shield_rect_pos = hp_bar_rect.left + 2 + hp_width
        pygame.draw.rect(surface, SHIELD_BAR_GREY, (shield_rect_pos, hp_bar_rect.top + 2, shield_width, hp_bar_rect.height - 4), border_radius=5)
    hp_text = f"{int(char.hp)}/{int(char.max_hp)}" + (f" (+{int(char.shield)})" if char.shield > 0 else "")
    hp_text_surf = fonts['small'].render(hp_text, True, TEXT_COLOR)
    surface.blit(hp_text_surf, hp_text_surf.get_rect(center=hp_bar_rect.center))

    stats_text = f"攻击: {int(char.attack)} | 防御: {int(char.defense)} | 攻速: {char.attack_speed:.2f}"
    stats_surf = fonts['small'].render(stats_text, True, TEXT_COLOR)
    surface.blit(stats_surf, (rect.left + 20, rect.top + 140))

    equipped_talents_to_draw = [t for t in char.equipped_talents if t is not None]
    if equipped_talents_to_draw:
        current_x = rect.left + 20
        talent_label_surf = fonts['small'].render("天赋: ", True, (255, 215, 0))
        surface.blit(talent_label_surf, (current_x, rect.top + 170))
        current_x += talent_label_surf.get_width()
        for i, talent in enumerate(equipped_talents_to_draw):
            name_surf = fonts['small'].render(talent.display_name, True, (255, 215, 0))
            name_rect = name_surf.get_rect(left=current_x, top=rect.top + 170)
            surface.blit(name_surf, name_rect)
            ui_elements['talents'].append((name_rect, talent))
            current_x += name_rect.width
            if i < len(equipped_talents_to_draw) - 1:
                separator_surf = fonts['small'].render(" | ", True, (255, 215, 0))
                surface.blit(separator_surf, (current_x, rect.top + 170))
                current_x += separator_surf.get_width()

    visible_buffs = [b for b in char.buffs if not b.hidden]
    if visible_buffs:
        current_x = rect.left + 20
        status_label_surf = fonts['small'].render("状态: ", True, TEXT_COLOR)
        surface.blit(status_label_surf, (current_x, rect.top + 200))
        current_x += status_label_surf.get_width()
        for i, buff in enumerate(visible_buffs):
            buff_text = buff.display_name
            if buff.max_stacks > 1 and buff.stacks > 1: buff_text += f"({buff.stacks})"
            color = (255, 80, 80) if buff.is_debuff else (80, 255, 80)
            text_surf = fonts['small'].render(buff_text, True, color)
            text_rect = text_surf.get_rect(left=current_x, top=rect.top + 200)
            surface.blit(text_surf, text_rect)
            ui_elements['buffs'].append((text_rect, buff))
            current_x += text_rect.width
            if i < len(visible_buffs) - 1:
                separator_surf = fonts['small'].render(" | ", True, TEXT_COLOR)
                surface.blit(separator_surf, (current_x, rect.top + 200))
                current_x += separator_surf.get_width()
    
    return ui_elements

# 文件: ui.py (完整替换 ScrollableTextRenderer 类)

class ScrollableTextRenderer:
    def __init__(self, rect, font, line_height, text_color=(200, 200, 200), bg_color=(30, 30, 30, 180)):
        self.rect = rect
        self.font = font
        self.line_height = line_height
        self.default_text_color = text_color # <-- 重命名，以示区分
        self.bg_color = bg_color
        self.messages = []
        self.offset = 0
        self.visible_lines = int(self.rect.height / self.line_height)
        self.scroll_bar_width = 10
        self.padding = 5

    def add_message(self, parts, color=None):
        """
        ### 核心升级 ###
        现在可以接收一个 parts 列表，格式为: [(text1, color1), (text2, color2), ...]
        为了向后兼容，如果传入的是普通字符串，则自动包装。
        """
        if isinstance(parts, str):
            # 如果只传入一个普通字符串，就用提供的颜色或默认颜色包装它
            self.messages.append([(parts, color if color else self.default_text_color)])
        else:
            # 否则，假定传入的是一个列表
            self.messages.append(parts)

        if len(self.messages) > self.visible_lines:
            self.offset = len(self.messages) - self.visible_lines

    def handle_event(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN:
            if self.rect.collidepoint(event.pos):
                if event.button == 4: self.scroll(-1)
                elif event.button == 5: self.scroll(1)

    def scroll(self, delta_lines):
        max_offset = max(0, len(self.messages) - self.visible_lines)
        self.offset = max(0, min(self.offset + delta_lines, max_offset))

    def draw(self, surface):
        pygame.draw.rect(surface, self.bg_color, self.rect, border_radius=5)
        pygame.draw.rect(surface, PANEL_BORDER_COLOR, self.rect, 2, border_radius=5)
        
        content_rect = pygame.Rect(
            self.rect.left + self.padding, self.rect.top + self.padding,
            self.rect.width - 2 * self.padding - (self.scroll_bar_width if len(self.messages) > self.visible_lines else 0),
            self.rect.height - 2 * self.padding
        )
        display_surface = surface.subsurface(content_rect)

        for i in range(self.visible_lines):
            msg_idx = self.offset + i
            if msg_idx < len(self.messages):
                message_parts = self.messages[msg_idx]
                current_x = 0
                
                # ### 核心升级 ###
                # 遍历一行中的所有片段，并挨个绘制
                for text, color in message_parts:
                    text_surf = self.font.render(text, True, color)
                    display_surface.blit(text_surf, (current_x, i * self.line_height))
                    current_x += text_surf.get_width() # 移动下一个片段的起始x坐标

        if len(self.messages) > self.visible_lines:
            bar_height = max(10, (self.visible_lines / len(self.messages)) * content_rect.height)
            bar_y_ratio = self.offset / max(1, len(self.messages) - self.visible_lines)
            bar_y = content_rect.top + bar_y_ratio * (content_rect.height - bar_height)
            
            scroll_bg_rect = pygame.Rect(self.rect.right - self.scroll_bar_width - self.padding, self.rect.top + self.padding, self.scroll_bar_width, content_rect.height)
            pygame.draw.rect(surface, (50, 50, 50), scroll_bg_rect, border_radius=3)
            slider_rect = pygame.Rect(scroll_bg_rect.left, bar_y, self.scroll_bar_width, bar_height)
            pygame.draw.rect(surface, (150, 150, 150), slider_rect, border_radius=3)


class TooltipManager:
    def __init__(self, font, delay=500):
        self.font, self.delay = font, delay
        self.active_item, self.hover_start_time, self.tooltip_surface = None, 0, None
    def _get_description(self, item):
        if not item: return None
        doc = inspect.getdoc(item)
        if not doc: return get_display_name(item)
        display_name = getattr(item, 'display_name', item.__class__.__name__)
        return f"[ {display_name} ]\n" + "-"*20 + f"\n{doc}"
    def update(self, hovered_item):
        now = pygame.time.get_ticks()
        if hovered_item:
            if self.active_item != hovered_item:
                self.active_item, self.hover_start_time, self.tooltip_surface = hovered_item, now, None
            elif now - self.hover_start_time > self.delay and not self.tooltip_surface:
                self._create_tooltip_surface(self._get_description(self.active_item))
        else:
            self.active_item, self.tooltip_surface = None, None
    def _create_tooltip_surface(self, text):
        if not text: return
        lines, wrapped_lines, max_width = text.splitlines(), [], 0
        for line in lines:
            wrapped = textwrap.wrap(line, width=40, replace_whitespace=False)
            if not wrapped: wrapped_lines.append("")
            for wrapped_line in wrapped:
                wrapped_lines.append(wrapped_line)
                line_width = self.font.size(wrapped_line)[0]
                if line_width > max_width: max_width = line_width
        padding, line_height = 15, self.font.get_height()
        total_width, total_height = max_width + padding * 2, len(wrapped_lines) * line_height + padding * 2
        self.tooltip_surface = pygame.Surface((total_width, total_height), pygame.SRCALPHA)
        self.tooltip_surface.fill((20, 35, 50, 230))
        pygame.draw.rect(self.tooltip_surface, PANEL_BORDER_COLOR, self.tooltip_surface.get_rect(), 2, border_radius=8)
        current_y = padding
        for line in wrapped_lines:
            text_surf = self.font.render(line, True, TEXT_COLOR)
            self.tooltip_surface.blit(text_surf, (padding, current_y))
            current_y += line_height
    def draw(self, surface):
        if self.tooltip_surface:
            mouse_pos = pygame.mouse.get_pos()
            tooltip_rect = self.tooltip_surface.get_rect(topleft=(mouse_pos[0] + 15, mouse_pos[1] + 15))
            if tooltip_rect.right > SCREEN_WIDTH: tooltip_rect.right = mouse_pos[0] - 15
            if tooltip_rect.bottom > SCREEN_HEIGHT: tooltip_rect.bottom = mouse_pos[1] - 15
            surface.blit(self.tooltip_surface, tooltip_rect)

def format_damage_log(damage_details, action_name="效果"):
    """
    一个标准化的伤害日志格式化工具。
    接收 take_damage 返回的“伤害报告”字典和一个动作名称，
    返回一个可供 log_renderer 使用的富文本列表。
    """
    if not damage_details:
        return []

    source_name = "环境"
    if damage_details["source"]:
        source_name = damage_details["source"].name

    target_name = damage_details["target"].name
    dmg_amount = damage_details["final_amount"]
    dmg_type_enum = damage_details["damage_type"]
    
    dmg_type_name = DAMAGE_TYPE_NAMES_CN.get(dmg_type_enum.name, "未知伤害")
    dmg_color = DAMAGE_TYPE_COLORS.get(dmg_type_enum.name, (255, 255, 255))

    # 使用金色来突出显示动作名称
    action_color = (255, 215, 0) 

    log_parts = [
        (f"[{source_name}]", TEXT_COLOR),
        (f" 的 ", TEXT_COLOR),
        (f"[{action_name}]", action_color),
        (f" 对 ", TEXT_COLOR),
        (f"[{target_name}]", TEXT_COLOR),
        (f" 造成了 ", TEXT_COLOR),
        (f"{dmg_amount} 点 [{dmg_type_name}]", dmg_color),
    ]

    if damage_details["is_critical"]:
        log_parts.append((" (暴击!)", CRIT_COLOR))
        
    return log_parts


================================================================================
### 文件路径: dungeons\sunstone_ruins.json
================================================================================


{
    "id": "sunstone_ruins",
    "name": "日之石遗迹",
    "description": "一座被阳光遗忘的古老遗迹，充满了基础的元素生物和哥布林。",

    
    "floor_pools": [
        {
            "floors": [1, 2, 3],
            "monster_pool": ["slime", "goblin", "giant_bat"], 
            "elite_pool": ["goblin_captain", "armored_skeleton"], 
            "boss_id": "ruin_golem",
            "event_pool": ["fountain_of_power", "wandering_spirit"],
            "shop_items": {
                "item_count": 3,
                "rarity_weights": { "common": 70, "uncommon": 30, "rare": 5 }
            },
            "treasure_loot": {
                "item_count": 2,
                "rarity_weights": { "common": 60, "uncommon": 35, "rare": 10, "epic": 1 }
            }
        },
        {
            "floors": [4, 5],
            "monster_pool": ["wild_boar", "forest_spirit", "rock_golem"],
            "elite_pool": ["fire_elemental", "ice_elemental"],
            "boss_id": "dark_knight",
            "event_pool": ["wandering_spirit"],
            "shop_items": {
                "item_count": 4,
                "rarity_weights": { "common": 20, "uncommon": 50, "rare": 25, "epic": 5 }
            },
            "treasure_loot": {
                "item_count": 2,
                "rarity_weights": { "common": 10, "uncommon": 40, "rare": 40, "epic": 10 }
            }
        }
    ]
}


================================================================================
### 文件路径: states\backpack.py
================================================================================

# 文件: states/backpack.py (完整替换)

# ... (所有 import 语句保持不变) ...
import pygame
import math
from .base import BaseState
from ui import draw_text, draw_panel, get_display_name, TooltipManager, Button
from settings import *

# ... (SLOT_CONFIG 和 RARITY_COLORS 保持不变) ...
SLOT_CONFIG = {
    "weapon": {"name": "武器", "icon": "武", "color": (255, 100, 100)},
    "offhand": {"name": "副手", "icon": "副", "color": (100, 255, 100)},
    "helmet": {"name": "头盔", "icon": "头", "color": (255, 255, 100)},
    "armor": {"name": "胸甲", "icon": "甲", "color": (100, 100, 255)},
    "pants": {"name": "腿甲", "icon": "腿", "color": (255, 100, 255)},
    "accessory": {"name": "饰品", "icon": "饰", "color": (100, 255, 255)},
}
RARITY_COLORS = {
    "common": (156, 163, 175), "uncommon": (16, 185, 129), "rare": (59, 130, 246),
    "epic": (139, 92, 246), "legendary": (245, 158, 11),
}

class BackpackScreen(BaseState):
    def __init__(self, game, player_override=None): # <-- 核心修改1
        super().__init__(game)
        self.player = player_override or self.game.player # <-- 核心修改2

        # --- 后续所有用到 self.game.player 的地方，都改成 self.player ---
        self.is_overlay = True
        # ... (其他初始化代码不变) ...
        self.dragging_item, self.dragging_from, self.dragging_from_info = None, None, {}
        self.selected_category, self.search_text, self.search_active = "all", "", False
        self.hover_slot = None
        self.tooltip_manager = TooltipManager(self.game.fonts['small'])
        self._setup_layout()
        self._setup_animations()

    # ... (除了下面被替换的方法，其他所有方法都不变) ...
    def _get_font(self, font_name, default_size=20):
        try:
            if hasattr(self.game, 'fonts') and font_name in self.game.fonts: return self.game.fonts[font_name]
        except: pass
        return pygame.font.Font(None, default_size)

    def _setup_layout(self):
        margin, header_height, sidebar_width, char_panel_width = 40, 80, 200, 280
        self.container_rect = pygame.Rect(margin, margin, SCREEN_WIDTH - 2*margin, SCREEN_HEIGHT - 2*margin)
        self.header_rect = pygame.Rect(self.container_rect.x, self.container_rect.y, self.container_rect.width, header_height)
        content_y, content_height = self.header_rect.bottom + 10, self.container_rect.height - header_height - 10
        self.sidebar_rect = pygame.Rect(self.container_rect.x, content_y, sidebar_width, content_height)
        self.character_panel_rect = pygame.Rect(self.container_rect.right - char_panel_width, content_y, char_panel_width, content_height)
        self.inventory_rect = pygame.Rect(self.sidebar_rect.right + 10, content_y, self.character_panel_rect.left - self.sidebar_rect.right - 20, content_height)
        self.search_rect = pygame.Rect(self.inventory_rect.x + 10, self.inventory_rect.y + 10, self.inventory_rect.width - 20, 35)
        self.grid_rect = pygame.Rect(self.inventory_rect.x + 10, self.search_rect.bottom + 15, self.inventory_rect.width - 20, self.inventory_rect.height - 60)
        self._generate_ui_elements()

    def _setup_animations(self): self.hover_animation, self.glow_animation = {}, 0

    def _generate_ui_elements(self):
        self.category_buttons = []
        categories = [("all", "全部"), ("weapon", "武器"), ("armor", "防具"), ("consumable", "消耗"), ("material", "材料"), ("misc", "其他")]
        btn_h, btn_s, start_y = 45, 8, self.sidebar_rect.y + 20
        for i, (cat_id, name) in enumerate(categories):
            rect = pygame.Rect(self.sidebar_rect.x + 15, start_y + i * (btn_h + btn_s), self.sidebar_rect.width - 30, btn_h)
            self.category_buttons.append({"id": cat_id, "name": name, "rect": rect, "hover": False})
        self.backpack_slots = []
        cols, rows, slot_size = 10, 6, min((self.grid_rect.width - 20) // 10 - 5, (self.grid_rect.height - 20) // 6 - 5)
        for row in range(rows):
            for col in range(cols):
                x, y = self.grid_rect.x + 10 + col * (slot_size + 5), self.grid_rect.y + 10 + row * (slot_size + 5)
                self.backpack_slots.append(pygame.Rect(x, y, slot_size, slot_size))
        self._generate_equipment_slots()
        close_btn_rect = pygame.Rect(self.container_rect.right - 45, self.container_rect.top + 10, 35, 35)
        self.close_button = Button(close_btn_rect, "X", self.game.fonts['normal'])

    def _generate_equipment_slots(self):
        self.equipment_slots = {}
        player = self.player # <-- 修改点
        model_rect = pygame.Rect(self.character_panel_rect.x + 15, self.character_panel_rect.y + 15, self.character_panel_rect.width - 30, 300)
        slot_size, spacing = 50, 10
        center_x = model_rect.centerx

        self.equipment_slots["helmet"] = [pygame.Rect(center_x - slot_size/2, model_rect.top + 10, slot_size, slot_size)]
        armor_rect = pygame.Rect(center_x - slot_size/2, model_rect.top + slot_size + spacing + 10, slot_size, slot_size)
        self.equipment_slots["armor"] = [armor_rect]
        self.equipment_slots["pants"] = [pygame.Rect(center_x - slot_size/2, armor_rect.bottom + spacing, slot_size, slot_size)]

        weapon_slots = []
        num_weapon_slots = player.SLOT_CAPACITY.get("weapon", 1)
        for i in range(num_weapon_slots):
            x = armor_rect.left - slot_size - spacing
            y = armor_rect.centery - slot_size/2 + i * (slot_size + spacing)
            weapon_slots.append(pygame.Rect(x, y, slot_size, slot_size))
        self.equipment_slots["weapon"] = weapon_slots

        if player.SLOT_CAPACITY.get("offhand", 0) > 0:
            self.equipment_slots["offhand"] = [pygame.Rect(armor_rect.right + spacing, armor_rect.centery - slot_size/2, slot_size, slot_size)]
        else:
            self.equipment_slots["offhand"] = []

        accessory_slots = []
        num_accessory_slots = player.SLOT_CAPACITY.get("accessory", 0)
        total_accessory_width = num_accessory_slots * slot_size + (num_accessory_slots - 1) * 5
        start_x = model_rect.centerx - total_accessory_width / 2
        accessory_y = model_rect.bottom - slot_size - 10
        for i in range(num_accessory_slots):
            x = start_x + i * (slot_size + 5)
            accessory_slots.append(pygame.Rect(x, accessory_y, slot_size, slot_size))
        self.equipment_slots["accessory"] = accessory_slots

    def handle_event(self, event):
        if self.close_button.handle_event(event): self.game.state_stack.pop(); return
        if event.type == pygame.KEYDOWN:
            if event.key in [pygame.K_b, pygame.K_ESCAPE]:
                if self.dragging_item: self._return_dragging_item()
                self.game.state_stack.pop(); return
            elif event.key == pygame.K_BACKSPACE and self.search_active: self.search_text = self.search_text[:-1]
            elif self.search_active and event.unicode.isprintable(): self.search_text += event.unicode
        elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            if not self.close_button.rect.collidepoint(event.pos): self._handle_mouse_down(event.pos)
        elif event.type == pygame.MOUSEBUTTONUP and event.button == 1: self._handle_mouse_up(event.pos)
        elif event.type == pygame.MOUSEMOTION: self._handle_mouse_motion(event.pos)

    def _handle_mouse_down(self, pos):
        player = self.player # <-- 修改点
        if self.search_rect.collidepoint(pos): self.search_active = True; return
        else: self.search_active = False
        for button in self.category_buttons:
            if button["rect"].collidepoint(pos): self.selected_category = button["id"]; return
        if self.dragging_item: return
        for slot_type, slot_rects in self.equipment_slots.items():
            for i, rect in enumerate(slot_rects):
                if rect.collidepoint(pos) and player.slots[slot_type][i] is not None:
                    item_to_drag = player.slots[slot_type][i]
                    self.dragging_item = player.unequip(item_to_drag)
                    self.dragging_from = 'equipment'
                    self.dragging_from_info = {'slot_type': slot_type, 'index': i}
                    return
        filtered_items = self._get_filtered_items()
        for i, rect in enumerate(self.backpack_slots):
            if rect.collidepoint(pos) and i < len(filtered_items):
                original_item = filtered_items[i]
                original_index_in_backpack = player.backpack.index(original_item)
                self.dragging_item = player.backpack.pop(original_index_in_backpack)
                self.dragging_from = 'backpack'
                self.dragging_from_info = {'index': original_index_in_backpack}
                return

    def _handle_mouse_up(self, pos):
        if not self.dragging_item: return
        player = self.player # <-- 修改点
        source_type, source_info = self.dragging_from, self.dragging_from_info
        for slot_type, slot_rects in self.equipment_slots.items():
            for i, rect in enumerate(slot_rects):
                if rect.collidepoint(pos) and self.dragging_item.slot == slot_type:
                    replaced_item = player.equip(self.dragging_item, specific_index=i)
                    if replaced_item:
                        if source_type == 'backpack':
                            player.backpack.append(replaced_item)
                        elif source_type == 'equipment':
                            player.equip(replaced_item, specific_index=source_info['index'])
                    self.dragging_item = None
                    return
        if self.grid_rect.collidepoint(pos):
            player.backpack.append(self.dragging_item)
            self.dragging_item = None
            return
        self._return_dragging_item()
        self.dragging_item = None

    def _handle_mouse_motion(self, pos):
        for button in self.category_buttons: button["hover"] = button["rect"].collidepoint(pos)
        self.hover_slot = None
        for slot_type, slot_rects in self.equipment_slots.items():
            for i, rect in enumerate(slot_rects):
                if rect.collidepoint(pos): self.hover_slot = (slot_type, i); break

    def _get_filtered_items(self):
        items = self.player.backpack.copy() # <-- 修改点
        if self.selected_category != "all":
            items = [item for item in items if hasattr(item, 'type') and item.type == self.selected_category]
        if self.search_text:
            items = [item for item in items if self.search_text.lower() in get_display_name(item).lower()]
        return items

    def _return_dragging_item(self):
        if not self.dragging_item: return
        player = self.player # <-- 修改点
        if self.dragging_from == 'backpack': 
            player.backpack.insert(self.dragging_from_info.get('index', 0), self.dragging_item)
        elif self.dragging_from == 'equipment': 
            player.equip(self.dragging_item)

    def _update_hovers(self):
        if self.dragging_item: self.tooltip_manager.update(None); return
        mouse_pos = pygame.mouse.get_pos()
        player = self.player # <-- 修改点
        hovered_item = None
        all_elements = []
        for slot_type, slot_rects in self.equipment_slots.items():
            equipped_items = player.slots.get(slot_type, [])
            for i, rect in enumerate(slot_rects):
                if equipped_items[i] is not None: all_elements.append((rect, equipped_items[i]))
        filtered_items = self._get_filtered_items()
        for i, rect in enumerate(self.backpack_slots):
            if i < len(filtered_items): all_elements.append((rect, filtered_items[i]))
        for rect, obj in all_elements:
            if rect.collidepoint(mouse_pos): hovered_item = obj; break
        self.tooltip_manager.update(hovered_item)

    def update(self, dt=0):
        current_time = pygame.time.get_ticks()
        if not hasattr(self, '_last_time'): self._last_time = current_time
        dt_ms = current_time - self._last_time; self._last_time = current_time; dt_sec = dt_ms / 1000.0
        self.glow_animation = (self.glow_animation + dt_sec * 3) % (2 * math.pi)
        self.animation_offset = math.sin(self.glow_animation) * 2; self._update_hovers()

    def draw(self, surface):
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA); overlay.fill((0, 0, 0, 160)); surface.blit(overlay, (0, 0))
        self._draw_modern_panel(surface, self.container_rect, (25, 30, 50, 240))
        self._draw_header(surface); self._draw_sidebar(surface); self._draw_inventory_area(surface)
        self._draw_character_panel(surface); self._draw_dragging_item(surface)
        self.close_button.draw(surface); self.tooltip_manager.draw(surface)
        if hasattr(self, 'update'): self.update()

    def _draw_modern_panel(self, surface, rect, color, border_color=None):
        pygame.draw.rect(surface, color, rect, border_radius=12)
        if border_color is None: border_color = (70, 80, 100, 180)
        pygame.draw.rect(surface, border_color, rect, width=2, border_radius=12)
        glow_rect = rect.inflate(-4, -4); pygame.draw.rect(surface, (255, 255, 255, 10), glow_rect, width=1, border_radius=10)

    def _draw_header(self, surface):
        header_bg = self.header_rect.inflate(-10, -10); self._draw_modern_panel(surface, header_bg, (35, 40, 65, 200))
        title_font = self._get_font('large', 32); title_text = title_font.render("背包系统", True, (255, 215, 0))
        title_rect = title_text.get_rect(x=header_bg.x + 20, centery=header_bg.centery); surface.blit(title_text, title_rect)

    def _draw_sidebar(self, surface):
        sidebar_bg = self.sidebar_rect.inflate(-5, -5); self._draw_modern_panel(surface, sidebar_bg, (30, 35, 55, 200))
        for button in self.category_buttons:
            is_active, is_hover = button["id"] == self.selected_category, button["hover"]
            if is_active: bg_color, border_color, text_color = (255, 215, 0, 100), (255, 215, 0), (255, 255, 255)
            elif is_hover: bg_color, border_color, text_color = (70, 80, 100, 120), (100, 110, 130), (240, 240, 240)
            else: bg_color, border_color, text_color = (40, 50, 70, 80), (60, 70, 90), (180, 180, 180)
            button_rect = button["rect"]; 
            if is_hover: button_rect = button_rect.move(2 + self.animation_offset, 0)
            pygame.draw.rect(surface, bg_color, button_rect, border_radius=8); pygame.draw.rect(surface, border_color, button_rect, width=2, border_radius=8)
            font = self._get_font('small', 18); text = f"{button['name']}"; text_surface = font.render(text, True, text_color); text_rect = text_surface.get_rect(center=button_rect.center); surface.blit(text_surface, text_rect)

    def _draw_inventory_area(self, surface):
        inventory_bg = self.inventory_rect.inflate(-5, -5); self._draw_modern_panel(surface, inventory_bg, (30, 35, 55, 200))
        search_bg_color, border_color = ((50, 60, 80, 150), (255, 215, 0)) if self.search_active else ((40, 50, 70, 120), (70, 80, 100))
        pygame.draw.rect(surface, search_bg_color, self.search_rect, border_radius=6); pygame.draw.rect(surface, border_color, self.search_rect, width=2, border_radius=6)
        search_font = self._get_font('small', 18); display_text = self.search_text or "搜索物品..."; text_color = (255, 255, 255) if self.search_text else (150, 150, 150)
        search_surface = search_font.render(display_text, True, text_color); search_text_rect = search_surface.get_rect(x=self.search_rect.x + 10, centery=self.search_rect.centery); surface.blit(search_surface, search_text_rect)
        if self.search_active and int(self.glow_animation * 2) % 2: pygame.draw.line(surface, (255, 255, 255), (search_text_rect.right + 2, self.search_rect.y + 8), (search_text_rect.right + 2, self.search_rect.bottom - 8), 2)
        self._draw_backpack_grid(surface)

    def _draw_backpack_grid(self, surface):
        filtered_items = self._get_filtered_items()
        for i, slot_rect in enumerate(self.backpack_slots):
            rarity_color = RARITY_COLORS['common']; bg_color, border_color = (40, 50, 70, 60), (60, 70, 90, 120)
            if i < len(filtered_items): item = filtered_items[i]; rarity = getattr(item, 'rarity', 'common'); rarity_color = RARITY_COLORS.get(rarity, RARITY_COLORS['common']); bg_color, border_color = (*rarity_color, 30), (*rarity_color, 180)
            pygame.draw.rect(surface, bg_color, slot_rect, border_radius=6); pygame.draw.rect(surface, border_color, slot_rect, width=2, border_radius=6)
            if i < len(filtered_items):
                item = filtered_items[i]
                if item != self.dragging_item:
                    item_name = get_display_name(item); font = self._get_font('small', 12) 
                    item_surface = font.render(item_name, True, (255, 255, 255)); 
                    if item_surface.get_width() > slot_rect.width - 8: 
                        item_name = item_name[:5] + ".."
                        item_surface = font.render(item_name, True, (255, 255, 255))
                    item_rect = item_surface.get_rect(center=slot_rect.center); surface.blit(item_surface, item_rect)
                    pygame.draw.rect(surface, rarity_color, (slot_rect.x, slot_rect.y, slot_rect.width, 3), border_top_left_radius=2, border_top_right_radius=2)

    def _draw_character_panel(self, surface):
        panel_bg = self.character_panel_rect.inflate(-5, -5); self._draw_modern_panel(surface, panel_bg, (30, 35, 55, 200))
        model_area = pygame.Rect(panel_bg.x + 15, panel_bg.y + 15, panel_bg.width - 30, 300)
        pygame.draw.rect(surface, (20, 25, 40, 150), model_area, border_radius=10)
        self._draw_equipment_slots(surface); self._draw_character_stats(surface, panel_bg)

    def _draw_equipment_slots(self, surface):
        player = self.player # <-- 修改点
        for slot_type, slot_rects in self.equipment_slots.items():
            slot_config = SLOT_CONFIG.get(slot_type, {"name": slot_type, "icon": "?", "color": (100, 100, 100)})
            for i, slot_rect in enumerate(slot_rects):
                is_hover = self.hover_slot == (slot_type, i)
                bg_color, border_color = ((*slot_config["color"], 50), slot_config["color"]) if is_hover else ((40, 50, 70, 100), (70, 80, 100))
                pygame.draw.rect(surface, bg_color, slot_rect, border_radius=8)
                pygame.draw.rect(surface, border_color, slot_rect, width=2, border_radius=8)
                item_in_slot = player.slots[slot_type][i]
                if item_in_slot is not None:
                    if item_in_slot != self.dragging_item:
                        item_name = get_display_name(item_in_slot)
                        font = self._get_font('small', 13)
                        if font.size(item_name)[0] > slot_rect.width - 6: 
                            item_name = item_name[:3] + ".."
                        text = font.render(item_name, True, (255, 255, 255))
                        text_rect = text.get_rect(center=slot_rect.center)
                        surface.blit(text, text_rect)
                else:
                    font = self._get_font('small', 14)
                    text_surf = font.render(slot_config["name"], True, (80, 90, 110))
                    text_rect = text_surf.get_rect(center=slot_rect.center)
                    surface.blit(text_surf, text_rect)

    def _draw_character_stats(self, surface, panel_bg):
        stats_area = pygame.Rect(panel_bg.x + 15, panel_bg.bottom - 185, panel_bg.width - 30, 170)
        pygame.draw.rect(surface, (20, 25, 40, 150), stats_area, border_radius=10)
        player = self.player # <-- 修改点
        stats_data = [("最大生命", f"{int(getattr(player, 'max_hp', 0))}"), ("攻击", f"{int(getattr(player, 'attack', 0))}"), ("防御", f"{int(getattr(player, 'defense', 0))}"), ("攻击速度", f"{getattr(player, 'attack_speed', 0):.2f}"), ("暴击率", f"{getattr(player, 'crit_chance', 0) * 100:.1f}%"), ("暴击伤害", f"{getattr(player, 'crit_multiplier', 0) * 100:.1f}%")]
        stats_font = self.game.fonts['small']; line_height = 26; y_offset = stats_area.y + 12
        for i, (name, value) in enumerate(stats_data):
            y_pos = y_offset + i * line_height
            name_surface = stats_font.render(f"{name}:", True, (180, 180, 180)); name_rect = name_surface.get_rect(x=stats_area.x + 15, centery=y_pos); surface.blit(name_surface, name_rect)
            value_surface = stats_font.render(str(value), True, (255, 215, 0)); value_rect = value_surface.get_rect(right=stats_area.right - 15, centery=y_pos); surface.blit(value_surface, value_rect)

    def _draw_dragging_item(self, surface):
        if self.dragging_item:
            mouse_pos = pygame.mouse.get_pos(); item_name = get_display_name(self.dragging_item)
            font = self._get_font('normal', 20); text_surface = font.render(item_name, True, (255, 255, 255)); text_rect = text_surface.get_rect(center=mouse_pos)
            bg_rect = text_rect.inflate(20, 12); pygame.draw.rect(surface, (40, 50, 80, 220), bg_rect, border_radius=8); pygame.draw.rect(surface, (255, 215, 0), bg_rect, width=2, border_radius=8); surface.blit(text_surface, text_rect)


================================================================================
### 文件路径: states\base.py
================================================================================

# states/base.py
class BaseState:
    def __init__(self, game):
        self.game = game

    def handle_event(self, event):
        """处理该状态下的单个事件"""
        pass

    def update(self):
        """更新该状态下的逻辑（非事件驱动）"""
        pass

    def draw(self, surface):
        """绘制该状态的画面"""
        pass


================================================================================
### 文件路径: states\choice_screen.py
================================================================================

# 文件: states/choice_screen.py (现代化重写版本)

import pygame
import math
import inspect
from .base import BaseState
from ui import Button, draw_text
from settings import *

class ChoiceScreen(BaseState):
    def __init__(self, game, item_choices, origin_room):
        super().__init__(game)
        self.is_overlay = True
        self.item_choices = item_choices
        self.origin_room = origin_room
        self.choice_buttons = []
        self.choice_made = False
        
        # 动画系统
        self.hover_animations = {}
        self.glow_animation = 0
        self.entrance_animation = 0
        self.card_offsets = []
        
        self._setup_ui()

    def _get_font(self, font_name, default_size=20):
        """安全获取字体"""
        try:
            if hasattr(self.game, 'fonts') and font_name in self.game.fonts:
                return self.game.fonts[font_name]
        except:
            pass
        return pygame.font.Font(None, default_size)

    def _setup_ui(self):
        num_choices = len(self.item_choices)
        
        # 动态调整面板大小
        base_card_width, base_card_height = 320, 450
        spacing = 30
        total_width = base_card_width * num_choices + spacing * (num_choices - 1) + 100
        
        # 如果太宽，调整卡片大小
        if total_width > SCREEN_WIDTH - 100:
            available_width = SCREEN_WIDTH - 200
            card_width = (available_width - spacing * (num_choices - 1)) // num_choices
            card_width = max(280, card_width)  # 最小宽度
        else:
            card_width = base_card_width
        
        card_height = base_card_height
        panel_width = min(total_width, SCREEN_WIDTH - 100)
        panel_height = card_height + 180
        
        self.panel_rect = pygame.Rect(0, 0, panel_width, panel_height)
        self.panel_rect.center = (SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2)
        
        # 创建卡片按钮
        actual_spacing = 30 if num_choices <= 3 else 20
        total_cards_width = card_width * num_choices + actual_spacing * (num_choices - 1)
        start_x = self.panel_rect.centerx - total_cards_width // 2
        
        self.choice_buttons = []
        self.card_offsets = []
        
        for i, item in enumerate(self.item_choices):
            card_x = start_x + i * (card_width + actual_spacing)
            card_rect = pygame.Rect(card_x, self.panel_rect.y + 90, card_width, card_height)
            button = Button(card_rect, "", self._get_font('normal'))
            self.choice_buttons.append((button, item))
            self.card_offsets.append(0)  # 初始化动画偏移
            self.hover_animations[i] = 0

    def handle_event(self, event):
        if self.choice_made or self.entrance_animation < 1.0:
            return

        for i, (button, item) in enumerate(self.choice_buttons):
            if button.handle_event(event):
                self.choice_made = True 
                
                # 添加选择动画效果
                self._animate_selection(i)
                
                # 处理选择逻辑
                feedback = self.game.player.pickup_item(item)
                print(f"玩家选择了: {getattr(item, 'display_name', item.__class__.__name__)}")
                
                self.origin_room.is_cleared = True
                
                # 更新地牢界面
                from .dungeon_screen import DungeonScreen
                if len(self.game.state_stack) > 1:
                    prev_state = self.game.state_stack[-2]
                    if isinstance(prev_state, DungeonScreen):
                        prev_state.door_rects = prev_state._generate_doors()
                
                # 退出当前界面
                self.game.state_stack.pop() 

                # 显示通知
                if feedback:
                    from .notification_screen import NotificationScreen
                    self.game.state_stack.append(NotificationScreen(self.game, feedback))
                
                return

    def _animate_selection(self, selected_index):
        """选择动画效果"""
        for i in range(len(self.choice_buttons)):
            if i != selected_index:
                self.hover_animations[i] = -1  # 标记为未选中

    def update(self, dt=0):
        """更新动画"""
        current_time = pygame.time.get_ticks()
        if not hasattr(self, '_last_time'): 
            self._last_time = current_time
            
        dt_ms = current_time - self._last_time
        self._last_time = current_time
        dt_sec = dt_ms / 1000.0
        
        # 入场动画
        self.entrance_animation = min(1.0, self.entrance_animation + dt_sec * 3)
        
        # 发光动画
        self.glow_animation = (self.glow_animation + dt_sec * 2) % (2 * math.pi)
        
        # 悬停检测和动画
        mouse_pos = pygame.mouse.get_pos()
        for i, (button, item) in enumerate(self.choice_buttons):
            if button.rect.collidepoint(mouse_pos) and not self.choice_made:
                self.hover_animations[i] = min(1.0, self.hover_animations[i] + dt_sec * 4)
                # 轻微浮动效果
                self.card_offsets[i] = math.sin(current_time * 0.003 + i) * 3
            else:
                if self.hover_animations[i] >= 0:  # 只有非选择状态才衰减
                    self.hover_animations[i] = max(0, self.hover_animations[i] - dt_sec * 3)
                    self.card_offsets[i] = 0

    def draw(self, surface):
        # 半透明遮罩
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, int(200 * self.entrance_animation)))
        surface.blit(overlay, (0, 0))
        
        # 主面板（入场动画）
        panel_rect = self.panel_rect.copy()
        if self.entrance_animation < 1.0:
            scale = 0.8 + 0.2 * self.entrance_animation
            panel_rect = pygame.Rect(0, 0, 
                                   int(self.panel_rect.width * scale),
                                   int(self.panel_rect.height * scale))
            panel_rect.center = (SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2)
        
        self._draw_modern_panel(surface, panel_rect, (25, 30, 50, 240))
        
        # 绘制标题
        self._draw_header(surface, panel_rect)
        
        # 绘制选择卡片
        self._draw_choice_cards(surface)

    def _draw_modern_panel(self, surface, rect, color, border_color=None):
        """绘制现代化面板"""
        pygame.draw.rect(surface, color, rect, border_radius=15)
        if border_color is None: 
            border_color = (70, 80, 100, 200)
        pygame.draw.rect(surface, border_color, rect, width=3, border_radius=15)
        
        # 内发光效果
        glow_rect = rect.inflate(-6, -6)
        pygame.draw.rect(surface, (255, 255, 255, 20), glow_rect, width=2, border_radius=12)

    def _draw_header(self, surface, panel_rect):
        """绘制标题区域"""
        title_rect = pygame.Rect(panel_rect.x + 30, panel_rect.y + 20, 
                                panel_rect.width - 60, 60)
        
        # 标题背景
        title_bg = title_rect.inflate(20, 10)
        self._draw_modern_panel(surface, title_bg, (35, 40, 65, 180), (100, 120, 150))
        
        # 主标题
        title_font = self._get_font('large', 28)
        title_text = "选择奖励"
        title_surface = title_font.render(title_text, True, (255, 215, 0))
        title_pos = title_surface.get_rect(center=title_bg.center)
        surface.blit(title_surface, title_pos)
        
        # 副标题
        subtitle_font = self._get_font('small', 16)
        subtitle_text = "从以下选项中选择一个奖励"
        subtitle_surface = subtitle_font.render(subtitle_text, True, (180, 180, 180))
        subtitle_pos = subtitle_surface.get_rect(centerx=title_bg.centerx, 
                                                top=title_pos.bottom + 5)
        surface.blit(subtitle_surface, subtitle_pos)

    def _draw_choice_cards(self, surface):
        """绘制选择卡片"""
        for i, (button, item) in enumerate(self.choice_buttons):
            # 计算动画偏移
            hover_alpha = max(0, self.hover_animations[i])
            entrance_offset = (1 - self.entrance_animation) * 100
            card_rect = button.rect.copy()
            card_rect.y += entrance_offset + self.card_offsets[i]
            
            # 绘制卡片
            self._draw_item_card(surface, card_rect, item, hover_alpha, i)

    def _draw_item_card(self, surface, rect, item, hover_alpha, card_index):
        """绘制单个物品卡片"""
        # 获取物品信息
        name = getattr(item, 'display_name', item.__class__.__name__)
        rarity = getattr(item, 'rarity', 'common')
        rarity_color = RARITY_COLORS.get(rarity, RARITY_COLORS['common'])
        
        # 卡片背景色（根据悬停状态调整）
        if self.hover_animations[card_index] == -1:  # 未选中状态
            bg_alpha = 100
            border_alpha = 120
            scale = 0.95
        else:
            bg_alpha = int(120 + hover_alpha * 40)
            border_alpha = int(160 + hover_alpha * 95)
            scale = 1.0 + hover_alpha * 0.05
        
        # 缩放卡片
        if scale != 1.0:
            scaled_size = (int(rect.width * scale), int(rect.height * scale))
            scaled_rect = pygame.Rect(0, 0, *scaled_size)
            scaled_rect.center = rect.center
            rect = scaled_rect
        
        # 卡片主体
        card_bg_color = (*rarity_color, bg_alpha)
        border_color = (*rarity_color, border_alpha)
        
        pygame.draw.rect(surface, card_bg_color, rect, border_radius=12)
        pygame.draw.rect(surface, border_color, rect, width=3, border_radius=12)
        
        # 稀有度装饰条
        decoration_rect = pygame.Rect(rect.x, rect.y, rect.width, 8)
        pygame.draw.rect(surface, rarity_color, decoration_rect, 
                        border_top_left_radius=12, border_top_right_radius=12)
        
        # 发光效果（悬停时）
        if hover_alpha > 0:
            glow_intensity = int((math.sin(self.glow_animation) + 1) * hover_alpha * 30 + 10)
            glow_surface = pygame.Surface(rect.size, pygame.SRCALPHA)
            pygame.draw.rect(glow_surface, (*rarity_color, glow_intensity), 
                           (0, 0, rect.width, rect.height), border_radius=12)
            surface.blit(glow_surface, rect.topleft)
        
        # 物品名称
        name_font = self._get_font('normal', 20)
        name_surface = name_font.render(name, True, (255, 255, 255))
        name_rect = name_surface.get_rect(centerx=rect.centerx, top=rect.top + 25)
        
        # 名称背景
        name_bg_rect = name_rect.inflate(20, 8)
        pygame.draw.rect(surface, (0, 0, 0, 120), name_bg_rect, border_radius=6)
        surface.blit(name_surface, name_rect)
        
        # 稀有度标签
        rarity_font = self._get_font('small', 14)
        rarity_text = rarity.upper()
        rarity_surface = rarity_font.render(rarity_text, True, rarity_color)
        rarity_rect = rarity_surface.get_rect(centerx=rect.centerx, 
                                             top=name_rect.bottom + 10)
        surface.blit(rarity_surface, rarity_rect)
        
        # 分割线
        line_y = rarity_rect.bottom + 15
        pygame.draw.line(surface, (100, 100, 100), 
                        (rect.x + 20, line_y), (rect.right - 20, line_y), 2)
        
        # 物品描述
        description = inspect.getdoc(item) or "这是一个神秘的物品。"
        desc_rect = pygame.Rect(rect.x + 15, line_y + 15, 
                               rect.width - 30, rect.height - (line_y - rect.y) - 30)
        self._draw_wrapped_text(surface, description, self._get_font('small', 14), 
                               (200, 200, 200), desc_rect)
        
        # 选择提示（悬停时）
        if hover_alpha > 0.5:
            hint_font = self._get_font('small', 16)
            hint_text = "点击选择"
            hint_surface = hint_font.render(hint_text, True, (255, 255, 100))
            hint_rect = hint_surface.get_rect(centerx=rect.centerx, 
                                             bottom=rect.bottom - 15)
            
            # 提示背景
            hint_bg = hint_rect.inflate(16, 6)
            pygame.draw.rect(surface, (50, 50, 0, 150), hint_bg, border_radius=4)
            surface.blit(hint_surface, hint_rect)

    def _draw_wrapped_text(self, surface, text, font, color, rect):
        """绘制自动换行文本"""
        words = text.split(' ')
        lines = []
        current_line = ""
        
        for word in words:
            test_line = current_line + (" " if current_line else "") + word
            if font.size(test_line)[0] <= rect.width:
                current_line = test_line
            else:
                if current_line:
                    lines.append(current_line)
                current_line = word
        
        if current_line:
            lines.append(current_line)
        
        # 绘制行
        line_height = font.get_height() + 3
        y_offset = rect.y
        
        for line in lines:
            if y_offset + line_height > rect.bottom:
                break
            line_surface = font.render(line, True, color)
            surface.blit(line_surface, (rect.x, y_offset))
            y_offset += line_height


================================================================================
### 文件路径: states\combat.py
================================================================================

# states/combat.py (已更新)
import pygame
import time
import random # 导入 random
from .base import BaseState
from ui import ScrollableTextRenderer, draw_character_panel, TooltipManager, Button, draw_panel, draw_text
from settings import *
from Character import Character
import Talents
from battle_logger import battle_logger

# 文件: states/combat.py (替换整个类)

class CombatScreen(BaseState):
    def __init__(self, game, enemy_id, origin_identifier=None):
        super().__init__(game)
        self.enemy_id = enemy_id
        self.origin_id = origin_identifier
        
        self.tooltip_manager = TooltipManager(self.game.fonts['small'])

        # 这会创建 self.enemy
        self._initialize_combat()
        
        # ### 核心修复：在这里，正式为双方指定对手！###
        self.game.player.current_opponent = self.enemy
        self.enemy.current_opponent = self.game.player

        self.player_ui_elements, self.enemy_ui_elements = {}, {}
        self.is_paused = False
        pause_button_rect = pygame.Rect(SCREEN_WIDTH - 60, 10, 50, 50)
        self.pause_button = Button(pause_button_rect, "||", self.game.fonts['normal'])

        self.battle_ended = False
        self.end_timer = 0.0
        self.END_DELAY = 2.0
        
        self.log_renderer = ScrollableTextRenderer(
            BATTLE_LOG_RECT, 
            self.game.fonts['small'], 
            line_height=20,
            bg_color=(30, 30, 30, 180)
        )
        
        battle_logger.register_renderer(self.log_renderer)
        self.log_renderer.add_message(f"战斗开始！遭遇了 {self.enemy.name}！")


    def _initialize_combat(self):
        enemy_preset = self.game.enemy_data[self.enemy_id]
        rolled_talents = []
        
        possible_talents = enemy_preset.get("possible_talents", [])
        for talent_info in possible_talents:
            if random.random() < talent_info["chance"]:
                talent_class_name = talent_info["talent_class_name"]
                if hasattr(Talents, talent_class_name):
                    talent_class = getattr(Talents, talent_class_name)
                    rolled_talents.append(talent_class())

        guaranteed_talents = enemy_preset.get("talents", [])
        for talent_class_name in guaranteed_talents:
            if hasattr(Talents, talent_class_name):
                talent_class = getattr(Talents, talent_class_name)
                rolled_talents.append(talent_class())
        
        self.enemy = Character(
            id=self.enemy_id, name=enemy_preset["name"], 
            talents=rolled_talents, **enemy_preset["stats"]
        )
        
        self.game.player.on_enter_combat()
        self.enemy.on_enter_combat()
        self.last_update_time = time.time()
        
        for talent in self.game.player.equipped_talents:
            if talent and hasattr(talent, 'on_battle_start'):
                talent.on_battle_start(self.game.player, self.enemy)
        for talent in self.enemy.equipped_talents:
            if talent and hasattr(talent, 'on_battle_start'):
                talent.on_battle_start(self.enemy, self.game.player)

        for eq in self.game.player.all_equipment: eq.on_battle_start(self.game.player)
        for eq in self.enemy.all_equipment: eq.on_battle_start(self.enemy)

    def handle_event(self, event):
        if self.pause_button.handle_event(event) or (event.type == pygame.KEYDOWN and event.key == pygame.K_p):
            self.is_paused = not self.is_paused
            self.pause_button.text = "继续" if self.is_paused else "||"
            if not self.is_paused: self.last_update_time = time.time()
            return

        if self.is_paused: return
        self.log_renderer.handle_event(event)

        from .confirm_dialog import ConfirmDialog
        from .title import TitleScreen
        if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
            def on_confirm_action(): self.game.state_stack = [TitleScreen(self.game)]
            confirm_dialog = ConfirmDialog(self.game, "所有战斗进度都将丢失，确定要返回主菜单吗？", on_confirm_action)
            self.game.state_stack.append(confirm_dialog)

    def _on_victory(self):
            # ### 核心修复：战斗胜利后，清除对手信息 ###
            self.game.player.current_opponent = None
            if hasattr(self, 'enemy'):
                self.enemy.current_opponent = None
            battle_logger.unregister_renderer()

            from .dungeon_screen import DungeonScreen
            from .loot import LootScreen
            # ... (后续的胜利逻辑不变) ...
            next_story_stage_id = None
            if len(self.game.state_stack) > 1 and isinstance(self.game.state_stack[-2], DungeonScreen):
                dungeon_screen = self.game.state_stack[-2]
                if self.origin_id:
                    dungeon_screen.on_monster_defeated(self.origin_id)
            else:
                current_stage_data = self.game.story_data.get(self.game.current_stage, {})
                next_story_stage_id = current_stage_data.get("next_win")

            self.game.state_stack.pop()
            self.game.state_stack.append(LootScreen(self.game, self.enemy, next_story_stage=next_story_stage_id))


    def update(self):
        from .title import TitleScreen

        self._update_hovers()

        if self.is_paused:
            return
            
        now = time.time()
        dt = now - self.last_update_time
        self.last_update_time = now

        if self.battle_ended:
            self.end_timer += dt
            if self.end_timer >= self.END_DELAY:
                if self.enemy.hp <= 0:
                    self._on_victory()
                elif self.game.player.hp <= 0:
                    # ### 核心修复：战斗失败后，也要清除对手信息 ###
                    self.game.player.current_opponent = None
                    if hasattr(self, 'enemy'):
                        self.enemy.current_opponent = None
                    battle_logger.unregister_renderer()
                    self.game.state_stack = [TitleScreen(self.game)]
            return

        for msg in self.game.player.update(dt): self.log_renderer.add_message(msg)
        for msg in self.enemy.update(dt): self.log_renderer.add_message(msg)
        
        player_res = self.game.player.try_attack(self.enemy, dt)
        if player_res:
            log_parts, extra_logs = player_res
            self.log_renderer.add_message(log_parts)
            [self.log_renderer.add_message(f"  └ {e}") for e in extra_logs]
            
        enemy_res = self.enemy.try_attack(self.game.player, dt)
        if enemy_res:
            log_parts, extra_logs = enemy_res
            self.log_renderer.add_message(log_parts)
            [self.log_renderer.add_message(f"  └ {e}") for e in extra_logs]
        
        if self.enemy.hp <= 0 or self.game.player.hp <= 0:
            self.battle_ended = True


    def _update_hovers(self):
        mouse_pos = pygame.mouse.get_pos()
        hovered_object = None
        all_elements = self.player_ui_elements.get('talents', []) + self.player_ui_elements.get('buffs', []) + \
                       self.enemy_ui_elements.get('talents', []) + self.enemy_ui_elements.get('buffs', [])
        for rect, obj in all_elements:
            if rect.collidepoint(mouse_pos):
                hovered_object = obj
                break
        self.tooltip_manager.update(hovered_object)

    def draw(self, surface):
        surface.fill(BG_COLOR)
        
        self.player_ui_elements = draw_character_panel(surface, self.game.player, PLAYER_PANEL_RECT, self.game.fonts)
        self.enemy_ui_elements = draw_character_panel(surface, self.enemy, ENEMY_PANEL_RECT, self.game.fonts)
        
        self._draw_combat_actions(surface, self.game.player, PLAYER_ACTION_PANEL_RECT)
        
        # --- 核心修复：使用新的 log_renderer 属性来绘制日志 ---
        self.log_renderer.draw(surface)
        
        self.pause_button.draw(surface)
        self.tooltip_manager.draw(surface)
        
    def _draw_combat_actions(self, surface, char, rect):
        """(占位符) 绘制角色的战斗行动选项，如技能、道具"""
        draw_panel(surface, rect, "行动", self.game.fonts['normal'])
        text_rect = rect.inflate(-20, -80)
        draw_text(surface, "技能/道具系统\n即将推出!", self.game.fonts['small'], TEXT_COLOR, text_rect)
        


================================================================================
### 文件路径: states\combat_victory.py
================================================================================

# states/combat_victory.py
import pygame
from .base import BaseState
# <-- 导入新的UI工具
from ui import draw_character_panel, draw_panel, Button
from settings import *

class CombatVictoryScreen(BaseState):
    def __init__(self, game, final_enemy):
        super().__init__(game)
        self.final_enemy = final_enemy
        # <-- 新增：创建一个继续按钮
        self.continue_button = Button(
            (SCREEN_WIDTH / 2 - 150, SCREEN_HEIGHT - 100, 300, 60),
            "进入结算",
            self.game.fonts['normal']
        )

    def handle_event(self, event):
        from states.loot import LootScreen
        # <-- 使用按钮的 handle_event 方法
        if self.continue_button.handle_event(event) or \
           (event.type == pygame.KEYDOWN and event.key in [pygame.K_RETURN, pygame.K_SPACE]):
            self.game.state_stack.pop()
            self.game.state_stack.append(LootScreen(self.game))

    def draw(self, surface):
        surface.fill(BG_COLOR)
        # <-- 保持风格统一，继续使用角色面板显示最终状态
        draw_character_panel(surface, self.game.player, PLAYER_PANEL_RECT, self.game.fonts)
        draw_character_panel(surface, self.final_enemy, ENEMY_PANEL_RECT, self.game.fonts)

        # <-- 使用一个面板来显示胜利信息，更有仪式感
        victory_panel_rect = pygame.Rect(SCREEN_WIDTH * 0.25, SCREEN_HEIGHT / 2 - 100, SCREEN_WIDTH * 0.5, 200)
        draw_panel(surface, victory_panel_rect, "战斗胜利！", self.game.fonts['large'])
        
        # <-- 绘制按钮
        self.continue_button.draw(surface)


================================================================================
### 文件路径: states\confirm_dialog.py
================================================================================

# states/confirm_dialog.py
import pygame
from .base import BaseState
from ui import Button, draw_text, draw_panel
from settings import *

class ConfirmDialog(BaseState):
    def __init__(self, game, text, on_confirm):
        super().__init__(game)
        self.is_overlay = True
        self.text = text
        self.on_confirm = on_confirm # 接受一个“确认”后要执行的函数

        # 定义UI元素
        panel_w, panel_h = 600, 300
        self.panel_rect = pygame.Rect((SCREEN_WIDTH - panel_w) / 2, (SCREEN_HEIGHT - panel_h) / 2, panel_w, panel_h)
        
        btn_w, btn_h = 150, 60
        self.yes_button = Button((self.panel_rect.centerx - btn_w - 20, self.panel_rect.bottom - 100, btn_w, btn_h), "确认", self.game.fonts['normal'])
        self.no_button = Button((self.panel_rect.centerx + 20, self.panel_rect.bottom - 100, btn_w, btn_h), "取消", self.game.fonts['normal'])

    def handle_event(self, event):
        if self.yes_button.handle_event(event):
            self.on_confirm() # 执行确认操作
        
        if self.no_button.handle_event(event):
            self.game.state_stack.pop() # 点击“取消”，只弹出自己

        if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
            self.game.state_stack.pop() # 按ESC也视为取消

    def draw(self, surface):
        
        
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))

        # 2. 绘制对话框面板
        draw_panel(surface, self.panel_rect, "请确认", self.game.fonts['large'])
        
        # 3. 绘制提示文字
        text_rect = self.panel_rect.inflate(-80, -80)
        text_rect.h = 100 # 限制文字区域高度
        draw_text(surface, self.text, self.game.fonts['normal'], TEXT_COLOR, text_rect)

        # 4. 绘制按钮
        self.yes_button.draw(surface)
        self.no_button.draw(surface)


================================================================================
### 文件路径: states\dungeon_screen.py
================================================================================

import pygame
import random
from .base import BaseState
from dungeon_generator import Floor
from player_sprite import Player
from monster_sprite import Monster
from treasure_sprite import TreasureChest
import Equips
from settings import *
from ui import Button
from portal_sprite import PortalSprite # <-- 新增这一行

NODE_STYLE = {"start": {"color": (100, 255, 100)},"combat": {"color": (200, 200, 200)}, "event": {"color": (255, 255, 100)},"treasure": {"color": (255, 215, 0)},"elite": {"color": (255, 50, 50)},"boss": {"color": (160, 32, 240)},"rest": {"color": (100, 200, 255)},"shop": {"color": (100, 255, 200)},"forge": {"color": (150, 150, 150)}}

# File: states/dungeon_screen.py

class DungeonScreen(BaseState):
    def __init__(self, game, dungeon_id="sunstone_ruins", floor_number=1):
        super().__init__(game)

        self.dungeon_id = dungeon_id
        self.floor_number = floor_number
        self.dungeon_data = self.game.dungeon_data[dungeon_id]

        self.current_floor_data = None
        for pool in self.dungeon_data.get("floor_pools", []):
            if self.floor_number in pool["floors"]:
                self.current_floor_data = pool
                break

        self.floor = Floor()
        self.floor.generate_floor(num_rooms=8, floor_data=self.current_floor_data)

        self.player = Player(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2)
        self.player_group = pygame.sprite.GroupSingle(self.player)
        self.monster_group = pygame.sprite.Group()
        self.chest_group = pygame.sprite.GroupSingle()
        self.portal_group = pygame.sprite.GroupSingle() # <-- 新增传送门组

        self.door_rects = {}
        # self.exit_portal_button = None <-- 删除这一行

        self.current_room = self.floor.start_room
        self._enter_room(self.current_room)

        backpack_button_rect = pygame.Rect(SCREEN_WIDTH - 160, 10, 140, 50)
        self.backpack_button = Button(backpack_button_rect, "背包 (B)", self.game.fonts['small'])
        talents_button_rect = pygame.Rect(backpack_button_rect.left - 150, 10, 140, 50)
        self.talents_button = Button(talents_button_rect, "天赋 (T)", self.game.fonts['small'])
        
        # 文件: states/dungeon_screen.py (替换这个函数)

    def _enter_room(self, room):
        self.current_room = room
        if not (self.current_room.type == 'boss' and self.current_room.is_cleared):
            self.exit_portal_button = None
        print(f"进入房间 ({room.x}, {room.y}), 类型: {room.type}")

        # --- 核心改动在这里 ---
        room_type = self.current_room.type
        is_cleared = self.current_room.is_cleared

        # 只有未清理过的特殊房间才会触发一次性事件
        if not is_cleared:
            if room_type == "event":
                from .event_screen import EventScreen
                event_id = random.choice(list(self.game.event_data.keys()))
                self.game.state_stack.append(EventScreen(self.game, event_id, self.current_room))
            elif room_type == "shop":
                from .shop_screen import ShopScreen
                self.game.state_stack.append(ShopScreen(self.game, self.current_room))
            
            # --- 新增的分支 ---
            elif room_type == "rest":
                from .rest_screen import RestScreen # 导入我们刚创建的休息界面
                # 弹出休息界面，并把当前房间信息传过去
                self.game.state_stack.append(RestScreen(self.game, self.current_room))

        self._sync_sprites()
        self.door_rects = self._generate_doors()

    def _generate_doors(self):
        if not self.current_room.is_cleared: return {}
        doors = {}; door_size, margin = 60, 10
        if self.current_room.doors["N"]: doors["N"] = pygame.Rect(SCREEN_WIDTH/2 - door_size/2, 0, door_size, margin)
        if self.current_room.doors["S"]: doors["S"] = pygame.Rect(SCREEN_WIDTH/2 - door_size/2, SCREEN_HEIGHT - margin, door_size, margin)
        if self.current_room.doors["W"]: doors["W"] = pygame.Rect(0, SCREEN_HEIGHT/2 - door_size/2, margin, door_size)
        if self.current_room.doors["E"]: doors["E"] = pygame.Rect(SCREEN_WIDTH - margin, SCREEN_HEIGHT/2 - door_size/2, margin, door_size)
        return doors

    # 用这个版本完整替换你的 handle_event 方法
    # 文件: states/dungeon_screen.py (替换 handle_event 方法)
    def handle_event(self, event):
        from .backpack import BackpackScreen
        from .talents_screen import TalentsScreen

        if self.backpack_button.handle_event(event):
            self.game.state_stack.append(BackpackScreen(self.game))
            return

        if self.talents_button.handle_event(event):
            self.game.state_stack.append(TalentsScreen(self.game))
            return

        # --- 旧的传送门按钮点击逻辑已从这里移除 ---

        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_b:
                self.game.state_stack.append(BackpackScreen(self.game))
            elif event.key == pygame.K_t:
                self.game.state_stack.append(TalentsScreen(self.game))

        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            pass # 这里不再需要处理宝箱点击，所以是空的
                            
    def _sync_sprites(self):
        self.monster_group.empty()
        self.chest_group.empty()

        if not self.current_room.is_cleared:
            if self.current_room.type in ["combat", "elite", "boss"]:
                for monster_data in self.current_room.monsters:
                    self.monster_group.add(Monster(monster_data))
            elif self.current_room.type == "treasure":
                self.chest_group.add(TreasureChest(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2))

    def _open_treasure_chest(self, chest_sprite):
        """打开宝箱，并根据当前楼层配置(JSON)生成选项 (带详细调试)"""
        print("--- 进入 _open_treasure_chest 方法 ---")
        
        # 检查点 A: 检查楼层数据是否存在
        if not self.current_floor_data or "treasure_loot" not in self.current_floor_data:
            print(">>> 错误：在dungeon_data.json中未找到当前楼层的 treasure_loot 配置！")
            return

        loot_config = self.current_floor_data["treasure_loot"]
        rarity_weights = loot_config.get("rarity_weights", {"common": 100})
        item_count = loot_config.get("item_count", 2)
        print(f"使用配置: {item_count}个物品, 掉落率: {rarity_weights}")

        # --- 物品生成逻辑 (不变) ---
        item_pool = {rarity: [] for rarity in rarity_weights.keys()}
        all_item_classes = [getattr(Equips, name) for name in dir(Equips) if isinstance(getattr(Equips, name), type) and issubclass(getattr(Equips, name), Equips.Equipment) and getattr(Equips, name) is not Equips.Equipment]
        for item_class in all_item_classes:
            temp_item = item_class()
            if hasattr(temp_item, 'rarity') and temp_item.rarity in item_pool:
                item_pool[temp_item.rarity].append(item_class)
        
        rarities_to_spawn = random.choices(list(rarity_weights.keys()), weights=list(rarity_weights.values()), k=item_count)
        choices = []
        for rarity in rarities_to_spawn:
            if item_pool.get(rarity):
                item_class = random.choice(item_pool[rarity])
                choices.append(item_class())
        
        # 检查点 B: 检查是否成功生成了物品
        print(f"成功生成了 {len(choices)} 个物品选项。")

        if not choices:
            print(">>> 错误: 未能生成任何物品！方法提前退出。")
            self.current_room.is_cleared = True
            self.door_rects = self._generate_doors()
            chest_sprite.kill()
            return

        # 检查点 C: 准备弹出选择界面
        print(f"准备弹出选择界面，物品为: {[getattr(c, 'display_name', '未知') for c in choices]}")
        from .choice_screen import ChoiceScreen
        self.game.state_stack.append(ChoiceScreen(self.game, choices, self.current_room))
        
        # 检查点 D: 确认界面已弹出
        print(">>> 选择界面已弹出到状态栈。 killing chest...")
        
        chest_sprite.kill()

    def on_monster_defeated(self, defeated_monster_uid):
        self.current_room.monsters = [m for m in self.current_room.monsters if m['uid'] != defeated_monster_uid]
        self._sync_sprites()
        if not self.current_room.monsters:
            self.current_room.is_cleared = True
            self.door_rects = self._generate_doors()
            if self.current_room.type == "boss":
                # 不再创建按钮，而是创建传送门精灵并添加到组里
                self.portal_group.add(PortalSprite(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2))
                
    # 文件: states/dungeon_screen.py (替换 update 方法)
    def update(self):
        self.player_group.update()

        if not self.current_room.is_cleared:
            # 检查与怪物的碰撞
            collided_monster = pygame.sprite.spritecollideany(self.player, self.monster_group)
            if collided_monster:
                from .combat import CombatScreen
                self.game.state_stack.append(CombatScreen(self.game, collided_monster.enemy_id, collided_monster.uid))
                self.monster_group.empty()
                return

            # 检查与宝箱的碰撞
            collided_chest = pygame.sprite.spritecollideany(self.player, self.chest_group)
            if collided_chest:
                self._open_treasure_chest(collided_chest)
                return

        else: # 房间已清理
            # --- 核心修改在这里 ---
            # 检查与传送门的碰撞
            collided_portal = pygame.sprite.spritecollideany(self.player, self.portal_group)
            if collided_portal:
                print("进入下一层！")
                next_floor_number = self.floor_number + 1
                self.game.state_stack.pop()
                self.game.state_stack.append(DungeonScreen(self.game, self.dungeon_id, next_floor_number))
                return
            # --- 修改结束 ---

            # 检查与门的碰撞
            for direction, door_rect in self.door_rects.items():
                if self.player.rect.colliderect(door_rect):
                    self._change_room(direction)
                    break
                
    def _change_room(self, direction):
        x, y = self.current_room.x, self.current_room.y; next_room_coord = None
        if direction == "N": next_room_coord = (x, y - 1)
        if direction == "S": next_room_coord = (x, y + 1)
        if direction == "W": next_room_coord = (x - 1, y)
        if direction == "E": next_room_coord = (x + 1, y)
        if next_room_coord in self.floor.rooms:
            next_room = self.floor.rooms[next_room_coord]; self._enter_room(next_room)
            if direction == "N": self.player.rect.bottom = SCREEN_HEIGHT - 15
            if direction == "S": self.player.rect.top = 15
            if direction == "W": self.player.rect.right = SCREEN_WIDTH - 15
            if direction == "E": self.player.rect.left = 15

    # 文件: states/dungeon_screen.py (替换 draw 方法)
    def draw(self, surface):
        surface.fill(BG_COLOR)
        for door_rect in self.door_rects.values(): pygame.draw.rect(surface, (100, 200, 100), door_rect)

        # if self.exit_portal_button: self.exit_portal_button.draw(surface) <-- 删除这行
        self.portal_group.draw(surface) # <-- 新增这行，绘制传送门精灵

        self.monster_group.draw(surface)
        self.chest_group.draw(surface)
        self.player_group.draw(surface)
        self._draw_minimap(surface)
        self.backpack_button.draw(surface)
        self.talents_button.draw(surface)
        
    def _draw_minimap(self, surface):
        minimap_rect = pygame.Rect(10, 10, 230, 230)
        pygame.draw.rect(surface, PANEL_BG_COLOR, minimap_rect); pygame.draw.rect(surface, PANEL_BORDER_COLOR, minimap_rect, 2)
        cell_size = 15
        for (x, y), room in self.floor.rooms.items():
            map_x, map_y = minimap_rect.x + x*cell_size + 5, minimap_rect.y + y*cell_size + 5
            cell_rect = pygame.Rect(map_x, map_y, cell_size - 1, cell_size - 1)
            base_color = NODE_STYLE.get(room.type, {"color": (255,255,255)})["color"]
            final_color = base_color
            if not room.is_cleared and room.type != "start":
                final_color = (base_color[0] // 2, base_color[1] // 2, base_color[2] // 2)
            pygame.draw.rect(surface, final_color, cell_rect)
            if room is self.current_room:
                p1 = (cell_rect.centerx, cell_rect.top + 3); p2 = (cell_rect.left + 3, cell_rect.bottom - 3); p3 = (cell_rect.right - 3, cell_rect.bottom - 3)
                pygame.draw.polygon(surface, (255, 255, 255, 200), [p1, p2, p3])


================================================================================
### 文件路径: states\event_screen.py
================================================================================

# states/event_screen.py
import pygame
import random
from .base import BaseState
from ui import Button, draw_panel, draw_text
from settings import *
import Talents # 导入天赋模块

class EventScreen(BaseState):
    def __init__(self, game, event_id, origin_room):
        super().__init__(game)
        self.is_overlay = True
        self.event_data = self.game.event_data[event_id]
        self.origin_room = origin_room
        
        # 界面状态管理：'choosing' (选择中) 或 'showing_result' (显示结果)
        self.view_mode = 'choosing' 
        self.result_text = ""
        
        self._setup_ui()

    def _setup_ui(self):
        # 面板
        panel_w, panel_h = 800, 500
        self.panel_rect = pygame.Rect((SCREEN_WIDTH - panel_w) / 2, (SCREEN_HEIGHT - panel_h) / 2, panel_w, panel_h)
        
        # 选项按钮
        self.choice_buttons = []
        btn_w, btn_h = 600, 60
        num_choices = len(self.event_data["choices"])
        start_y = self.panel_rect.bottom - (btn_h + 20) * num_choices - 20
        
        for i, choice in enumerate(self.event_data["choices"]):
            rect = pygame.Rect(self.panel_rect.centerx - btn_w / 2, start_y + i * (btn_h + 20), btn_w, btn_h)
            self.choice_buttons.append(Button(rect, choice["text"], self.game.fonts['normal']))
            
        # “继续”按钮（用于显示结果后）
        self.continue_button = Button(self.choice_buttons[-1].rect, "继续...", self.game.fonts['normal'])

    def handle_event(self, event):
        if self.view_mode == 'choosing':
            for i, button in enumerate(self.choice_buttons):
                if button.handle_event(event):
                    self._process_choice(i)
                    return
        elif self.view_mode == 'showing_result':
            if self.continue_button.handle_event(event):
                self._leave_event()

    # 在 states/event_screen.py 文件中，找到并替换这个函数

    def _process_choice(self, choice_index):
        """处理玩家的选择并计算结果"""
        choice_data = self.event_data["choices"][choice_index]
        outcomes = choice_data["outcomes"]
        
        rand_val = random.random()
        cumulative_chance = 0.0
        selected_outcome = None
        for outcome in outcomes:
            cumulative_chance += outcome.get("chance", 1.0)
            if rand_val < cumulative_chance:
                selected_outcome = outcome
                break
        
        if not selected_outcome: return

        outcome_type = selected_outcome["type"]
        self.result_text = selected_outcome["result_text"]
        
        player = self.game.player
        if outcome_type == "HEAL":
            if selected_outcome["amount"] == "full":
                player.hp = player.max_hp
        
        elif outcome_type == "WEAPON_UPGRADE":
            player.base_attack += 5
            player.attack += 5
        
        elif outcome_type == "WEAPON_CURSE":
            player.base_attack = max(1, player.base_attack - 3)
            player.attack = max(1, player.attack - 3)
            
        # --- 核心修复：使用新的天赋学习和装备逻辑 ---
        elif outcome_type == "GAIN_TALENT":
            talent_class_name = selected_outcome["talent_class_name"]
            if hasattr(Talents, talent_class_name):
                talent_instance = getattr(Talents, talent_class_name)()
                
                # 1. 尝试学习新天赋
                was_new = player.learn_talent(talent_instance)
                
                if was_new:
                    # 2. 如果是新学会的，尝试自动装备它
                    was_equipped = player.equip_talent(talent_instance)
                    if not was_equipped:
                        self.result_text += " (天赋槽已满，请在天赋界面(T)手动装备)"
                else:
                    self.result_text = "你似乎已经领悟过类似的能力了..."

        elif outcome_type == "TRIGGER_COMBAT":
            from .combat import CombatScreen
            enemy_id = selected_outcome["enemy_id"]
            self._leave_event()
            # 剧情战斗不需要 origin_id
            self.game.state_stack.append(CombatScreen(self.game, enemy_id)) 
            return
            
        self.view_mode = 'showing_result'

    def _leave_event(self):
        """离开事件，更新地图并关闭界面"""
        from .dungeon_screen import DungeonScreen
        self.origin_room.is_cleared = True
        if len(self.game.state_stack) > 1:
            prev_state = self.game.state_stack[-2]
            if isinstance(prev_state, DungeonScreen):
                prev_state.door_rects = prev_state._generate_doors()
        self.game.state_stack.pop()

    def draw(self, surface):
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180)); surface.blit(overlay, (0, 0))
        
        draw_panel(surface, self.panel_rect, self.event_data["title"], self.game.fonts['large'])
        
        if self.view_mode == 'choosing':
            desc_rect = self.panel_rect.inflate(-80, -250)
            desc_rect.top = self.panel_rect.top + 100
            draw_text(surface, self.event_data["description"], self.game.fonts['normal'], TEXT_COLOR, desc_rect)
            for button in self.choice_buttons:
                button.draw(surface)
        elif self.view_mode == 'showing_result':
            result_rect = self.panel_rect.inflate(-80, -250)
            result_rect.top = self.panel_rect.top + 150
            draw_text(surface, self.result_text, self.game.fonts['normal'], HOVER_COLOR, result_rect)
            self.continue_button.draw(surface)


================================================================================
### 文件路径: states\loading.py
================================================================================

# states/loading.py
import pygame
import time
from .base import BaseState
from ui import draw_text, Button
from settings import *

class LoadScreen(BaseState):
    def __init__(self, game):
        super().__init__(game)
        self.back_button = Button((SCREEN_WIDTH / 2 - 150, SCREEN_HEIGHT - 100, 300, 60), "返回", self.game.fonts['normal'])
        self.slot_rects = [pygame.Rect(100, 120 + i * 50, SCREEN_WIDTH - 200, 50) for i in range(10)]
        self.load_fail_message = None

    def handle_event(self, event):
        if self.back_button.handle_event(event) or (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
            self.game.state_stack.pop()
            return

        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            for i, rect in enumerate(self.slot_rects):
                if rect.collidepoint(event.pos):
                    # --- 这是核心修复 ---
                    # load_from_slot 会更新 self.game 的 player, current_stage 等
                    if self.game.load_from_slot(i):
                        from states.story import StoryScreen
                        # 清空整个状态栈，然后压入一个新的、基于已加载数据的 StoryScreen
                        self.game.state_stack = [StoryScreen(self.game)]
                    else:
                        self.load_fail_message = f"槽位 {i} 为空或损坏！"
                    return
                    # --- 修复结束 ---

    def draw(self, surface):
        surface.fill(BG_COLOR)
        title_font = self.game.fonts['large']
        draw_text(surface, "选择要加载的存档", title_font, TEXT_COLOR, pygame.Rect(0, 50, SCREEN_WIDTH, 100))

        for i, rect in enumerate(self.slot_rects):
            slot_data = self.game.peek_save_slot(i)
            is_hovered = rect.collidepoint(pygame.mouse.get_pos())
            if is_hovered:
                pygame.draw.rect(surface, PANEL_BORDER_COLOR, rect.inflate(10, 10), 2, border_radius=5)
            
            text = f"{i}. " + ("(自动)" if i == 0 else "")
            if slot_data and slot_data.get("player"):
                player = slot_data["player"]
                save_time = time.strftime('%Y-%m-%d %H:%M', time.localtime(slot_data.get("timestamp", 0)))
                text += f"{player.name} - 等级 {player.level} ({save_time})"
            else:
                text += "-- 空 --"
            draw_text(surface, text, self.game.fonts['normal'], TEXT_COLOR, rect)

        if self.load_fail_message:
            fail_rect = pygame.Rect(0, SCREEN_HEIGHT - 150, SCREEN_WIDTH, 40)
            draw_text(surface, self.load_fail_message, self.game.fonts['normal'], (255, 100, 100), fail_rect)

        self.back_button.draw(surface)


================================================================================
### 文件路径: states\loot.py
================================================================================

# states/loot.py (已修正)
import pygame
import random
from .base import BaseState
from ui import draw_panel, draw_text
from settings import *
import Equips
from Character import Character # 需要导入Character类用于类型检查

class LootScreen(BaseState):
    def __init__(self, game, defeated_enemy_object=None, next_story_stage=None):
        super().__init__(game)
        self.is_overlay = True

        # --- 核心修改在这里 ---
        # defeated_enemy_object 现在是完整的敌人对象
        self.defeated_enemy_object = defeated_enemy_object
        # 我们仍然需要 enemy_id 来查询装备掉落表
        self.defeated_enemy_id = defeated_enemy_object.id if isinstance(defeated_enemy_object, Character) else None

        self.next_story_stage = next_story_stage

        panel_w = SCREEN_WIDTH * 0.7
        panel_h = SCREEN_HEIGHT * 0.7
        self.panel_rect = pygame.Rect(
            (SCREEN_WIDTH - panel_w) / 2,
            (SCREEN_HEIGHT - panel_h) / 2,
            panel_w, panel_h
        )
        self._process_rewards()

    def _process_rewards(self):
        self.exp_messages = []
        if self.defeated_enemy_id:
            enemy_preset = self.game.enemy_data.get(self.defeated_enemy_id, {})
            self.exp_messages = self.game.player.add_exp(enemy_preset.get("exp_reward", 0))
        
        self.loot_messages = self._generate_loot()
        self.game.save_to_slot(0)
        
    # 文件: states/loot.py (替换这个函数)

    # 文件: states/loot.py (替换这个函数)

    def _generate_loot(self):
        messages = []
        found_any_loot = False
        
        # --- Part 1: 装备掉落逻辑 ---
        if self.defeated_enemy_id:
            equipment_drops = self.game.loot_data.get(self.defeated_enemy_id, [])
            if equipment_drops:
                equipment_header_added = False
                for drop_info in equipment_drops:
                    if random.random() < drop_info.get("chance", 1.0):
                        if not equipment_header_added:
                            messages.append("--- 战利品 ---")
                            equipment_header_added = True
                        
                        found_any_loot = True
                        item_class_name = drop_info["item_class_name"]
                        try:
                            item_class = getattr(Equips, item_class_name)
                            new_item = item_class()
                            display_name = getattr(new_item, 'display_name', item_class_name)
                            feedback = self.game.player.pickup_item(new_item)
                            if "放入你的背包" in feedback:
                                messages.append(f"获得了装备：{display_name}！")
                            else:
                                messages.append(feedback)
                        except AttributeError:
                            messages.append(f"错误：未找到物品 {item_class_name}。")

        # --- Part 2: 天赋掉落逻辑 ---
        import Talents
        if self.defeated_enemy_object and self.defeated_enemy_object.equipped_talents:
            talent_header_added = False
            for possessed_talent in self.defeated_enemy_object.equipped_talents:
                
                # --- 核心修复：在处理前，先确保这个槽位里的天赋不是空的 (None) ---
                if possessed_talent and random.random() < 0.15: # 15% 的掉落率
                    was_new = self.game.player.learn_talent(possessed_talent)
                    if was_new:
                        if not talent_header_added:
                            messages.append("--- 能力领悟 ---")
                            talent_header_added = True
                            
                        found_any_loot = True
                        messages.append(f"你从敌人身上领悟了「{possessed_talent.display_name}」！")

        # --- Part 3: 最终总结 ---
        if not found_any_loot:
            messages.append("敌人没有留下任何有价值的东西。")
            
        return messages

    def handle_event(self, event):
        if (event.type == pygame.MOUSEBUTTONDOWN and event.button == 1) or \
           (event.type == pygame.KEYDOWN and event.key in [pygame.K_RETURN, pygame.K_SPACE]):
            
            if self.next_story_stage:
                from .story import StoryScreen
                self.game.current_stage = self.next_story_stage
                self.game.state_stack.pop()
                if self.game.state_stack and isinstance(self.game.state_stack[-1], StoryScreen):
                    self.game.state_stack.pop()
                self.game.state_stack.append(StoryScreen(self.game))
            else:
                self.game.state_stack.pop()

    def draw(self, surface):
        # 绘制底层界面
        if len(self.game.state_stack) > 1:
            self.game.state_stack[-2].draw(surface)
        
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180)); surface.blit(overlay, (0, 0))
        
        # --- 核心修复：使用 self.panel_rect ---
        title = "战斗胜利" if self.defeated_enemy_id else "打开宝箱"
        draw_panel(surface, self.panel_rect, title, self.game.fonts['large'])
        
        all_messages = self.exp_messages + self.loot_messages
        current_y = self.panel_rect.top + 120
        for line in all_messages:
            clean_line = line.replace("🎉 ", "")
            text_surf = self.game.fonts['normal'].render(clean_line, True, TEXT_COLOR)
            text_rect = text_surf.get_rect(center=(self.panel_rect.centerx, current_y))
            surface.blit(text_surf, text_rect); current_y += 35
            
        prompt_surf = self.game.fonts['small'].render("点击任意处继续...", True, TEXT_COLOR)
        prompt_rect = prompt_surf.get_rect(center=(self.panel_rect.centerx, self.panel_rect.bottom - 40))
        surface.blit(prompt_surf, prompt_rect)


================================================================================
### 文件路径: states\notification_screen.py
================================================================================

# states/notification_screen.py
import pygame
from .base import BaseState
from ui import draw_text
from settings import *

class NotificationScreen(BaseState):
    def __init__(self, game, message, duration=2.0):
        super().__init__(game)
        self.is_overlay = True
        self.message = message
        self.duration = duration # 秒
        self.start_time = pygame.time.get_ticks()

    def update(self):
        # 计时结束，自动关闭
        if pygame.time.get_ticks() - self.start_time > self.duration * 1000:
            self.game.state_stack.pop()

    def draw(self, surface):
        # 创建一个位于屏幕底部中央的对话框
        box_width = 600
        box_height = 80
        box_rect = pygame.Rect(
            (SCREEN_WIDTH - box_width) / 2,
            SCREEN_HEIGHT - box_height - 30, # 离底部30像素
            box_width,
            box_height
        )
        
        # 绘制半透明背景
        bg_surface = pygame.Surface(box_rect.size, pygame.SRCALPHA)
        bg_surface.fill((20, 35, 50, 200)) # 使用面板背景色，带透明度
        surface.blit(bg_surface, box_rect.topleft)
        pygame.draw.rect(surface, PANEL_BORDER_COLOR, box_rect, 2, border_radius=10)

        # 绘制消息文本
        draw_text(surface, self.message, self.game.fonts['normal'], TEXT_COLOR, box_rect)


================================================================================
### 文件路径: states\rest_screen.py
================================================================================

# 文件: states/rest_screen.py (新文件)

import pygame
import random
from .base import BaseState
from ui import Button, draw_panel, draw_text
from settings import *

class RestScreen(BaseState):

    def __init__(self, game, origin_room):
        super().__init__(game)
        self.is_overlay = True
        self.origin_room = origin_room

        self.rest_used = False
        self.forge_used = False
        self.feedback_message = ""

        # --- 核心修改在这里 ---
        from Equips import UPGRADE_MAP 

        # 1. 创建一个包含玩家所有物品（已装备的 + 背包里的）的总列表
        all_player_items = self.game.player.all_equipment + self.game.player.backpack

        # 2. 从这个总列表中，筛选出所有可以被升级的物品
        self.upgradable_items = [
            item for item in all_player_items
            if item.__class__ in UPGRADE_MAP
        ]

        self._setup_ui()

    def _setup_ui(self):
        """初始化用户界面元素"""
        panel_w, panel_h = 800, 500
        self.panel_rect = pygame.Rect((SCREEN_WIDTH - panel_w) / 2, (SCREEN_HEIGHT - panel_h) / 2, panel_w, panel_h)

        # 定义两个核心选项按钮的位置
        btn_w, btn_h = 300, 180
        spacing = 50
        start_x = self.panel_rect.centerx - (btn_w * 2 + spacing) / 2

        self.rest_button = Button(
            (start_x, self.panel_rect.centery - btn_h/2, btn_w, btn_h),
            "休息", # 按钮的初始文字
            self.game.fonts['large']
        )
        self.forge_button = Button(
            (start_x + btn_w + spacing, self.panel_rect.centery - btn_h/2, btn_w, btn_h),
            "锻造",
            self.game.fonts['large']
        )
        
        # 离开按钮
        self.leave_button = Button(
            (self.panel_rect.centerx - 150, self.panel_rect.bottom - 100, 300, 60),
            "离开",
            self.game.fonts['normal']
        )

    def handle_event(self, event):
        """处理玩家的输入事件"""
        # --- 休息按钮的逻辑 (不变) ---
        if not self.rest_used and self.rest_button.handle_event(event):
            self.rest_used = True
            heal_amount = int(self.game.player.max_hp * 0.3)
            self.game.player.heal(heal_amount)
            self.feedback_message = f"你恢复了 {heal_amount} 点生命！"
            self.forge_used = True # 休息和锻造二选一
            return

        # --- 全新的、更强大的锻造逻辑 ---
        if not self.forge_used and len(self.upgradable_items) > 0 and self.forge_button.handle_event(event):
            self.forge_used = True
            self.rest_used = True # 休息和锻造二选一

            player = self.game.player

            # 1. 从可升级列表中随机选一件 (现在这个列表包含了背包物品)
            item_to_upgrade = random.choice(self.upgradable_items)
            item_name = getattr(item_to_upgrade, 'display_name', '装备')

            from Equips import UPGRADE_MAP
            upgraded_class = UPGRADE_MAP.get(item_to_upgrade.__class__)

            if upgraded_class:
                # 2. 创建升级后的新装备实例
                upgraded_item = upgraded_class()

                # 3. 从原来的位置移除旧装备
                #    检查它是在身上还是在背包里
                if item_to_upgrade in player.all_equipment:
                    player.unequip(item_to_upgrade)
                elif item_to_upgrade in player.backpack:
                    player.backpack.remove(item_to_upgrade)

                # 4. 将锻造好的新装备放入背包
                #    我们使用 pickup_item 方法，因为它能自动处理重复物品转化为金币的逻辑
                feedback = player.pickup_item(upgraded_item)
                if "放入你的背包" in feedback:
                    self.feedback_message = f"锻造成功！新的「{upgraded_item.display_name}」已放入你的背包！"
                else: # 如果玩家已经有升级版的装备了，会自动转化成金币
                    self.feedback_message = f"锻造成功！但你已拥有同名装备，转化为金币！"

            else:
                self.feedback_message = f"「{item_name}」似乎无法被强化..."

            return

        # --- 处理离开按钮 (不变) ---
        if self.leave_button.handle_event(event):
            self._leave_room()
            
    def _leave_room(self):
        """处理离开休息室的逻辑"""
        from .dungeon_screen import DungeonScreen
        # 标记这个房间为“已探索完毕”
        self.origin_room.is_cleared = True
        
        # 更新地牢界面，让出口的门显示出来
        if len(self.game.state_stack) > 1:
            prev_state = self.game.state_stack[-2]
            if isinstance(prev_state, DungeonScreen):
                prev_state.door_rects = prev_state._generate_doors()
        
        # 将自己从状态栈中弹出，返回地牢界面
        self.game.state_stack.pop()

    def draw(self, surface):
        """绘制所有UI元素到屏幕上"""
        # 绘制半透明的背景遮罩
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))

        # 绘制主面板
        draw_panel(surface, self.panel_rect, "篝火旁的쉼터", self.game.fonts['large'])

        # --- 绘制休息按钮和描述 ---
        self.rest_button.draw(surface)
        rest_desc = "恢复30%最大生命值"
        rest_desc_rect = self.rest_button.rect.copy()
        rest_desc_rect.y += 190 # 调整描述文本的位置
        draw_text(surface, rest_desc, self.game.fonts['small'], TEXT_COLOR, rest_desc_rect)
        if self.rest_used: # 如果已使用，绘制一个遮罩
            s = pygame.Surface(self.rest_button.rect.size, pygame.SRCALPHA)
            s.fill((50,50,50,180))
            surface.blit(s, self.rest_button.rect.topleft)

        # --- 绘制锻造按钮和描述 ---
        self.forge_button.draw(surface)
        forge_desc = "随机强化一件装备"
        if len(self.upgradable_items) == 0:
            forge_desc = "没有可强化的装备"
        forge_desc_rect = self.forge_button.rect.copy()
        forge_desc_rect.y += 190
        draw_text(surface, forge_desc, self.game.fonts['small'], TEXT_COLOR, forge_desc_rect)
        if self.forge_used or len(self.upgradable_items) == 0: # 如果已使用或没有装备，绘制遮罩
            s = pygame.Surface(self.forge_button.rect.size, pygame.SRCALPHA)
            s.fill((50,50,50,180))
            surface.blit(s, self.forge_button.rect.topleft)

        # 绘制操作反馈信息
        if self.feedback_message:
            feedback_rect = pygame.Rect(0, self.panel_rect.top + 100, self.panel_rect.width, 40)
            feedback_rect.centerx = self.panel_rect.centerx
            draw_text(surface, self.feedback_message, self.game.fonts['normal'], HOVER_COLOR, feedback_rect)

        # 绘制离开按钮
        self.leave_button.draw(surface)


================================================================================
### 文件路径: states\sandbox_screen.py
================================================================================

# 文件: states/sandbox_screen.py (新文件)

import pygame
import inspect
from .base import BaseState
from ui import Button, draw_panel, draw_text
from settings import *
from Character import Character
import Equips
import Talents

class SandboxScreen(BaseState):
# 文件: states/sandbox_screen.py (替换这个函数)

    def __init__(self, game):
        super().__init__(game)
        
        # --- 核心修改：同样使用 PLAYER_BASE_STATS 来创建测试角色 ---
        self.sandbox_player = Character(
            "测试英雄",
            **PLAYER_BASE_STATS # <-- 使用我们定义的标准属性
        )
        
        # 2. 解锁所有装备到背包
        all_equipment_classes = [cls for name, cls in inspect.getmembers(Equips, inspect.isclass) if issubclass(cls, Equips.Equipment) and cls is not Equips.Equipment]
        for eq_class in all_equipment_classes:
            self.sandbox_player.backpack.append(eq_class())
            
        # 3. 解锁所有天赋
        all_talent_classes = [cls for name, cls in inspect.getmembers(Talents, inspect.isclass) if issubclass(cls, Talents.Talent) and cls is not Talents.Talent]
        for talent_class in all_talent_classes:
            self.sandbox_player.learn_talent(talent_class())

        # 4. 设置UI
        self.enemy_ids = list(self.game.enemy_data.keys())
        self.selected_enemy_index = 0
        
        self._setup_ui()

# 文件: states/sandbox_screen.py (替换这三个函数)

    def _setup_ui(self):
        # 按钮定义
        self.backpack_button = Button((100, 150, 300, 60), "配置背包", self.game.fonts['normal'])
        self.talents_button = Button((100, 230, 300, 60), "配置天赋", self.game.fonts['normal'])
        
        # --- 新增：等级控制按钮 ---
        level_y = self.talents_button.rect.bottom + 40
        self.level_down_button = Button((100, level_y, 60, 60), "-", self.game.fonts['large'])
        self.level_up_button = Button((100 + 240, level_y, 60, 60), "+", self.game.fonts['large'])
        # --- 新增结束 ---

        self.start_combat_button = Button((100, 450, 300, 80), "开始战斗", self.game.fonts['large'])
        self.back_button = Button((20, 20, 100, 50), "返回", self.game.fonts['small'])

        # 敌人选择器
        self.prev_enemy_button = Button((SCREEN_WIDTH - 450, 250, 50, 50), "<", self.game.fonts['normal'])
        self.next_enemy_button = Button((SCREEN_WIDTH - 100, 250, 50, 50), ">", self.game.fonts['normal'])
        
    def handle_event(self, event):
        from .backpack import BackpackScreen
        from .talents_screen import TalentsScreen
        from .combat import CombatScreen

        if self.back_button.handle_event(event):
            self.game.state_stack.pop()
            return
            
        if self.backpack_button.handle_event(event):
            self.game.state_stack.append(BackpackScreen(self.game, player_override=self.sandbox_player))
            return
            
        if self.talents_button.handle_event(event):
            self.game.state_stack.append(TalentsScreen(self.game, player_override=self.sandbox_player))
            return

        # --- 新增：处理等级控制按钮的点击事件 ---
        if self.level_up_button.handle_event(event):
            self.sandbox_player.gain_level()
            return
        
        if self.level_down_button.handle_event(event):
            self.sandbox_player.lose_level()
            return
        # --- 新增结束 ---
            
        if self.prev_enemy_button.handle_event(event):
            self.selected_enemy_index = (self.selected_enemy_index - 1 + len(self.enemy_ids)) % len(self.enemy_ids)
        
        if self.next_enemy_button.handle_event(event):
            self.selected_enemy_index = (self.selected_enemy_index + 1) % len(self.enemy_ids)

        if self.start_combat_button.handle_event(event):
            original_player = self.game.player
            self.game.player = self.sandbox_player
            selected_enemy_id = self.enemy_ids[self.selected_enemy_index]
            self.game.state_stack.append(CombatScreen(self.game, selected_enemy_id))
            return

    def draw(self, surface):
        surface.fill(BG_COLOR)
        draw_panel(surface, pygame.Rect(50, 50, 400, SCREEN_HEIGHT - 100), "配置角色", self.game.fonts['large'])
        draw_panel(surface, pygame.Rect(SCREEN_WIDTH - 500, 50, 450, SCREEN_HEIGHT - 100), "选择敌人", self.game.fonts['large'])

        # 绘制按钮
        self.backpack_button.draw(surface)
        self.talents_button.draw(surface)
        self.start_combat_button.draw(surface)
        self.back_button.draw(surface)
        self.prev_enemy_button.draw(surface)
        self.next_enemy_button.draw(surface)
        
        # --- 新增：绘制等级控制器 ---
        self.level_up_button.draw(surface)
        self.level_down_button.draw(surface)
        
        # 绘制当前等级文本
        level_text = f"等级: {self.sandbox_player.level}"
        level_rect = pygame.Rect(self.level_down_button.rect.right, self.level_down_button.rect.top, 
                                 self.level_up_button.rect.left - self.level_down_button.rect.right, 60)
        draw_text(surface, level_text, self.game.fonts['large'], TEXT_COLOR, level_rect)
        # --- 新增结束 ---

        # 绘制当前选择的敌人
        selected_enemy_id = self.enemy_ids[self.selected_enemy_index]
        enemy_name = self.game.enemy_data[selected_enemy_id]['name']
        enemy_rect = pygame.Rect(self.prev_enemy_button.rect.right, self.prev_enemy_button.rect.top, 
                                 self.next_enemy_button.rect.left - self.prev_enemy_button.rect.right, 50)
        draw_text(surface, enemy_name, self.game.fonts['large'], TEXT_COLOR, enemy_rect)


================================================================================
### 文件路径: states\saving.py
================================================================================

# states/saving.py
import pygame
import time
from .base import BaseState
from ui import draw_text, Button
from settings import *

class SaveScreen(BaseState):
    def __init__(self, game):
        super().__init__(game)
        self.back_button = Button((SCREEN_WIDTH / 2 - 150, SCREEN_HEIGHT - 100, 300, 60), "返回", self.game.fonts['normal'])
        self.slot_rects = [pygame.Rect(100, 120 + (i-1) * 50, SCREEN_WIDTH - 200, 50) for i in range(1, 10)]
        self.feedback_message = None
        self.feedback_timer = 0

    def update(self):
        if self.feedback_message and pygame.time.get_ticks() - self.feedback_timer > 2000:
            self.feedback_message = None

    def handle_event(self, event):
        if self.back_button.handle_event(event) or (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
            self.game.state_stack.pop()
            return

        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            for i, rect in enumerate(self.slot_rects, 1):
                if rect.collidepoint(event.pos):
                    self.feedback_message = self.game.save_to_slot(i)
                    self.feedback_timer = pygame.time.get_ticks()
                    return

    def draw(self, surface):
        surface.fill(BG_COLOR)
        title_font = self.game.fonts['large']
        draw_text(surface, "选择要覆盖的存档槽", title_font, TEXT_COLOR, pygame.Rect(0, 50, SCREEN_WIDTH, 100))

        for i, rect in enumerate(self.slot_rects, 1):
            slot_data = self.game.peek_save_slot(i) # <-- 使用 peek_save_slot
            is_hovered = rect.collidepoint(pygame.mouse.get_pos())
            if is_hovered:
                pygame.draw.rect(surface, PANEL_BORDER_COLOR, rect.inflate(10, 10), 2, border_radius=5)
            
            text = f"{i}. "
            if slot_data and slot_data.get("player"):
                player = slot_data["player"]
                save_time = time.strftime('%Y-%m-%d %H:%M', time.localtime(slot_data.get("timestamp", 0)))
                text += f"{player.name} - 等级 {player.level} ({save_time})"
            else:
                text += "-- 空 --"
            draw_text(surface, text, self.game.fonts['normal'], TEXT_COLOR, rect)

        if self.feedback_message:
            feedback_rect = pygame.Rect(0, SCREEN_HEIGHT - 150, SCREEN_WIDTH, 40)
            draw_text(surface, self.feedback_message, self.game.fonts['normal'], (100, 255, 100), feedback_rect)
        
        self.back_button.draw(surface)


================================================================================
### 文件路径: states\shop_screen.py
================================================================================


# states/shop_screen.py (现代化重写版本，已补全)
import pygame
import random
import math
import inspect
from .base import BaseState
from ui import Button, TooltipManager
from settings import *
import Equips

# 安全获取 RARITY_COLORS（防止 settings 未定义时崩溃）
_DEFAULT_RARITY_COLORS = {
    "common": (180, 180, 180),
    "uncommon": (80, 200, 120),
    "rare": (80, 160, 255),
    "epic": (180, 80, 255),
    "legendary": (255, 180, 60),
}
try:
    RARITY_COLORS = dict(RARITY_COLORS)  # type: ignore
except Exception:
    RARITY_COLORS = _DEFAULT_RARITY_COLORS

RARITY_PRICES = {"common": 50, "uncommon": 100, "rare": 250, "epic": 500, "legendary": 1000}

class ShopScreen(BaseState):
    def __init__(self, game, origin_room):
        super().__init__(game)
        self.is_overlay = True
        self.origin_room = origin_room
        self.shop_items = []
        self.feedback_message = ""
        self.feedback_timer = 0
        
        # 动画系统
        self.hover_animations = {}
        self.glow_animation = 0.0
        self.entrance_animation = 0.0
        self.coin_particles = []
        self.card_bounce_offsets = []
        
        self.tooltip_manager = TooltipManager(self._get_font('small', 16))
        
        self._generate_inventory()
        self._setup_ui()

    def _get_font(self, font_name, default_size=20):
        """安全获取字体"""
        try:
            if hasattr(self.game, 'fonts') and font_name in self.game.fonts:
                return self.game.fonts[font_name]
        except Exception:
            pass
        return pygame.font.Font(None, default_size)

    def _generate_inventory(self):
        """生成商店物品"""
        all_item_classes = [getattr(Equips, name) for name in dir(Equips) 
                           if isinstance(getattr(Equips, name), type) 
                           and issubclass(getattr(Equips, name), Equips.Equipment) 
                           and getattr(Equips, name) is not Equips.Equipment]
        
        choices = random.sample(all_item_classes, min(4, len(all_item_classes)))  # 4个商品
        
        for item_class in choices:
            item = item_class()
            rarity = getattr(item, 'rarity', 'common')
            base_price = RARITY_PRICES.get(rarity, 9999)
            # 添加价格波动
            price_variation = random.uniform(0.85, 1.15)
            price = int(base_price * price_variation)
            self.shop_items.append([None, item, price, False])

    def _setup_ui(self):
        """设置UI布局"""
        # 动态调整面板大小
        num_items = len(self.shop_items)
        card_width, card_height = 280, 380
        spacing = 25
        
        # 计算布局
        cards_per_row = min(4, num_items)
        rows = (num_items + cards_per_row - 1) // cards_per_row
        
        total_width = cards_per_row * card_width + (cards_per_row - 1) * spacing + 80
        total_height = rows * card_height + (rows - 1) * spacing + 200
        
        self.panel_rect = pygame.Rect(0, 0, total_width, total_height)
        self.panel_rect.center = (SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2)
        
        # 创建商品卡片
        cards_start_x = self.panel_rect.x + 40
        cards_start_y = self.panel_rect.y + 120
        
        for i, item_tuple in enumerate(self.shop_items):
            row = i // cards_per_row
            col = i % cards_per_row
            
            # 如果最后一行商品数量不足，居中显示
            if row == rows - 1:
                items_in_last_row = num_items - row * cards_per_row
                if items_in_last_row < cards_per_row:
                    # 计算居中偏移
                    empty_slots = cards_per_row - items_in_last_row
                    center_offset = (empty_slots * (card_width + spacing)) // 2
                    card_x = cards_start_x + center_offset + col * (card_width + spacing)
                else:
                    card_x = cards_start_x + col * (card_width + spacing)
            else:
                card_x = cards_start_x + col * (card_width + spacing)
            
            card_y = cards_start_y + row * (card_height + spacing)
            card_rect = pygame.Rect(card_x, card_y, card_width, card_height)
            
            button = Button(card_rect, "", self._get_font('normal', 20))
            item_tuple[0] = button
            
            # 初始化动画
            self.hover_animations[i] = 0.0
            self.card_bounce_offsets.append(random.uniform(0, math.pi * 2))  # 随机相位
        
        # 离开按钮
        leave_rect = pygame.Rect(self.panel_rect.centerx - 100, 
                                self.panel_rect.bottom - 60, 200, 45)
        self.leave_button = Button(leave_rect, "离开商店", self._get_font('normal', 20))
        self.hover_animations['leave'] = 0.0

    def handle_event(self, event):
        """处理事件"""
        if self.entrance_animation < 1.0:
            return
        
        if self.leave_button.handle_event(event):
            self.origin_room.is_cleared = True
            from .dungeon_screen import DungeonScreen
            if len(self.game.state_stack) > 1 and isinstance(self.game.state_stack[-2], DungeonScreen):
                self.game.state_stack[-2].door_rects = self.game.state_stack[-2]._generate_doors()
            self.game.state_stack.pop()
            return
        
        for i, (button, item, price, is_sold) in enumerate(self.shop_items):
            if not is_sold and button.handle_event(event):
                if self.game.player.gold >= price:
                    # 购买成功
                    self.game.player.gold -= price
                    feedback = self.game.player.pickup_item(item)
                    
                    # 创建金币粒子效果
                    self._create_coin_particles(button.rect.center)
                    
                    if feedback:
                        from .notification_screen import NotificationScreen
                        self.game.state_stack.append(NotificationScreen(self.game, feedback))
                    
                    self.feedback_message = f"成功购买 {getattr(item, 'display_name', '物品')}！"
                    # 将该商品标记为已售出
                    self.shop_items[i][3] = True
                else:
                    self.feedback_message = "金币不足！"
                    
                self.feedback_timer = pygame.time.get_ticks()
                return

    def _create_coin_particles(self, center):
        """创建金币粒子效果"""
        for _ in range(18):
            particle = {
                'x': center[0] + random.uniform(-15, 15),
                'y': center[1] + random.uniform(-10, 10),
                'vx': random.uniform(-3.2, 3.2),
                'vy': random.uniform(-6, -2),
                'life': 60,
                'max_life': 60,
                'size': random.uniform(3, 7)
            }
            self.coin_particles.append(particle)

    def update(self):
        """更新动画和状态"""
        current_time = pygame.time.get_ticks()
        if not hasattr(self, '_last_time'): 
            self._last_time = current_time
            
        dt_ms = current_time - self._last_time
        self._last_time = current_time
        dt_sec = dt_ms / 1000.0
        
        # 入场动画
        self.entrance_animation = min(1.0, self.entrance_animation + dt_sec * 2.5)
        
        # 发光动画
        self.glow_animation = (self.glow_animation + dt_sec * 2) % (2 * math.pi)
        
        # 更新粒子
        for particle in self.coin_particles[:]:
            particle['x'] += particle['vx']
            particle['y'] += particle['vy']
            particle['vy'] += 0.22  # 重力
            particle['life'] -= 1
            if particle['life'] <= 0:
                self.coin_particles.remove(particle)
        
        # 悬停检测和动画
        mouse_pos = pygame.mouse.get_pos()
        hovered_item = None
        
        # 检查商品卡片悬停
        for i, (button, item, price, is_sold) in enumerate(self.shop_items):
            if button.rect.collidepoint(mouse_pos) and not is_sold:
                self.hover_animations[i] = min(1.0, self.hover_animations[i] + dt_sec * 4.0)
                hovered_item = item
            else:
                self.hover_animations[i] = max(0.0, self.hover_animations[i] - dt_sec * 3.0)
        
        # 检查离开按钮悬停
        if self.leave_button.rect.collidepoint(mouse_pos):
            self.hover_animations['leave'] = min(1.0, self.hover_animations['leave'] + dt_sec * 4.0)
        else:
            self.hover_animations['leave'] = max(0.0, self.hover_animations['leave'] - dt_sec * 3.0)
        
        # 更新tooltip
        self.tooltip_manager.update(hovered_item)
        
        # 清除过期反馈消息
        if self.feedback_message and current_time - self.feedback_timer > 2000:
            self.feedback_message = ""

    def draw(self, surface):
        """绘制界面"""
        # 半透明遮罩
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, int(200 * self.entrance_animation)))
        surface.blit(overlay, (0, 0))
        
        # 主面板（入场动画）
        panel_rect = self.panel_rect.copy()
        if self.entrance_animation < 1.0:
            scale = 0.7 + 0.3 * self.entrance_animation
            panel_rect = pygame.Rect(0, 0, 
                                   int(self.panel_rect.width * scale),
                                   int(self.panel_rect.height * scale))
            panel_rect.center = (SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2)
        
        self._draw_modern_panel(surface, panel_rect, (25, 30, 50, 240))
        
        # 绘制各部分
        self._draw_header(surface, panel_rect)
        self._draw_shop_items(surface)
        self._draw_leave_button(surface)
        self._draw_feedback(surface, panel_rect)
        self._draw_particles(surface)
        
        # 绘制tooltip
        self.tooltip_manager.draw(surface)

    def _draw_modern_panel(self, surface, rect, color, border_color=None):
        """绘制现代化面板"""
        pygame.draw.rect(surface, color, rect, border_radius=15)
        if border_color is None: 
            border_color = (70, 80, 100, 200)
        pygame.draw.rect(surface, border_color, rect, width=3, border_radius=15)
        
        # 内发光效果
        glow_rect = rect.inflate(-6, -6)
        pygame.draw.rect(surface, (255, 255, 255, 25), glow_rect, width=2, border_radius=12)

    def _draw_header(self, surface, panel_rect):
        """绘制商店标题和金币显示"""
        header_rect = pygame.Rect(panel_rect.x + 30, panel_rect.y + 20, 
                                 panel_rect.width - 60, 80)
        
        # 标题背景
        self._draw_modern_panel(surface, header_rect, (35, 40, 65, 180), (100, 120, 150))
        
        # 商店标题
        title_font = self._get_font('large', 32)
        title_text = "✨ 神秘商店 ✨"
        title_surface = title_font.render(title_text, True, (255, 215, 0))
        title_rect = title_surface.get_rect(x=header_rect.x + 25, centery=header_rect.centery - 10)
        surface.blit(title_surface, title_rect)
        
        # 金币显示
        gold_font = self._get_font('normal', 24)
        gold_text = f"💰 {self.game.player.gold} G"
        gold_surface = gold_font.render(gold_text, True, (255, 215, 0))
        gold_rect = gold_surface.get_rect(right=header_rect.right - 25, centery=header_rect.centery - 10)
        
        # 金币背景
        gold_bg = gold_rect.inflate(20, 10)
        pygame.draw.rect(surface, (50, 40, 20, 150), gold_bg, border_radius=8)
        pygame.draw.rect(surface, (255, 215, 0, 100), gold_bg, width=2, border_radius=8)
        surface.blit(gold_surface, gold_rect)
        
        # 副标题
        subtitle_font = self._get_font('small', 16)
        subtitle_text = "精选装备，物超所值！"
        subtitle_surface = subtitle_font.render(subtitle_text, True, (180, 180, 180))
        subtitle_rect = subtitle_surface.get_rect(x=header_rect.x + 25, top=title_rect.bottom + 5)
        surface.blit(subtitle_surface, subtitle_rect)

    def _draw_shop_items(self, surface):
        """绘制商店物品"""
        current_time = pygame.time.get_ticks()
        
        for i, (button, item, price, is_sold) in enumerate(self.shop_items):
            # 计算入场动画偏移
            entrance_delay = i * 0.1
            entrance_progress = max(0.0, min(1.0, (self.entrance_animation - entrance_delay) / 0.8))
            entrance_offset = (1.0 - entrance_progress) * 50.0
            
            # 计算浮动偏移
            bounce_phase = self.card_bounce_offsets[i] + current_time * 0.001
            bounce_offset = math.sin(bounce_phase) * 2.0 if not is_sold else 0.0
            
            # 调整卡片位置
            card_rect = button.rect.copy()
            card_rect.y += int(entrance_offset + bounce_offset)
            
            # 绘制商品卡片
            hover_alpha = self.hover_animations[i]
            self._draw_item_card(surface, card_rect, item, price, is_sold, hover_alpha)

    def _wrap_text(self, font, text, max_width, max_lines=None):
        """基于像素宽度的简单自动换行，返回行列表"""
        words = text.split()
        lines = []
        cur = ""
        for w in words:
            test = (cur + " " + w).strip()
            if font.size(test)[0] <= max_width:
                cur = test
            else:
                if cur:
                    lines.append(cur)
                cur = w
                if max_lines and len(lines) >= max_lines:
                    break
        if cur and (not max_lines or len(lines) < max_lines):
            lines.append(cur)
        return lines

    def _draw_item_card(self, surface, rect, item, price, is_sold, hover_alpha):
        """绘制单个商品卡片"""
        # 获取物品信息
        name = getattr(item, 'display_name', '未知物品')
        rarity = getattr(item, 'rarity', 'common')
        rarity_color = RARITY_COLORS.get(rarity, RARITY_COLORS.get('common', (180,180,180)))
        
        # 卡片状态
        if is_sold:
            bg_alpha = 60
            border_alpha = 80
            text_color = (200, 200, 200)
            scale = 0.95
        else:
            bg_alpha = int(140 + hover_alpha * 40)
            border_alpha = int(180 + hover_alpha * 75)
            text_color = (255, 255, 255)
            scale = 1.0 + hover_alpha * 0.03
        
        # 缩放效果
        target_rect = rect
        if scale != 1.0:
            scaled_size = (int(rect.width * scale), int(rect.height * scale))
            scaled_rect = pygame.Rect(0, 0, *scaled_size)
            scaled_rect.center = rect.center
            target_rect = scaled_rect
        
        # 卡片背景
        card_color = (*rarity_color, bg_alpha) if not is_sold else (60, 60, 60, bg_alpha)
        border_color = (*rarity_color, border_alpha) if not is_sold else (80, 80, 80, border_alpha)
        
        pygame.draw.rect(surface, card_color, target_rect, border_radius=12)
        pygame.draw.rect(surface, border_color, target_rect, width=3, border_radius=12)
        
        # 稀有度装饰
        decoration_rect = pygame.Rect(target_rect.x, target_rect.y, target_rect.width, 8)
        decoration_color = rarity_color if not is_sold else (80, 80, 80)
        pygame.draw.rect(surface, decoration_color, decoration_rect, 
                        border_top_left_radius=12, border_top_right_radius=12)
        
        # 发光效果（悬停且未售出）
        if hover_alpha > 0 and not is_sold:
            glow_intensity = int((math.sin(self.glow_animation) + 1) * hover_alpha * 25 + 15)
            glow_surface = pygame.Surface(target_rect.size, pygame.SRCALPHA)
            pygame.draw.rect(glow_surface, (*rarity_color, glow_intensity), 
                           (0, 0, target_rect.width, target_rect.height), border_radius=12)
            surface.blit(glow_surface, target_rect.topleft)
        
        # 已售出标记
        if is_sold:
            sold_font = self._get_font('large', 28)
            sold_text = sold_font.render("已售罄", True, (255, 100, 100))
            sold_rect = sold_text.get_rect(center=target_rect.center)
            
            # 半透明背景
            sold_bg = sold_rect.inflate(30, 15)
            pygame.draw.rect(surface, (0, 0, 0, 150), sold_bg, border_radius=8)
            pygame.draw.rect(surface, (255, 100, 100), sold_bg, width=2, border_radius=8)
            surface.blit(sold_text, sold_rect)
            return
        
        # 物品名称
        name_font = self._get_font('normal', 18)
        display_name = name
        if name_font.size(display_name)[0] > target_rect.width - 20:
            while name_font.size(display_name + "...")[0] > target_rect.width - 20 and len(display_name) > 1:
                display_name = display_name[:-1]
            display_name += "..."
        
        name_surface = name_font.render(display_name, True, text_color)
        name_rect = name_surface.get_rect(centerx=target_rect.centerx, top=target_rect.top + 18)
        
        # 名称背景
        name_bg_rect = name_rect.inflate(16, 6)
        pygame.draw.rect(surface, (0, 0, 0, 100), name_bg_rect, border_radius=4)
        surface.blit(name_surface, name_rect)
        
        # 稀有度标签
        rarity_font = self._get_font('small', 14)
        rarity_text = str(rarity).upper()
        rarity_surface = rarity_font.render(rarity_text, True, rarity_color)
        rarity_rect = rarity_surface.get_rect(centerx=target_rect.centerx, top=name_rect.bottom + 6)
        surface.blit(rarity_surface, rarity_rect)
        
        # 分割线
        line_y = rarity_rect.bottom + 10
        pygame.draw.line(surface, (100, 100, 100), 
                        (target_rect.x + 15, line_y), (target_rect.right - 15, line_y), 1)
        
        # 物品描述（基于 docstring 的简要信息）
        description = inspect.getdoc(item) or getattr(item, 'description', '') or "神秘的装备"
        desc_words = description.split()
        # 限制字数并自动换行
        desc_text = " ".join(desc_words[:40]) + ("..." if len(desc_words) > 40 else "")
        desc_area = pygame.Rect(target_rect.x + 14, line_y + 8, target_rect.width - 28, target_rect.height - (line_y + 8) - 80)
        desc_font = self._get_font('small', 14)
        lines = self._wrap_text(desc_font, desc_text, desc_area.width, max_lines=5)
        y = desc_area.y
        for ln in lines:
            surf = desc_font.render(ln, True, (220, 220, 220))
            surface.blit(surf, (desc_area.x, y))
            y += desc_font.get_height() + 2
        
        # 底部价格按钮区
        price_area = pygame.Rect(target_rect.x + 12, target_rect.bottom - 64, target_rect.width - 24, 50)
        if self.game.player.gold < price:
            btn_bg = (40, 30, 30, 160)
            btn_border = (150, 80, 80)
            price_text = f"金币不足（{price} G）"
            price_color = (230, 120, 120)
        else:
            # 悬停增强
            hover = hover_alpha if hover_alpha > 0 else 0.0
            base_alpha = 160 + int(60 * hover)
            btn_bg = (30, 40, 30, base_alpha)
            btn_border = (80, 200, 120)
            price_text = f"购买（{price} G）"
            price_color = (200, 255, 200)
        
        # 绘制按钮感
        pygame.draw.rect(surface, btn_bg, price_area, border_radius=10)
        pygame.draw.rect(surface, btn_border, price_area, width=2, border_radius=10)
        
        price_font = self._get_font('normal', 20)
        price_surf = price_font.render(price_text, True, price_color)
        price_rect = price_surf.get_rect(center=price_area.center)
        surface.blit(price_surf, price_rect)
        
        # 购买提示
        hint_font = self._get_font('small', 14)
        hint_text = "点击卡片以购买" if self.game.player.gold >= price else "去冒险赚点钱吧"
        hint_surf = hint_font.render(hint_text, True, (180, 180, 180))
        hint_rect = hint_surf.get_rect(midtop=(price_area.centerx, price_area.bottom + 2))
        surface.blit(hint_surf, hint_rect)

    def _draw_leave_button(self, surface):
        rect = self.leave_button.rect.copy()
        hover = self.hover_animations.get('leave', 0.0)
        bg = (35, 45, 70, int(200 + 40 * hover))
        border = (120, 140, 170)
        text_color = (255, 255, 255)
        
        # 背景
        pygame.draw.rect(surface, bg, rect, border_radius=10)
        pygame.draw.rect(surface, border, rect, width=2, border_radius=10)
        
        # 文本
        font = self._get_font('normal', 22)
        txt = font.render("离开商店", True, text_color)
        surface.blit(txt, txt.get_rect(center=rect.center))

    def _draw_feedback(self, surface, panel_rect):
        if not self.feedback_message:
            return
        msg_font = self._get_font('small', 18)
        msg_surf = msg_font.render(self.feedback_message, True, (255, 230, 150))
        msg_rect = msg_surf.get_rect(centerx=panel_rect.centerx, y=panel_rect.top + 95)
        # 背景
        bg = msg_rect.inflate(16, 8)
        pygame.draw.rect(surface, (0, 0, 0, 140), bg, border_radius=8)
        pygame.draw.rect(surface, (255, 215, 0), bg, width=2, border_radius=8)
        surface.blit(msg_surf, msg_rect)

    def _draw_particles(self, surface):
        for p in self.coin_particles:
            # life-based alpha
            alpha = max(0, min(255, int(255 * (p['life'] / p['max_life']))))
            coin = pygame.Surface((int(p['size']*2), int(p['size']*2)), pygame.SRCALPHA)
            pygame.draw.circle(coin, (255, 215, 0, alpha), (int(p['size']), int(p['size'])), int(p['size']))
            surface.blit(coin, (p['x']-p['size'], p['y']-p['size']))



================================================================================
### 文件路径: states\story.py
================================================================================

# 文件: states/story.py (完整替换)

import pygame
from .base import BaseState
from .dungeon_screen import DungeonScreen
from .saving import SaveScreen
from .loading import LoadScreen
from .backpack import BackpackScreen
from .talents_screen import TalentsScreen
from ui import draw_text, Button
from settings import *

class StoryScreen(BaseState):
    def __init__(self, game):
        super().__init__(game)
        
        # --- 核心修改 1: 重新布局，为“天赋”按钮腾出空间 ---
        button_w, button_h = 120, 40
        padding = 15
        # 从右往左依次是 保存 -> 加载 -> 背包 -> 天赋
        save_rect = pygame.Rect(SCREEN_WIDTH - padding - button_w, SCREEN_HEIGHT - padding - button_h - 250, button_w, button_h)
        load_rect = pygame.Rect(save_rect.left - padding - button_w, save_rect.top, button_w, button_h)
        backpack_rect = pygame.Rect(load_rect.left - padding - button_w, load_rect.top, button_w, button_h)
        talents_rect = pygame.Rect(backpack_rect.left - padding - button_w, backpack_rect.top, button_w, button_h)
        
        self.buttons = {
            "save": Button(save_rect, "保存(S)", self.game.fonts['small']),
            "load": Button(load_rect, "加载(L)", self.game.fonts['small']),
            "backpack": Button(backpack_rect, "背包(B)", self.game.fonts['small']),
            "talents": Button(talents_rect, "天赋(T)", self.game.fonts['small']) # <-- 新增天赋按钮
        }
        self._initialize_story()

    def _initialize_story(self):
        start_index = getattr(self.game, "loaded_dialogue_index", 0)
        self.dialogue_index = start_index
        self.displayed_chars = 0
        self.typing_complete = False
        self.last_char_time = 0
        self.typewriter_speed = 30
        self.game.loaded_dialogue_index = 0

    def update(self):
        if not self.typing_complete:
            now = pygame.time.get_ticks()
            if now - self.last_char_time > self.typewriter_speed:
                stage_data = self.game.story_data.get(self.game.current_stage, {})
                dialogue_list = stage_data.get("text", [])
                if not dialogue_list or self.dialogue_index >= len(dialogue_list):
                    self.typing_complete = True
                    return
                line = dialogue_list[self.dialogue_index].get("line", "")
                if self.displayed_chars < len(line):
                    self.displayed_chars += 1
                    self.last_char_time = now
                else:
                    self.typing_complete = True
    
    def handle_event(self, event):
        # --- 核心修改 2: 增加对新按钮和快捷键的处理 ---
        if self.buttons['save'].handle_event(event):
            self.game.state_stack.append(SaveScreen(self.game))
            return
        if self.buttons['load'].handle_event(event):
            self.game.state_stack.append(LoadScreen(self.game))
            return
        if self.buttons['backpack'].handle_event(event):
            self.game.state_stack.append(BackpackScreen(self.game))
            return
        # <-- 新增：处理天赋按钮点击事件
        if self.buttons['talents'].handle_event(event):
            self.game.state_stack.append(TalentsScreen(self.game))
            return

        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            is_over_button = any(btn.rect.collidepoint(event.pos) for btn in self.buttons.values())
            if not is_over_button:
                self._advance_dialogue()
        
        if event.type == pygame.KEYDOWN:
            if event.key in [pygame.K_RETURN, pygame.K_SPACE]:
                self._advance_dialogue()
            elif event.key == pygame.K_s:
                self.game.state_stack.append(SaveScreen(self.game))
            elif event.key == pygame.K_l:
                self.game.state_stack.append(LoadScreen(self.game))
            elif event.key == pygame.K_b:
                self.game.state_stack.append(BackpackScreen(self.game))
            # <-- 新增：处理天赋快捷键 'T'
            elif event.key == pygame.K_t:
                self.game.state_stack.append(TalentsScreen(self.game))

    def _advance_dialogue(self):
        from .combat import CombatScreen
        from .title import TitleScreen

        stage_data = self.game.story_data.get(self.game.current_stage)
        if not stage_data:
            self.game.state_stack = [TitleScreen(self.game)]
            return
            
        dialogue_list = stage_data.get("text", [])

        if not self.typing_complete:
            self.typing_complete = True
            if self.dialogue_index < len(dialogue_list):
                current_line = dialogue_list[self.dialogue_index].get("line", "")
                self.displayed_chars = len(current_line)
            return

        if self.dialogue_index < len(dialogue_list):
            current_dialogue = dialogue_list[self.dialogue_index]
            action = current_dialogue.get("action")
            if action == "start_trial":
                self.game.state_stack.pop()
                self.game.state_stack.append(DungeonScreen(self.game, "sunstone_ruins", 1))
                return

        self.dialogue_index += 1

        if self.dialogue_index >= len(dialogue_list):
            self.game.current_stage = stage_data.get("next", "quit")
            if self.game.current_stage == "quit":
                self.game.state_stack = [TitleScreen(self.game)]
                return
            
            next_stage_data = self.game.story_data.get(self.game.current_stage, {})
            if next_stage_data.get("type") == "combat":
                enemy_id = next_stage_data.get("enemy_id", "slime")
                self.game.state_stack.pop()
                self.game.state_stack.append(CombatScreen(self.game, enemy_id))
            else:
                self._initialize_story()
        else:
            self.displayed_chars = 0
            self.typing_complete = False
            self.last_char_time = 0

    def draw(self, surface):
        surface.fill(BG_COLOR)
        dialogue_box_rect = pygame.Rect(50, SCREEN_HEIGHT - 250, SCREEN_WIDTH - 100, 200)
        pygame.draw.rect(surface, PANEL_BG_COLOR, dialogue_box_rect, border_radius=10)
        pygame.draw.rect(surface, PANEL_BORDER_COLOR, dialogue_box_rect, 3, border_radius=10)

        stage_data = self.game.story_data.get(self.game.current_stage, {})
        dialogue_list = stage_data.get("text", [{"speaker": "错误", "line": "未找到剧情文本"}])
        safe_index = min(self.dialogue_index, len(dialogue_list) - 1)
        dialogue = dialogue_list[safe_index]
        speaker, full_line = dialogue["speaker"], dialogue["line"]
        if speaker != "旁白":
            speaker_text_surf = self.game.fonts['normal'].render(speaker, True, TEXT_COLOR)
            speaker_panel_rect = speaker_text_surf.get_rect(topleft=(dialogue_box_rect.left + 30, dialogue_box_rect.top - 35))
            speaker_panel_rect.inflate_ip(20, 10)
            pygame.draw.rect(surface, PANEL_BG_COLOR, speaker_panel_rect, border_radius=5)
            pygame.draw.rect(surface, PANEL_BORDER_COLOR, speaker_panel_rect, 2, border_radius=5)
            surface.blit(speaker_text_surf, (speaker_panel_rect.x + 10, speaker_panel_rect.y + 5))
        text_to_render = full_line[:self.displayed_chars]
        text_rect = dialogue_box_rect.inflate(-40, -40)
        draw_text(surface, text_to_render, self.game.fonts['normal'], TEXT_COLOR, text_rect)
        if self.typing_complete:
            prompt_pos = (dialogue_box_rect.right - 40, dialogue_box_rect.bottom - 40)
            pygame.draw.polygon(surface, TEXT_COLOR, [prompt_pos, (prompt_pos[0] - 20, prompt_pos[1]), (prompt_pos[0] - 10, prompt_pos[1] - 15)])
        
        # 绘制所有按钮 (会自动包含新按钮，无需修改)
        for button in self.buttons.values():
            button.draw(surface)


================================================================================
### 文件路径: states\talents_screen.py
================================================================================

# 文件: states/talents_screen.py (完全重写的现代化版本)

import pygame
import math
import inspect
from .base import BaseState
from ui import draw_text, Button, get_display_name, TooltipManager
from settings import *

# 天赋稀有度颜色配置
TALENT_RARITY_COLORS = {
    "common": (156, 163, 175),
    "uncommon": (16, 185, 129), 
    "rare": (59, 130, 246),
    "epic": (139, 92, 246),
    "legendary": (245, 158, 11)
}

class TalentsScreen(BaseState):
    def __init__(self, game, player_override=None):
        super().__init__(game)
        self.player = player_override or self.game.player
        self.is_overlay = True
        self.dragging_talent = None
        self.dragging_from_info = None
        
        # 动画系统
        self.hover_animation = {}
        self.glow_animation = 0
        self.pulse_animation = 0
        
        self._setup_layout()
        self.tooltip_manager = TooltipManager(self.game.fonts['small'])
        
    def _get_font(self, font_name, default_size=20):
        """安全获取字体"""
        try:
            if hasattr(self.game, 'fonts') and font_name in self.game.fonts:
                return self.game.fonts[font_name]
        except:
            pass
        return pygame.font.Font(None, default_size)

    def _setup_layout(self):
        margin, header_height = 40, 80
        self.container_rect = pygame.Rect(margin, margin, SCREEN_WIDTH - 2*margin, SCREEN_HEIGHT - 2*margin)
        self.header_rect = pygame.Rect(self.container_rect.x, self.container_rect.y, 
                                     self.container_rect.width, header_height)
        
        content_y = self.header_rect.bottom + 15
        content_height = self.container_rect.height - header_height - 15
        
        # 左侧：已装备天赋面板
        panel_width = 380
        self.equipped_panel_rect = pygame.Rect(self.container_rect.x, content_y, 
                                             panel_width, content_height)
        
        # 右侧：天赋库面板  
        self.learned_panel_rect = pygame.Rect(self.equipped_panel_rect.right + 20, content_y,
                                            self.container_rect.right - self.equipped_panel_rect.right - 20, 
                                            content_height)
        
        # 关闭按钮
        self.close_button = Button(
            pygame.Rect(self.container_rect.right - 50, self.container_rect.top + 15, 40, 40), 
            "×", self._get_font('large', 24)
        )

    def handle_event(self, event):
        if self.close_button.handle_event(event) or (event.type == pygame.KEYDOWN and event.key in [pygame.K_ESCAPE, pygame.K_t]):
            if self.dragging_talent:
                self._return_dragging_talent()
            self.game.state_stack.pop()
            return
            
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            self._handle_mouse_down(event.pos)
        if event.type == pygame.MOUSEBUTTONUP and event.button == 1:
            self._handle_mouse_up(event.pos)
        if event.type == pygame.MOUSEMOTION:
            self._handle_mouse_motion(event.pos)

    def _handle_mouse_down(self, pos):
        if self.dragging_talent: 
            return
        
        # 从已装备槽拾起
        for i, talent in enumerate(self.player.equipped_talents):
            if talent is not None:
                rect = self._get_talent_rect(i, 'equipped')
                if rect.collidepoint(pos):
                    self.dragging_talent = talent
                    self.dragging_from_info = {'type': 'equipped', 'index': i}
                    self.player.unequip_talent(talent)
                    return
        
        # 从天赋库拾起
        unequipped = [t for t in self.player.learned_talents if t not in self.all_equipped_talents]
        for i, talent in enumerate(unequipped):
            rect = self._get_talent_rect(i, 'learned')
            if rect.collidepoint(pos):
                self.dragging_talent = talent
                self.dragging_from_info = {'type': 'learned'}
                return

    def _handle_mouse_up(self, pos):
        if not self.dragging_talent: 
            return

        talent_to_place = self.dragging_talent
        source_info = self.dragging_from_info
        
        # 重置拖拽状态
        self.dragging_talent = None
        self.dragging_from_info = None

        # 检查是否放置在装备槽
        for i in range(self.player.max_talent_slots):
            rect = self._get_talent_rect(i, 'equipped')
            if rect.collidepoint(pos):
                target_talent = self.player.equipped_talents[i]
                
                if target_talent:
                    self.player.unequip_talent(target_talent)
                
                self.player.equip_talent(talent_to_place, specific_index=i)
                
                if target_talent and source_info['type'] == 'equipped':
                    self.player.equip_talent(target_talent, specific_index=source_info['index'])
                
                self.player.recalculate_stats()
                return

        # 检查是否放置在天赋库
        if self.learned_panel_rect.collidepoint(pos):
            self.player.recalculate_stats()
            return

        # 无效操作，返回原处
        self._return_dragging_talent(talent_to_place, source_info)
        self.player.recalculate_stats()

    def _handle_mouse_motion(self, pos):
        """处理鼠标悬停动画"""
        # 重置所有悬停状态
        for key in list(self.hover_animation.keys()):
            if key not in ['mouse_pos']:
                self.hover_animation[key] = max(0, self.hover_animation[key] - 0.1)
        
        # 检查装备槽悬停
        for i in range(self.player.max_talent_slots):
            rect = self._get_talent_rect(i, 'equipped')
            if rect.collidepoint(pos):
                self.hover_animation[f'equipped_{i}'] = min(1.0, self.hover_animation.get(f'equipped_{i}', 0) + 0.15)
        
        # 检查天赋库悬停
        unequipped = [t for t in self.player.learned_talents if t not in self.all_equipped_talents]
        for i, talent in enumerate(unequipped):
            rect = self._get_talent_rect(i, 'learned')
            if rect.collidepoint(pos):
                self.hover_animation[f'learned_{i}'] = min(1.0, self.hover_animation.get(f'learned_{i}', 0) + 0.15)

    def _return_dragging_talent(self, talent_to_return, source_info):
        """将天赋返回原处"""
        if source_info and source_info['type'] == 'equipped':
            self.player.equip_talent(talent_to_return, specific_index=source_info['index'])

    def update(self, dt=0):
        """更新动画"""
        current_time = pygame.time.get_ticks()
        if not hasattr(self, '_last_time'): 
            self._last_time = current_time
            
        dt_ms = current_time - self._last_time
        self._last_time = current_time
        dt_sec = dt_ms / 1000.0
        
        self.glow_animation = (self.glow_animation + dt_sec * 2) % (2 * math.pi)
        self.pulse_animation = (self.pulse_animation + dt_sec * 1.5) % (2 * math.pi)
        
        # 更新悬停检测
        if self.dragging_talent:
            self.tooltip_manager.update(None)
            return
        
        hovered_talent = None
        mouse_pos = pygame.mouse.get_pos()
        
        all_panels = [('equipped', self.all_equipped_talents), 
                      ('learned', [t for t in self.player.learned_talents if t not in self.all_equipped_talents])]

        for panel_type, talent_list in all_panels:
            for i, talent in enumerate(talent_list):
                if talent is None: 
                    continue
                rect = self._get_talent_rect(i, panel_type)
                if rect.collidepoint(mouse_pos):
                    hovered_talent = talent
                    break
            if hovered_talent: 
                break
        
        self.tooltip_manager.update(hovered_talent)

    def _get_talent_rect(self, index, panel_type):
        """获取天赋卡片矩形"""
        panel_rect = self.equipped_panel_rect if panel_type == 'equipped' else self.learned_panel_rect
        
        if panel_type == 'equipped':
            # 装备槽使用特殊布局
            padding, slot_size, spacing = 25, 80, 15
            cols = 3
            col, row = index % cols, index // cols
            x = panel_rect.left + padding + col * (slot_size + spacing)
            y = panel_rect.top + 120 + row * (slot_size + spacing)
            return pygame.Rect(x, y, slot_size, slot_size)
        else:
            # 天赋库使用网格布局
            padding, item_size, spacing = 20, 70, 12
            cols = max(1, (panel_rect.width - 2 * padding + spacing) // (item_size + spacing))
            col, row = index % cols, index // cols
            x = panel_rect.left + padding + col * (item_size + spacing)
            y = panel_rect.top + 120 + row * (item_size + spacing)
            return pygame.Rect(x, y, item_size, item_size)

    def draw(self, surface):
        # 半透明遮罩
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        # 主容器
        self._draw_modern_panel(surface, self.container_rect, (25, 30, 50, 240))
        
        # 绘制各部分
        self._draw_header(surface)
        self._draw_equipped_panel(surface)
        self._draw_learned_panel(surface)
        self._draw_dragging_talent(surface)
        
        self.close_button.draw(surface)
        self.tooltip_manager.draw(surface)
        
        # 更新动画
        if hasattr(self, 'update'): 
            self.update()

    def _draw_modern_panel(self, surface, rect, color, border_color=None):
        """绘制现代化面板"""
        pygame.draw.rect(surface, color, rect, border_radius=12)
        if border_color is None: 
            border_color = (70, 80, 100, 180)
        pygame.draw.rect(surface, border_color, rect, width=2, border_radius=12)
        
        # 内发光效果
        glow_rect = rect.inflate(-4, -4)
        pygame.draw.rect(surface, (255, 255, 255, 15), glow_rect, width=1, border_radius=10)

    def _draw_header(self, surface):
        """绘制标题区域"""
        header_bg = self.header_rect.inflate(-10, -10)
        self._draw_modern_panel(surface, header_bg, (35, 40, 65, 200))
        
        title_font = self._get_font('large', 32)
        title_text = title_font.render("天赋管理系统", True, (255, 215, 0))
        title_rect = title_text.get_rect(x=header_bg.x + 25, centery=header_bg.centery)
        surface.blit(title_text, title_rect)
        
        # 天赋点数显示
        if hasattr(self.player, 'talent_points'):
            points_text = f"天赋点: {self.player.talent_points}"
            points_font = self._get_font('normal', 20)
            points_surface = points_font.render(points_text, True, (100, 255, 100))
            points_rect = points_surface.get_rect(right=header_bg.right - 25, centery=header_bg.centery)
            surface.blit(points_surface, points_rect)

    def _draw_equipped_panel(self, surface):
        """绘制已装备天赋面板"""
        panel_bg = self.equipped_panel_rect.inflate(-8, -8)
        self._draw_modern_panel(surface, panel_bg, (30, 35, 55, 200))
        
        # 标题
        title = f"已装备天赋 ({len(self.all_equipped_talents)}/{self.player.max_talent_slots})"
        title_rect = pygame.Rect(panel_bg.x + 20, panel_bg.y + 20, panel_bg.width - 40, 50)
        title_font = self._get_font('normal', 22)
        title_surface = title_font.render(title, True, (255, 215, 0))
        surface.blit(title_surface, title_rect)
        
        # 分割线
        line_y = title_rect.bottom + 15
        pygame.draw.line(surface, (70, 80, 100), 
                        (panel_bg.x + 20, line_y), (panel_bg.right - 20, line_y), 2)
        
        # 装备槽
        for i in range(self.player.max_talent_slots):
            rect = self._get_talent_rect(i, 'equipped')
            hover_alpha = self.hover_animation.get(f'equipped_{i}', 0)
            
            # 槽位背景
            slot_color = (40, 50, 70, 120 + int(hover_alpha * 60))
            border_color = (70, 80, 100, 180 + int(hover_alpha * 75))
            
            # 添加悬停动画偏移
            if hover_alpha > 0:
                offset = int(math.sin(self.pulse_animation) * hover_alpha * 3)
                rect = rect.move(0, offset)
            
            pygame.draw.rect(surface, slot_color, rect, border_radius=10)
            pygame.draw.rect(surface, border_color, rect, width=2, border_radius=10)
            
            # 装备的天赋
            if i < len(self.player.equipped_talents):
                talent = self.player.equipped_talents[i]
                if talent and talent != self.dragging_talent:
                    self._draw_talent_card(surface, rect, talent, hover_alpha > 0.5)
                elif not talent:
                    # 空槽提示
                    plus_font = self._get_font('large', 36)
                    plus_text = plus_font.render("+", True, (100, 100, 100, 150))
                    plus_rect = plus_text.get_rect(center=rect.center)
                    surface.blit(plus_text, plus_rect)

    def _draw_learned_panel(self, surface):
        """绘制天赋库面板"""
        panel_bg = self.learned_panel_rect.inflate(-8, -8)
        self._draw_modern_panel(surface, panel_bg, (30, 35, 55, 200))
        
        # 标题
        unequipped_count = len([t for t in self.player.learned_talents if t not in self.all_equipped_talents])
        title = f"天赋库 ({unequipped_count} 个可用)"
        title_rect = pygame.Rect(panel_bg.x + 20, panel_bg.y + 20, panel_bg.width - 40, 50)
        title_font = self._get_font('normal', 22)
        title_surface = title_font.render(title, True, (255, 215, 0))
        surface.blit(title_surface, title_rect)
        
        # 分割线
        line_y = title_rect.bottom + 15
        pygame.draw.line(surface, (70, 80, 100), 
                        (panel_bg.x + 20, line_y), (panel_bg.right - 20, line_y), 2)
        
        # 天赋卡片
        unequipped = [t for t in self.player.learned_talents if t not in self.all_equipped_talents]
        
        for i, talent in enumerate(unequipped):
            if talent != self.dragging_talent:
                rect = self._get_talent_rect(i, 'learned')
                hover_alpha = self.hover_animation.get(f'learned_{i}', 0)
                
                # 添加悬停动画效果
                if hover_alpha > 0:
                    offset = int(math.sin(self.pulse_animation) * hover_alpha * 2)
                    rect = rect.move(0, offset)
                
                self._draw_talent_card(surface, rect, talent, hover_alpha > 0.3)

    def _draw_talent_card(self, surface, rect, talent, is_highlighted=False):
        """绘制天赋卡片"""
        # 获取稀有度
        rarity = getattr(talent, 'rarity', 'common')
        rarity_color = TALENT_RARITY_COLORS.get(rarity, TALENT_RARITY_COLORS['common'])
        
        # 背景颜色
        if is_highlighted:
            bg_color = (*rarity_color, 80)
            border_color = rarity_color
        else:
            bg_color = (*rarity_color, 40)
            border_color = (*rarity_color, 120)
        
        pygame.draw.rect(surface, bg_color, rect, border_radius=8)
        pygame.draw.rect(surface, border_color, rect, width=2, border_radius=8)
        
        # 稀有度指示条
        indicator_rect = pygame.Rect(rect.x, rect.y, rect.width, 4)
        pygame.draw.rect(surface, rarity_color, indicator_rect, 
                        border_top_left_radius=8, border_top_right_radius=8)
        
        # 天赋名称
        name = get_display_name(talent)
        font = self._get_font('small', 14)
        
        # 如果名称太长，截断并添加省略号
        if font.size(name)[0] > rect.width - 8:
            while font.size(name + "...")[0] > rect.width - 8 and len(name) > 1:
                name = name[:-1]
            name += "..."
        
        text_surface = font.render(name, True, (255, 255, 255))
        text_rect = text_surface.get_rect(center=(rect.centerx, rect.centery))
        surface.blit(text_surface, text_rect)
        
        # 发光效果（如果高亮）
        if is_highlighted:
            glow_alpha = int((math.sin(self.glow_animation) + 1) * 30 + 20)
            glow_surface = pygame.Surface(rect.size, pygame.SRCALPHA)
            pygame.draw.rect(glow_surface, (*rarity_color, glow_alpha), 
                           (0, 0, rect.width, rect.height), border_radius=8)
            surface.blit(glow_surface, rect.topleft)

    def _draw_dragging_talent(self, surface):
        """绘制拖拽中的天赋"""
        if self.dragging_talent:
            mouse_pos = pygame.mouse.get_pos()
            name = get_display_name(self.dragging_talent)
            
            # 创建拖拽卡片
            card_size = (120, 40)
            card_rect = pygame.Rect(0, 0, *card_size)
            card_rect.center = mouse_pos
            
            # 半透明背景
            drag_surface = pygame.Surface(card_size, pygame.SRCALPHA)
            rarity = getattr(self.dragging_talent, 'rarity', 'common')
            rarity_color = TALENT_RARITY_COLORS.get(rarity, TALENT_RARITY_COLORS['common'])
            
            pygame.draw.rect(drag_surface, (*rarity_color, 150), 
                           (0, 0, *card_size), border_radius=8)
            pygame.draw.rect(drag_surface, rarity_color, 
                           (0, 0, *card_size), width=2, border_radius=8)
            
            # 文字
            font = self._get_font('normal', 16)
            text = font.render(name, True, (255, 255, 255))
            text_rect = text.get_rect(center=(card_size[0]//2, card_size[1]//2))
            drag_surface.blit(text, text_rect)
            
            surface.blit(drag_surface, card_rect.topleft)

    @property
    def all_equipped_talents(self):
        """获取所有已装备的非空天赋"""
        return [t for t in self.player.equipped_talents if t is not None]


================================================================================
### 文件路径: states\title.py
================================================================================

# 文件: states/title.py (完整替换)

import pygame
from .base import BaseState
from .loading import LoadScreen
from .story import StoryScreen
from .sandbox_screen import SandboxScreen # <-- 1. 导入新场景
from ui import Button
from settings import *

class TitleScreen(BaseState):
    def __init__(self, game):
        super().__init__(game)
        # --- 2. 重新布局，加入新按钮 ---
        self.buttons = {
            "new_game": Button((SCREEN_WIDTH / 2 - 150, 300, 300, 60), "新游戏", self.game.fonts['normal']),
            "continue_game": Button((SCREEN_WIDTH / 2 - 150, 380, 300, 60), "继续游戏", self.game.fonts['normal']),
            "load_game": Button((SCREEN_WIDTH / 2 - 150, 460, 300, 60), "加载游戏", self.game.fonts['normal']),
            "sandbox": Button((SCREEN_WIDTH / 2 - 150, 540, 300, 60), "沙盒模式(测试)", self.game.fonts['normal']),
        }

    def handle_event(self, event):
        # --- 3. 添加对新按钮的事件处理 ---
        if self.buttons['new_game'].handle_event(event):
            self.game.start_new_game()
            self.game.state_stack.append(StoryScreen(self.game))

        elif self.buttons['continue_game'].handle_event(event):
            if self.game.load_from_slot(0):
                self.game.state_stack.append(StoryScreen(self.game))
            else:
                self.game.start_new_game()
                self.game.state_stack.append(StoryScreen(self.game))

        elif self.buttons['load_game'].handle_event(event):
            self.game.state_stack.append(LoadScreen(self.game))

        elif self.buttons['sandbox'].handle_event(event):
            self.game.state_stack.append(SandboxScreen(self.game))

        if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
            self.game.running = False

    def draw(self, surface):
        surface.fill(BG_COLOR)
        title_surf = self.game.fonts['large'].render("我的战斗游戏", True, TEXT_COLOR)
        title_rect = title_surf.get_rect(center=(SCREEN_WIDTH / 2, 150))
        surface.blit(title_surf, title_rect)
        for button in self.buttons.values():
            button.draw(surface)



--- ä»£ç åˆé›†ç”Ÿæˆäº: 2025-09-04 17:02:17 ---
--- æ ¹ç›®å½•: C:\Users\User\Desktop\private\battle ---

================================================================================
### æ–‡ä»¶è·¯å¾„: battle_logger.py
================================================================================

# æ–‡ä»¶: battle_logger.py (æ–°æ–‡ä»¶)

class BattleLogger:
    def __init__(self):
        self._renderer = None

    def register_renderer(self, renderer_instance):
        """æˆ˜æ–—å¼€å§‹æ—¶ï¼Œç”±æˆ˜æ–—ç•Œé¢è°ƒç”¨ï¼Œç”¨äºæ³¨å†Œæ—¥å¿—æ˜¾ç¤ºå™¨"""
        print("[BattleLogger] æ—¥å¿—æ˜¾ç¤ºå™¨å·²æ³¨å†Œã€‚")
        self._renderer = renderer_instance

    def unregister_renderer(self):
        """æˆ˜æ–—ç»“æŸæ—¶è°ƒç”¨ï¼Œç”¨äºæ³¨é”€æ˜¾ç¤ºå™¨"""
        print("[BattleLogger] æ—¥å¿—æ˜¾ç¤ºå™¨å·²æ³¨é”€ã€‚")
        self._renderer = None

    def log(self, parts, color=None):
        """
        å…¨å±€æ—¥å¿—æ¥å£ã€‚
        ä»»ä½•åœ°æ–¹éƒ½å¯ä»¥è°ƒç”¨è¿™ä¸ªå‡½æ•°æ¥å‘é€æ—¥å¿—ã€‚
        """
        if self._renderer:
            # ç›´æ¥è°ƒç”¨æ˜¾ç¤ºå™¨çš„ add_message æ–¹æ³•
            self._renderer.add_message(parts, color=color)
        else:
            # å¦‚æœæ²¡æœ‰æ³¨å†Œæ˜¾ç¤ºå™¨ï¼ˆæ¯”å¦‚éæˆ˜æ–—çŠ¶æ€ï¼‰ï¼Œåˆ™åœ¨æ§åˆ¶å°æ‰“å°
            if isinstance(parts, list):
                # å¦‚æœæ˜¯å¯Œæ–‡æœ¬åˆ—è¡¨ï¼Œæ‹¼æ¥åæ‰“å°
                print("".join([p[0] for p in parts]))
            else:
                print(parts)

# åˆ›å»ºä¸€ä¸ªå…¨å±€å”¯ä¸€çš„æ’­æŠ¥å‘˜å®ä¾‹
battle_logger = BattleLogger()


================================================================================
### æ–‡ä»¶è·¯å¾„: Buffs.py
================================================================================

from damage import DamagePacket, DamageType
from abc import ABC
import collections
from collections import defaultdict
from rich.console import Console, Group
from rich.live import Live
from rich.table import Table
from rich.panel import Panel
from rich.text import Text
import time
import random
from rich.text import Text
from rich.progress import BarColumn  # å¯é€‰ï¼šä¹Ÿå¯ä»¥ç›´æ¥ç”¨ Text
import math
from collections import Counter
#import pygame
import sys
from battle_logger import battle_logger
from ui import format_damage_log


class Buff(ABC):
    """é€šç”¨ Buff/DeBuff åŸºç±»ï¼Œæ‰€æœ‰çŠ¶æ€ç»§æ‰¿æ­¤ç±»ã€‚"""
    display_name     = None      # ç•Œé¢æ˜¾ç¤ºå
    max_stacks       = 1         # æœ€å¤§å å±‚æ•°ï¼›1 è¡¨ç¤ºä¸å¯å åŠ 
    dispellable      = False     # æ˜¯å¦å¯è¢«é©±æ•£
    duration         = None      # æŒç»­ç§’æ•°ï¼›None æˆ– 0 è¡¨ç¤ºæ— é™
    hidden           = False     # æ˜¯å¦åœ¨ç•Œé¢éšè—
    is_debuff        = False     # æ˜¯å¦ä¸ºè´Ÿé¢çŠ¶æ€
    priority         = 0         # æ‰§è¡Œé¡ºåºï¼Œè¶Šå¤§è¶Šå…ˆæ‰§è¡Œ
    disable_attack   = False     # æ˜¯å¦ç¦æ­¢æ”»å‡»ï¼ˆå¦‚çœ©æ™•ã€ä¸ç­äºŒé˜¶æ®µï¼‰

    def __init__(self, stacks: int = 1, duration_override: float = None):
        self.stacks = min(stacks, self.max_stacks)
        self.remaining = duration_override if duration_override is not None else self.duration
        self._accum = 0.0

    def on_apply(self, wearer):
        """Buff è¢«æ·»åŠ åˆ°è§’è‰²æ—¶è§¦å‘"""
        pass

    def on_remove(self, wearer):
        """Buff è¢«ç§»é™¤æ—¶è§¦å‘"""
        pass

    def on_tick(self, wearer, dt):
        """
        æ¯å¸§æˆ–å®šæ—¶è§¦å‘ï¼Œç”¨äºæŒç»­æ€§æ•ˆæœã€‚
        è¿”å›å­—ç¬¦ä¸²åˆ™è¡¨ç¤ºæœ‰é£˜å­—ã€‚
        """
        return None

    def before_take_damage(self, wearer, dmg):
        """å—åˆ°ä¼¤å®³å‰è§¦å‘ï¼Œå¯ä¿®æ”¹ dmg"""
        return dmg

    def on_attacked(self, wearer, attacker, dmg):
        """æ¯æ¬¡è¢«æ”»å‡»åè§¦å‘"""
        pass

    def on_fatal(self, wearer):
        """
        ä¸´ç•Œï¼ˆhp<=0ï¼‰æ—¶è§¦å‘ä¸€æ¬¡ï¼Œè‡ªæ•‘æˆ–å…¶ä»–
        è¿”å› True åˆ™ç§»é™¤è‡ªèº« Buff
        """
        return False


class SteelHeartBuff(Buff):
    """åˆšæ¯…ï¼šå—åˆ°è‡´å‘½ä¼¤æ—¶è‡ªæ•‘ä¸€æ¬¡ï¼Œå¯å åŠ """
    display_name = "åˆšæ¯…"
    dispellable  = False
    max_stacks   = 99  # âœ… å…è®¸å åŠ 

    def __init__(self, uses: int = 1):
        super().__init__(stacks=uses)

    def on_fatal(self, wearer):
        if self.stacks > 0:
            self.stacks -= 1
            wearer.hp = 1
            wearer.shield += int(wearer.max_hp * 0.3)
            return self.stacks == 0  # æœ€å1æ¬¡åç§»é™¤
        return False


class RegenerationBuff(Buff):
    """
    å†ç”Ÿï¼šæ¯å±‚æ¯ç§’å›å¤ 1 ç‚¹ HPï¼ŒæŒç»­å­˜åœ¨ï¼ˆæ— é™ï¼‰ã€‚
    """
    display_name = "å†ç”Ÿ"
    dispellable  = True
    max_stacks   = 99
    is_debuff    = False

    def __init__(self, stacks: int = 1):
        super().__init__(stacks=stacks)
        self._timer = 0.0  # æ–°å¢ï¼šç§’è®¡æ—¶å™¨

    def on_tick(self, wearer, dt):
        self._timer += dt  # ç´¯åŠ æ¯å¸§çš„æ—¶é—´
        
        # å½“è®¡æ—¶å™¨è¶…è¿‡æˆ–ç­‰äº1ç§’æ—¶ï¼Œæ‰§è¡Œå›è¡€
        while self._timer >= 1.0:
            amount = self.stacks  # æ¯ç§’å›å¤é‡ = å±‚æ•°
            
            # ### æœ€ç»ˆä¿®å¤ï¼šä» current_opponent è·å–ç›®æ ‡ï¼Œå¹¶ä½œä¸º combat_target ä¼ å…¥ ###
            opponent = getattr(wearer, "current_opponent", None)
            wearer.heal(amount, combat_target=opponent)
            
            self._timer -= 1.0  # è®¡æ—¶å™¨å‡å»1ç§’ï¼Œå‡†å¤‡ä¸‹ä¸€æ¬¡è®¡æ—¶
        return None


class PoisonDebuff(Buff):
    """
    æ¯’ï¼šæ¯å±‚æ¯ç§’å¯¹è§’è‰²é€ æˆ 1 ç‚¹æ¯’ç³»ä¼¤å®³ï¼›ä¼˜å…ˆæ¶ˆè€—æŠ¤ç›¾
    """
    display_name = "æ¯’"
    dispellable  = True
    max_stacks   = 99
    is_debuff    = True

    def __init__(self, stacks: int = 1):
        super().__init__(stacks=stacks)
        self._timer = 0.0

    def on_tick(self, wearer, dt):
        self._timer += dt
        while self._timer >= 1.0:
            dmg = self.stacks
            # <-- æ ¸å¿ƒä¿®æ”¹ï¼šåˆ›å»ºå¹¶å‘é€ä¸€ä¸ªä¼¤å®³ä¿¡æ¯åŒ… -->
            packet = DamagePacket(
                amount=dmg, 
                damage_type=DamageType.POISON, # ç±»å‹æ˜¯æ¯’
                is_dot=True,                   # æ ‡è®°ä¸ºæŒç»­ä¼¤å®³
                is_sourceless=True             # æ ‡è®°ä¸ºæ— æ¥æºä¼¤å®³
            )
            wearer.take_damage(packet)
            self._timer -= 1.0
        return None


class AttackDisabledBuff(Buff):
    """é€šç”¨ï¼šç¦æ­¢è§’è‰²æ™®æ”»"""
    display_name    = "æ— æ³•æ”»å‡»"
    dispellable     = False
    is_debuff       = True
    hidden          = True
    disable_attack  = True

    def __init__(self, duration: float):
        super().__init__(stacks=1)
        self.remaining = duration

    def on_tick(self, wearer, dt):
        if self.remaining is None:
            return None
        self.remaining -= dt
        if self.remaining <= 0:
            wearer.remove_buff(self)
        return None

class StunDebuff(Buff):
    """
    çœ©æ™•ï¼šç¦æ­¢æ™®æ”»ï¼Œä¸å¯å åŠ ï¼Œä¸å¯é©±æ•£
    """
    display_name    = "çœ©æ™•"
    max_stacks      = 1
    dispellable     = False
    is_debuff       = True
    disable_attack  = True
    duration        = 2.0

    def __init__(self, duration=2.0):
        super().__init__(duration_override=duration)

    def on_apply(self, wearer):
        for b in wearer.buffs:
            if b is not self and isinstance(b, StunDebuff):
                b.remaining = max(b.remaining, self.remaining)
                wearer.remove_buff(self)
                return

    def on_tick(self, wearer, dt):
        self.remaining -= dt
        if self.remaining <= 0:
            wearer.remove_buff(self)
        return None


# æ›¿æ¢ Buffs.py ä¸­çš„ ThornsBuff ç±»
class ThornsBuff(Buff):
    """è†æ£˜ï¼šè¢«æ”»å‡»æ—¶åå¼¹å½“å‰å±‚æ•°çš„çœŸå®ä¼¤å®³ç»™æ”»å‡»è€…"""
    display_name  = "è†æ£˜"
    dispellable   = True
    is_debuff     = False
    max_stacks    = 99

    def on_attacked(self, wearer, attacker, dmg):
        if attacker is not None and self.stacks > 0 and attacker.hp > 0:
            # åˆ›å»ºä¸€ä¸ªçœŸå®ä¼¤å®³ã€æ— æ¥æºçš„ä¼¤å®³åŒ…è¿›è¡Œåä¼¤
            thorns_packet = DamagePacket(
                amount=self.stacks,
                damage_type=DamageType.TRUE,
                source=wearer,
                is_sourceless=True
            )
            attacker.take_damage(thorns_packet)

class PhoenixCrownStage1Buff(Buff):
    """ä¸ç­Â·è§‰é†’ï¼ˆStage1ï¼‰ï¼šé˜²å¾¡â†’æ”»å‡»+æ”»é€Ÿ"""
    display_name  = "ä¸ç­Â·è§‰é†’"
    dispellable   = False
    is_debuff     = False

    def __init__(self):
        super().__init__(stacks=1)
        self._boosted = False

    def on_apply(self, wearer):
        bm = wearer.base_max_hp
        wearer.max_hp = bm * 2
        wearer.hp     = min(wearer.hp + bm, wearer.max_hp)

    def on_tick(self, wearer, dt):
        if not self._boosted:
            bd = wearer.base_defense
            ba = wearer.base_attack
            bs = wearer.base_attack_speed
            wearer.attack = ba + bd
            wearer.attack_speed = bs + bd * 0.05
            wearer.attack_interval = 6.0 / wearer.attack_speed
            wearer.defense = 0
            self._boosted = True
        if wearer.hp / wearer.max_hp <= 0.2:
            wearer.remove_buff(self)
            wearer.add_buff(PhoenixCrownStage2Buff())
        return None


# æ–‡ä»¶: Buffs.py (å®Œæ•´æ›¿æ¢ PhoenixCrownStage2Buff è¿™ä¸ªç±»)

class PhoenixCrownStage2Buff(Buff):
    """ä¸ç­Â·ç¬¬äºŒé˜¶æ®µï¼šç¦æ‰‹+å›è¡€åå‡»"""
    display_name    = "ä¸ç­"
    dispellable     = False
    is_debuff       = False
    disable_attack  = True

    def __init__(self):
        super().__init__(stacks=1)
        # ### æ ¸å¿ƒä¿®æ”¹ 1ï¼šä¸å†ä½¿ç”¨ _healed_totalï¼Œæ”¹ä¸º _damage_to_deal ###
        self._damage_to_deal = 0.0
        self._rec_atk        = None
        self._rec_def        = None
        self._rec_as         = None
        self._rec_dr         = None
        self._timer          = 0.0

    def on_apply(self, wearer):
        # ### æ ¸å¿ƒä¿®æ”¹ 2ï¼šåœ¨Buffç”Ÿæ•ˆæ—¶ï¼Œç«‹åˆ»è®¡ç®—å¹¶å‚¨å­˜åº”é€ æˆçš„æ€»ä¼¤å®³ ###
        # è¿™ä¸ªä¼¤å®³å€¼ç­‰äºè§’è‰²å½“æ—¶å·²æŸå¤±çš„ç”Ÿå‘½å€¼ã€‚
        self._damage_to_deal = wearer.max_hp - wearer.hp
        
        # ä¿å­˜è§’è‰²å±æ€§ (è¿™éƒ¨åˆ†ä¸å˜)
        self._rec_atk  = wearer.attack
        self._rec_def  = wearer.defense
        self._rec_as   = wearer.attack_speed
        self._rec_dr   = wearer.damage_resistance
        wearer.damage_resistance = self._rec_dr + 0.5

    # æ–‡ä»¶: Buffs.py (åœ¨ PhoenixCrownStage2Buff ç±»ä¸­ï¼Œæ›¿æ¢ on_tick æ–¹æ³•)
    def on_tick(self, wearer, dt):
        self._timer += dt

        if self._timer >= 1.0:
            if wearer.hp < wearer.max_hp:
                heal_amount = wearer.max_hp * 0.1
                # ### æ ¸å¿ƒä¿®æ”¹ï¼šä» current_opponent è·å–ç›®æ ‡ ###
                opponent = getattr(wearer, "current_opponent", None)
                wearer.heal(heal_amount, combat_target=opponent)
            self._timer -= 1.0

        if wearer.hp >= wearer.max_hp:
            total = int(self._damage_to_deal)
            # ### æ ¸å¿ƒä¿®æ”¹ï¼šä» current_opponent è·å–ç›®æ ‡ ###
            opponent = getattr(wearer, "current_opponent", None)

            if opponent and opponent.hp > 0:
                # ... (åç»­çš„ä¼¤å®³å’Œæ—¥å¿—é€»è¾‘ä¸å˜, åªæ˜¯æŠŠ attacker æ¢æˆäº† opponent)
                from damage import DamagePacket, DamageType
                from ui import format_damage_log
                packet = DamagePacket(total, DamageType.TRUE, source=wearer, is_sourceless=True)
                damage_details = opponent.take_damage(packet)
                log_parts = format_damage_log(damage_details, action_name="ä¸ç­åå‡»")
                battle_logger.log(log_parts)

            # ... (æ¢å¤å±æ€§çš„éƒ¨åˆ†ä¸å˜) ...
            wearer.remove_buff(self)
            return None

        return None



class BleedDebuff(Buff):
    """
    æµè¡€ (å¯å åŠ , å¯é©±æ•£)
    æ¯å±‚æ¯ç§’å¯¹ç›®æ ‡é€ æˆ 1 ç‚¹çœŸå®ä¼¤å®³ï¼ˆæ— è§†é˜²å¾¡ï¼‰ã€‚
    """
    display_name = "æµè¡€"
    dispellable  = True
    is_debuff    = True
    max_stacks   = 99

    def __init__(self, stacks: int = 1, duration: float = 5.0):
        super().__init__(stacks=stacks, duration_override=duration)
        self._timer = 0.0

    def on_tick(self, wearer, dt):
        self._timer += dt
        if self._timer >= 1.0:
            dmg = self.stacks
            # <-- æ ¸å¿ƒä¿®æ”¹ï¼šåˆ›å»ºå¹¶å‘é€ä¸€ä¸ªä¼¤å®³ä¿¡æ¯åŒ… -->
            packet = DamagePacket(
                amount=dmg,
                damage_type=DamageType.TRUE, # ç±»å‹æ˜¯çœŸå®ä¼¤å®³
                is_dot=True,
                is_sourceless=True
            )
            wearer.take_damage(packet)
            self._timer -= 1.0
        
        self.remaining -= dt
        if self.remaining <= 0:
            wearer.remove_buff(self)
        return None

class BlockBuff(Buff):
    """æ ¼æŒ¡ï¼šæ¯å±‚å¯ä»¥å®Œå…¨æŠµæŒ¡ä¸€æ¬¡ä»»æ„æ¥æºçš„ä¼¤å®³ã€‚"""
    display_name = "æ ¼æŒ¡"
    max_stacks   = 99

    def before_take_damage(self, wearer, packet: DamagePacket): # <-- å‚æ•°æ”¹ä¸º packet
        if self.stacks > 0 and packet.amount > 0:
            print(f"[æ ¼æŒ¡] æ•ˆæœè§¦å‘ï¼æŠµæŒ¡äº† {int(packet.amount)} ç‚¹ä¼¤å®³ã€‚")
            self.stacks -= 1
            if self.stacks <= 0:
                wearer.remove_buff(self)
            
            packet.amount = 0 # å°†ä¼¤å®³åŒ…çš„æ•°å€¼æ¸…é›¶


class DragonSoulBuff(Buff):
    """ã€é¾™é­‚ã€‘ï¼šä¸€ç§ç‰¹æ®Šçš„èƒ½é‡èµ„æºï¼Œå¯è¢«æ¶ˆè€—ã€‚"""
    display_name = "é¾™é­‚"
    max_stacks   = 10 # é¾™é­‚ä¸Šé™ä¸º10å±‚
    is_debuff    = False

class SunstoneBrandDebuff(Buff):
    """ã€æ—¥ä¹‹çƒ™å°ã€‘ï¼šä¸€ç§å¯è¢«å¼•çˆ†çš„å°è®°ã€‚"""
    display_name = "æ—¥ä¹‹çƒ™å°"
    is_debuff    = True
    max_stacks   = 99

class SunderDebuff(Buff):
    """ã€ç ´ç”²ã€‘(Debuff): æ¯å±‚ä½¿ç›®æ ‡çš„é˜²å¾¡åŠ›é™ä½1ç‚¹ã€‚"""
    display_name = "ç ´ç”²"
    is_debuff    = True
    max_stacks   = 99

class VitalityBloomBuff(Buff):
    """ã€ç”Ÿæœºç»½æ”¾ã€‘(Buff): å—åˆ°ä¼¤å®³æ—¶ï¼Œæ¢å¤ç­‰åŒäº å±‚æ•° * 1% æœ€å¤§ç”Ÿå‘½å€¼çš„ç”Ÿå‘½ã€‚"""
    display_name = "ç”Ÿæœºç»½æ”¾"
    max_stacks   = 99

    def on_attacked(self, wearer, attacker, dmg):
        if dmg > 0:
            heal_amount = wearer.max_hp * (self.stacks * 0.01)
            # ### æ ¸å¿ƒä¿®å¤ï¼šå°†æ”»å‡»è€… attacker ä½œä¸º combat_target ä¼ å…¥ ###
            wearer.heal(heal_amount, combat_target=attacker)

class WitheredCurseDebuff(Buff):
    """ã€å‡‹é›¶å’’å°ã€‘(Debuff): æŒç»­æœŸé—´ï¼Œå—åˆ°çš„æ‰€æœ‰æ²»ç–—æ•ˆæœè½¬å˜ä¸ºç­‰é‡çœŸå®ä¼¤å®³ã€‚"""
    display_name = "å‡‹é›¶å’’å°"
    is_debuff    = True
    duration     = 5.0 # å‡è®¾æŒç»­5ç§’

    def on_tick(self, wearer, dt):
        # æŒç»­æ—¶é—´é€’å‡
        self.remaining -= dt
        if self.remaining <= 0:
            wearer.remove_buff(self)

    def before_healed(self, wearer, amount):
        """è¿™æ˜¯ä¸€ä¸ªæ–°çš„è‡ªå®šä¹‰é’©å­ï¼Œä¼šåœ¨Character.healä¸­è¢«è°ƒç”¨"""
        if amount > 0:
            print(f"[å‡‹é›¶å’’å°] {wearer.name} çš„æ²»ç–—è¢«è½¬åŒ–ä¸ºäº†ä¼¤å®³ï¼")
            from damage import DamagePacket, DamageType
            packet = DamagePacket(amount, DamageType.TRUE, is_sourceless=True)
            wearer.take_damage(packet)
        return 0 # è¿”å›0ï¼Œé˜»æ­¢æœ¬æ¬¡æ²»ç–—

class FrenzyBuff(Buff):
    """ã€ç‹‚çƒ­ã€‘(Buff): æŒç»­æœŸé—´ï¼Œæ”»å‡»é€Ÿåº¦ç¿»å€ã€‚"""
    display_name = "ç‹‚çƒ­"
    duration     = 8.0 # å‡è®¾æŒç»­8ç§’

    def on_tick(self, wearer, dt):
        self.remaining -= dt
        if self.remaining <= 0:
            wearer.remove_buff(self)
            wearer.recalculate_stats() # Buffæ¶ˆå¤±åï¼Œéœ€è¦é‡ç®—å±æ€§

class SunfireAuraDebuff(Buff):
    """ã€æ—¥ç‚ç¼çƒ§ã€‘(Debuff): æ¯ç§’å—åˆ°æ–½åŠ è€…æœ€å¤§ç”Ÿå‘½å€¼5%çš„çœŸå®ä¼¤å®³ã€‚"""
    display_name = "æ—¥ç‚ç¼çƒ§"
    is_debuff    = True

    def __init__(self, source_char):
        super().__init__()
        self.source = source_char # éœ€è¦çŸ¥é“æ˜¯è°æ–½åŠ çš„
        self._timer = 0.0

    def on_tick(self, wearer, dt):
        self._timer += dt
        if self._timer >= 1.0:
            self._timer -= 1.0
            from damage import DamagePacket, DamageType
            damage = self.source.max_hp * 0.05
            packet = DamagePacket(damage, DamageType.TRUE, source=self.source, is_dot=True)
            wearer.take_damage(packet)

class CovenantOfFateBuff(Buff):
    """ã€å‘½è¿å¥‘çº¦ã€‘(Buff): æŒç»­æœŸé—´ï¼Œä½ å—åˆ°ä¼¤å®³æ—¶ï¼Œæ”»å‡»è€…ä¹Ÿä¼šå—åˆ°ç­‰é‡çš„çœŸå®ä¼¤å®³ã€‚"""
    display_name = "å‘½è¿å¥‘çº¦"
    duration     = 10.0 # å‡è®¾æŒç»­10ç§’

    def on_tick(self, wearer, dt):
        self.remaining -= dt
        if self.remaining <= 0:
            wearer.remove_buff(self)

    def on_attacked(self, wearer, attacker, dmg):
        if attacker and attacker.hp > 0 and dmg > 0:
            from damage import DamagePacket, DamageType
            print(f"[å‘½è¿å¥‘çº¦] å¯¹ {attacker.name} åå¼¹äº† {int(dmg)} ç‚¹çœŸå®ä¼¤å®³ï¼")
            packet = DamagePacket(dmg, DamageType.TRUE, source=wearer)
            attacker.take_damage(packet)
            
class StormDebuff(Buff):
    """ã€é£æš´å°è®°ã€‘(Debuff): æ¯æ¬¡å—åˆ°ä¼¤å®³æ—¶ï¼Œé¢å¤–æ‰¿å—ç­‰åŒäºé£æš´å°è®°å±‚æ•°çš„ä¼¤å®³ã€‚"""
    display_name = "é£æš´"
    dispellable  = True
    is_debuff    = True
    max_stacks   = 99

    def before_take_damage(self, wearer, packet: DamagePacket):
        if packet.amount > 0:
            print(f"[é£æš´å°è®°] é¢å¤–é€ æˆ {self.stacks} ç‚¹ä¼¤å®³ï¼")
            packet.amount += self.stacks


================================================================================
### æ–‡ä»¶è·¯å¾„: Character.py
================================================================================

# Character.py (æœ€ç»ˆå®Œæ•´ç‰ˆ)
import pygame
import sys
import time
import collections
import math
import random
# from rich.console import Console  <- No longer needed
# console = Console()

import Buffs
import Talents
import Equips
from damage import DamagePacket, DamageType
from settings import RARITY_COLORS
from ui import format_damage_log

RARITY_GOLD_VALUE = {"common": 10, "uncommon": 25, "rare": 60, "epic": 150, "legendary": 400, "mythic": 1000}

class Character:
    DEFAULT_SLOT_CAPACITY = {"weapon": 1, "offhand": 1, "helmet": 1, "armor": 1, "pants": 1, "accessory": 4}

    # File: Character.py (Replace this method)
    def __init__(self, name, hp, defense, magic_resist, attack, attack_speed,
                equipment=None, talents=None, id=None):

        self.id = id or name
        self.name, self.level, self.gold = name, 1, 0
        self.exp, self.exp_to_next_level, self.backpack = 0, 100, []
        self.SLOT_CAPACITY = self.DEFAULT_SLOT_CAPACITY.copy()
        self.max_talent_slots = 3
        self.learned_talents = talents or []
        
        # --- CORE FIX: Initialize equipped_talents with None placeholders ---
        self.equipped_talents = [None] * self.max_talent_slots
        
        self.buffs = []
        self.shield = 0
        self._cd = 0.0
        self.crit_chance = 0.0
        self.crit_multiplier = 1.5
        self.last_damage = 0
        self.last_hits = collections.deque(maxlen=5)
        self.damage_resistance = 0.0

        self._innate_max_hp, self._innate_defense, self._innate_attack, self._innate_attack_speed = hp, defense, attack, attack_speed
        self.magic_resist = magic_resist
        
        self.slots = {
            slot: [None] * capacity for slot, capacity in self.SLOT_CAPACITY.items()
        }
        
        for eq in (equipment or []):
            self.equip(eq)

        self.base_max_hp, self.base_defense, self.base_attack, self.base_attack_speed = 0, 0, 0, 0
        
        # Temporarily store learned talents to equip them after stats are ready
        initial_talents_to_equip = self.learned_talents[:]
        self.learned_talents = [] # Clear and re-learn to ensure no duplicates
        
        for talent in initial_talents_to_equip:
            self.learn_talent(talent)
            self.equip_talent(talent) # This will now work correctly

        # Final stat calculation after initial equipment and talents
        self.recalculate_stats()
        self.hp = self.max_hp
            
    def add_gold(self, amount, source=""):
        if amount <= 0: return None
        self.gold += amount
        source_text = f" ({source})" if source else ""
        return f"è·å¾—äº† {amount} Gï¼{source_text} (å½“å‰: {self.gold} G)"

    # æ–‡ä»¶: Character.py (æ›¿æ¢è¿™ä¸ªå‡½æ•°)

    def pickup_item(self, item_to_pickup):
        """æ‹¾å–ç‰©å“ï¼ŒåŒ…å«æ›´å®Œå–„çš„é‡å¤åˆ¤å®šå’Œè°ƒè¯•ä¿¡æ¯ã€‚"""
        from Equips import UPGRADE_MAP
        
        item_name = getattr(item_to_pickup, 'display_name', item_to_pickup.__class__.__name__)
        print(f"\n--- æ­£åœ¨å°è¯•æ‹¾å–: {item_name} ---")

        all_current_items = self.backpack + self.all_equipment
        
        # åˆ¤å®šè§„åˆ™ 1: æ˜¯å¦å·²å­˜åœ¨åŒåç‰©å“
        is_duplicate_by_name = any(getattr(item, 'display_name', '') == item_name for item in all_current_items)
        if is_duplicate_by_name:
            print(f"è°ƒè¯•ä¿¡æ¯: å‘ç°åŒåç‰©å“ '{item_name}'ï¼Œåˆ¤å®šä¸ºé‡å¤ã€‚")

        # åˆ¤å®šè§„åˆ™ 2: æ˜¯å¦å·²æ‹¥æœ‰è¯¥ç‰©å“çš„å‡çº§ç‰ˆ (æ–°åŠŸèƒ½)
        is_inferior_version = False
        item_class = item_to_pickup.__class__
        if item_class in UPGRADE_MAP:
            upgraded_class = UPGRADE_MAP[item_class]
            if any(isinstance(item, upgraded_class) for item in all_current_items):
                is_inferior_version = True
                print(f"è°ƒè¯•ä¿¡æ¯: å·²æ‹¥æœ‰ '{item_name}' çš„å‡çº§ç‰ˆï¼Œåˆ¤å®šä¸ºé‡å¤ã€‚")

        # æœ€ç»ˆåˆ¤å®š
        is_duplicate = is_duplicate_by_name or is_inferior_version
        print(f"æœ€ç»ˆåˆ¤å®šç»“æœ: is_duplicate = {is_duplicate}")

        if is_duplicate:
            print("æ‰§è¡Œæ“ä½œ: è½¬åŒ–ä¸ºé‡‘å¸ã€‚")
            rarity = getattr(item_to_pickup, 'rarity', 'common')
            gold_value = RARITY_GOLD_VALUE.get(rarity, 5)
            return self.add_gold(gold_value, source=f"è½¬åŒ–({item_name})")
        else:
            print("æ‰§è¡Œæ“ä½œ: æ”¾å…¥èƒŒåŒ…ã€‚")
            self.backpack.append(item_to_pickup)
            return f"ç‰©å“ã€Œ{item_name}ã€å·²æ”¾å…¥ä½ çš„èƒŒåŒ…ã€‚"
        
    # ... (å…¶ä»–æ‰€æœ‰æ–¹æ³•éƒ½ä¿æŒä¸å˜)
    def learn_talent(self, talent_to_learn):
        if not any(isinstance(t, talent_to_learn.__class__) for t in self.learned_talents):
            self.learned_talents.append(talent_to_learn)
            print(f"å­¦ä¼šäº†æ–°å¤©èµ‹: {talent_to_learn.display_name}")
            return True
        return False

    # File: Character.py (Replace this method)
    def equip_talent(self, talent_to_equip, specific_index=None):
        if talent_to_equip not in self.learned_talents:
            print("å°šæœªå­¦ä¼šè¯¥å¤©èµ‹ï¼")
            return False
        if talent_to_equip in self.equipped_talents:
            print("è¯¥å¤©èµ‹å·²è¢«è£…å¤‡ã€‚")
            return False

        # If a specific slot is targeted
        if specific_index is not None:
            if 0 <= specific_index < self.max_talent_slots:
                if self.equipped_talents[specific_index] is None:
                    self.equipped_talents[specific_index] = talent_to_equip
                    self.recalculate_stats()
                    print(f"å·²è£…å¤‡å¤©èµ‹: {talent_to_equip.display_name} åˆ°æ§½ä½ {specific_index}")
                    return True
                else: # Slot is occupied, this should be handled by swap logic in the UI
                    return False 
        
        # If no specific slot, find the first empty one
        else:
            try:
                empty_index = self.equipped_talents.index(None)
                self.equipped_talents[empty_index] = talent_to_equip
                self.recalculate_stats()
                print(f"å·²è£…å¤‡å¤©èµ‹: {talent_to_equip.display_name} åˆ°æ§½ä½ {empty_index}")
                return True
            except ValueError:
                print("å¤©èµ‹æ§½å·²æ»¡ï¼")
                return False
            
    # File: Character.py (Replace this method)
    def unequip_talent(self, talent_to_unequip):
        if talent_to_unequip not in self.equipped_talents:
            return
        # Find the talent and replace it with None, instead of removing it
        index = self.equipped_talents.index(talent_to_unequip)
        self.equipped_talents[index] = None
        self.recalculate_stats()
        print(f"å·²å¸ä¸‹å¤©èµ‹: {talent_to_unequip.display_name}")
        
    def on_enter_combat(self):
        self.buffs.clear(); self.hp = self.max_hp; self.shield = 0; self._cd = 0.0;

        # æ–°å¢é€»è¾‘ï¼šé‡ç½®è£…å¤‡çš„æˆ˜æ–—å†…çŠ¶æ€
        for eq in self.all_equipment:
            if isinstance(eq, Equips.AdventurersPouch):
                eq.atk_bonus = 0 # æˆ˜æ–—å‡†å¤‡æ—¶ï¼Œå°†é’±è¢‹çš„åŠ æˆæ¸…é›¶

        # é‡ç½®å®Œåå†é‡ç®—ä¸€æ¬¡å±æ€§ï¼Œç¡®ä¿ä¸€ä¸ªå¹²å‡€çš„çŠ¶æ€
        self.recalculate_stats() 
        print(f"{self.name} å·²è¿›å…¥æˆ˜æ–—å‡†å¤‡çŠ¶æ€ï¼")

    # æ–‡ä»¶: Character.py (è¯·ç”¨è¿™ä¸ªæ–°ç‰ˆæœ¬æ›¿æ¢æ•´ä¸ª update å‡½æ•°)

    # æ–‡ä»¶: Character.py (è¿˜åŸ update å‡½æ•°)
    def update(self, dt) -> list[str]:
        texts = []
        for buff in list(self.buffs):
            if hasattr(buff, "on_tick"):
                res = buff.on_tick(self, dt)
                if isinstance(res, str) and res:
                    texts.append(res) # æ¢å¤æˆåªå¤„ç†å­—ç¬¦ä¸²
        for eq in self.all_equipment:
            if hasattr(eq, "on_tick"):
                res = eq.on_tick(self, dt)
                if isinstance(res, str) and res:
                    texts.append(res)
        return texts

    def recalculate_stats(self):
        hp_percent = self.hp / self.max_hp if hasattr(self, 'max_hp') and self.max_hp > 0 else 1
        self.base_max_hp = self._innate_max_hp
        self.base_defense = self._innate_defense
        self.base_attack = self._innate_attack
        self.base_attack_speed = self._innate_attack_speed
        all_eq = self.all_equipment
        self.base_max_hp += sum(getattr(eq, "hp_bonus", 0) for eq in all_eq)
        self.base_defense += sum(getattr(eq, "def_bonus", 0) for eq in all_eq)
        self.base_attack += sum(getattr(eq, "atk_bonus", 0) for eq in all_eq)
        self.base_attack_speed += sum(getattr(eq, "as_bonus", 0) for eq in all_eq)
        self.max_hp = self.base_max_hp
        self.defense = self.base_defense
        self.attack = self.base_attack
        self.attack_speed = self.base_attack_speed
        self.crit_chance = 0.0 
        self.magic_resist = 3 
        self.damage_resistance = 0.0
        self.SLOT_CAPACITY = self.DEFAULT_SLOT_CAPACITY.copy()
        for talent in self.equipped_talents:
            if hasattr(talent, 'on_init'):
                talent.on_init(self)
        for slot, required_capacity in self.SLOT_CAPACITY.items():
            current_slots = self.slots.get(slot, [])
            current_capacity = len(current_slots)
            if current_capacity < required_capacity:
                current_slots.extend([None] * (required_capacity - current_capacity))
            elif current_capacity > required_capacity:
                extra_items = current_slots[required_capacity:]
                for item in extra_items:
                    if item: self.backpack.append(item)
                self.slots[slot] = current_slots[:required_capacity]
        
        # --- æ–°å¢ï¼šå¤„ç†ç‰¹æ®ŠBuffå’ŒDebuffå¯¹å±æ€§çš„ç›´æ¥å½±å“ ---
        self.defense -= sum(b.stacks for b in self.buffs if isinstance(b, Buffs.SunderDebuff))
        self.defense = max(0, self.defense) # é˜²å¾¡ä¸èƒ½ä¸ºè´Ÿ
        if any(isinstance(b, Buffs.FrenzyBuff) for b in self.buffs):
            self.attack_speed *= 2
        # --- æ–°å¢ç»“æŸ ---

        self.magic_resist += sum(getattr(eq, "magic_resist_bonus", 0) for eq in all_eq)
        self.crit_chance += sum(getattr(eq, "crit_bonus", 0) for eq in all_eq)
        self.hp = min(self.max_hp, self.max_hp * hp_percent)
        self.attack_interval = 6.0 / self.attack_speed if self.attack_speed > 0 else 999
        print("è§’è‰²å±æ€§å·²æ›´æ–°ï¼")

    @property
    def all_equipment(self):
        eqs = []
        for eq_list in self.slots.values():
            # ç­›é€‰å‡ºä¸æ˜¯ None çš„çœŸå®è£…å¤‡
            eqs.extend([item for item in eq_list if item is not None])
        return eqs

# --- 3. å®Œæ•´æ›¿æ¢ equip æ–¹æ³• ---
    def equip(self, eq_to_equip, specific_index=None):
        """è£…å¤‡ä¸€ä»¶ç‰©å“ï¼Œå¯ä»¥æŒ‡å®šç²¾ç¡®çš„æ§½ä½ç´¢å¼•ã€‚"""
        slot = eq_to_equip.slot
        if slot not in self.SLOT_CAPACITY:
            raise ValueError(f"æœªçŸ¥æ’æ§½ï¼š{slot}")

        # å¦‚æœæŒ‡å®šäº†ç´¢å¼•
        if specific_index is not None:
            if 0 <= specific_index < self.SLOT_CAPACITY[slot]:
                # å¸ä¸‹ç›®æ ‡æ§½ä½åŸæœ‰çš„ç‰©å“
                unequipped_item = self.slots[slot][specific_index]
                # ç©¿ä¸Šæ–°ç‰©å“
                self.slots[slot][specific_index] = eq_to_equip
                self.recalculate_stats()
                return unequipped_item # è¿”å›è¢«æ›¿æ¢ä¸‹çš„ç‰©å“ (å¯èƒ½æ˜¯None)
            else:
                return eq_to_equip # ç´¢å¼•æ— æ•ˆï¼Œè£…å¤‡å¤±è´¥

        # å¦‚æœæœªæŒ‡å®šç´¢å¼•ï¼Œåˆ™è‡ªåŠ¨å¯»æ‰¾ç©ºä½
        else:
            try:
                # æ‰¾åˆ°ç¬¬ä¸€ä¸ªç©ºæ§½ä½ (å€¼ä¸ºNone)
                empty_index = self.slots[slot].index(None)
                self.slots[slot][empty_index] = eq_to_equip
                self.recalculate_stats()
                return None # æˆåŠŸè£…å¤‡åˆ°ç©ºæ§½ï¼Œæ²¡æœ‰ç‰©å“è¢«æ›¿æ¢
            except ValueError:
                # å¦‚æœæ‰¾ä¸åˆ°Noneï¼Œè¯´æ˜æ§½ä½å·²æ»¡
                # å¯¹äºå•æ§½ä½ï¼Œç›´æ¥æ›¿æ¢
                if self.SLOT_CAPACITY[slot] == 1:
                    unequipped_item = self.slots[slot][0]
                    self.slots[slot][0] = eq_to_equip
                    self.recalculate_stats()
                    return unequipped_item
                else: # å¤šæ§½ä½å·²æ»¡ä¸”æœªæŒ‡å®šç´¢å¼•ï¼Œåˆ™å¤±è´¥
                    print(f"è­¦å‘Š: {slot} æ’æ§½å·²æ»¡ä¸”æœªæŒ‡å®šæ›¿æ¢ä½ç½®")
                    return eq_to_equip

# --- 4. å®Œæ•´æ›¿æ¢ unequip æ–¹æ³• ---
    def unequip(self, eq_to_unequip):
        """ä»è§’è‰²èº«ä¸Šå¸ä¸‹æŒ‡å®šçš„è£…å¤‡ã€‚"""
        slot = eq_to_unequip.slot
        if eq_to_unequip in self.slots[slot]:
            # æ‰¾åˆ°ç‰©å“çš„ç´¢å¼•
            index = self.slots[slot].index(eq_to_unequip)
            # å°†è¯¥ä½ç½®è®¾ç½®å› None
            self.slots[slot][index] = None
            self.recalculate_stats()
            return eq_to_unequip # è¿”å›è¢«å¸ä¸‹çš„ç‰©å“
        return None

    def take_damage(self, packet: DamagePacket):
        """
        è§’è‰²å—åˆ°ä¼¤å®³çš„æ ¸å¿ƒå¤„ç†å‡½æ•°ã€‚
        å¢åŠ äº†â€œè®°å½•æœ€åæ”»å‡»è€…â€çš„åŠŸèƒ½ã€‚
        """
        # ### æ ¸å¿ƒä¿®å¤ 2ï¼šè®°å½•ä¼¤å®³æ¥æº ###

        # è§¦å‘é’©å­ï¼šå—åˆ°ä¼¤å®³å‰
        for buff in list(self.buffs):
            if hasattr(buff, 'before_take_damage'): buff.before_take_damage(self, packet)
        for eq in self.all_equipment:
            if hasattr(eq, 'before_take_damage'): eq.before_take_damage(self, packet)

        initial_amount_after_hooks = packet.amount
        final_shield_absorbed = 0

        # 1. æŠ¤ç›¾å¸æ”¶
        if self.shield > 0 and packet.amount > 0:
            absorbed = min(self.shield, packet.amount)
            self.shield -= absorbed
            packet.amount -= absorbed
            final_shield_absorbed = absorbed

        # 2. è®¡ç®—ä¼¤å®³å‡å…
        final_hp_deduction = 0
        if packet.amount > 0:
            reduction = 0.0
            if packet.damage_type not in [DamageType.TRUE] and not packet.ignores_armor:
                if packet.damage_type == DamageType.PHYSICAL:
                    reduction = self.defense / (self.defense + 100)
                elif packet.damage_type == DamageType.MAGIC:
                    reduction = self.magic_resist / (self.magic_resist + 100)
            final_hp_deduction = packet.amount * (1.0 - reduction)

        # 3. æœ€ç»ˆæ‰£è¡€
        final_hp_deduction = max(0, int(final_hp_deduction))
        self.hp -= final_hp_deduction
        if self.hp < 0: self.hp = 0

        # 4. è§¦å‘é’©å­ï¼šå—åˆ°ä¼¤å®³å
        if packet.source:
            self.on_attacked(packet.source, final_hp_deduction)

        # 5. è¿”å›ä¼¤å®³æŠ¥å‘Š
        return {
            "source": packet.source,
            "target": self,
            "final_amount": final_hp_deduction,
            "shield_absorbed": int(final_shield_absorbed),
            "damage_type": packet.damage_type,
            "is_critical": packet.is_critical,
            "is_dot": packet.is_dot,
            "is_fatal": self.hp <= 0,
        }

    # --- é™„å¸¦ä¿®æ”¹ï¼šç¡®ä¿ on_attacked ä¹Ÿè¢«è°ƒç”¨ ---
    # (ä½ çš„ä»£ç ä¸­ç¼ºå°‘è¿™ä¸ªå‡½æ•°ï¼Œè¯·åœ¨ take_damage å‡½æ•°ä¸‹æ–¹æ·»åŠ å®ƒ)
    def on_attacked(self, attacker, dmg):
        """æ¯æ¬¡è¢«æ”»å‡»åè§¦å‘"""
        for b in self.buffs:
            if hasattr(b, "on_attacked"):
                b.on_attacked(self, attacker, dmg)
        for eq in self.all_equipment:
            if hasattr(eq, "on_attacked"):
                eq.on_attacked(self, attacker, dmg)

    def try_attack(self, target, dt):
        if any(getattr(b, "disable_attack", False) for b in self.buffs): return None
        self._cd += dt
        if self._cd < self.attack_interval or self.hp <= 0: return None

        # ... (å‡†å¤‡ä¼¤å®³åŒ…è£¹å’Œè°ƒç”¨é’©å­çš„éƒ¨åˆ†ä¿æŒä¸å˜) ...
        is_crit = (random.random() < self.crit_chance)
        damage = self.attack * self.crit_multiplier if is_crit else self.attack
        packet = DamagePacket(amount=damage, damage_type=DamageType.PHYSICAL, source=self, is_critical=is_crit)
        
        for t in self.equipped_talents:
            if t and hasattr(t, "before_attack"): t.before_attack(self, target, packet)
        for eq in self.all_equipment:
            if hasattr(eq, "before_attack"): eq.before_attack(self, target, packet)

        damage_details = target.take_damage(packet)
        actual_dmg = damage_details["final_amount"]
        
        # ... (æ”»å‡»åé’©å­é€»è¾‘ä¿æŒä¸å˜) ...
        extra_texts = []
        for t in self.equipped_talents:
            if t and hasattr(t, "on_attack"):
                out = t.on_attack(self, target, actual_dmg)
                if out: extra_texts.extend(out)
        self._cd -= self.attack_interval

        log_parts = format_damage_log(damage_details, action_name="æ™®æ”»")

        # 4. è¿”å›è¿™ä¸ªå¯Œæ–‡æœ¬åˆ—è¡¨å’Œé¢å¤–ä¿¡æ¯
        return (log_parts, extra_texts)


    def perform_extra_attack(self, target):
        """
        æ‰§è¡Œä¸€æ¬¡æ ‡å‡†åŒ–çš„é¢å¤–æ”»å‡»ã€‚
        è¿™ä¸ªæ–¹æ³•ç°åœ¨ä¼šè‡ªå·±å¤„ç†ä¼¤å®³è®¡ç®—å’Œæ—¥å¿—è®°å½•ã€‚
        """
        from battle_logger import battle_logger, format_damage_log
        
        # 1. å‡†å¤‡ä¼¤å®³åŒ…è£¹ (ä¸ try_attack é€»è¾‘ä¸€è‡´)
        is_crit = (random.random() < self.crit_chance)
        damage = self.attack * self.crit_multiplier if is_crit else self.attack
        packet = DamagePacket(amount=damage, damage_type=DamageType.PHYSICAL, source=self, is_critical=is_crit)
        
        # 2. è§¦å‘æ”»å‡»å‰é’©å­
        for eq in self.all_equipment:
            if hasattr(eq, "before_attack"): eq.before_attack(self, target, packet)
        
        # 3. é€ æˆä¼¤å®³å¹¶è·å–ä¼¤å®³æŠ¥å‘Š
        damage_details = target.take_damage(packet)
        actual_dmg = damage_details["final_amount"]
        
        # 4. ä½¿ç”¨æ ‡å‡†å·¥å…·æ ¼å¼åŒ–æ—¥å¿—å¹¶æ’­æŠ¥
        log_parts = format_damage_log(damage_details, action_name="é¢å¤–æ”»å‡»")
        battle_logger.log(log_parts)
        
        # 5. è§¦å‘æ”»å‡»åé’©å­
        for eq in self.all_equipment:
            if hasattr(eq, "after_attack"): eq.after_attack(self, target, actual_dmg)
        if is_crit:
            for eq in self.all_equipment:
                if hasattr(eq, "on_critical"): eq.on_critical(self, target, actual_dmg)
        else:
            for eq in self.all_equipment:
                if hasattr(eq, "on_non_critical"): eq.on_non_critical(self, target, actual_dmg)
                

    
    def heal(self, amount: float, combat_target=None) -> float:
        # é’©å­ï¼šæ²»ç–—å‰
        for buff in list(self.buffs):
            if hasattr(buff, 'before_healed'):
                amount = buff.before_healed(self, amount)

        healed = min(self.max_hp - self.hp, amount)
        if healed <= 0: return 0.0
        self.hp += healed

        # é’©å­ï¼šæ²»ç–—å
        for talent in list(self.equipped_talents):
            if talent and hasattr(talent, 'on_healed'):
                talent.on_healed(self, healed, combat_target)

        return healed
        
    def add_status(self, status: Buffs.Buff, *, source: "Character" = None):
        final_buff = None
        added_stacks = status.stacks
        for b in self.buffs:
            if isinstance(b, status.__class__):
                if b.max_stacks == 1:
                    b.remaining = b.duration
                else:
                    b.stacks = min(b.stacks + status.stacks, b.max_stacks)
                final_buff = b
                break
        if final_buff is None:
            final_buff = status
            self.buffs.append(status)
            status.on_apply(self)
        
        # --- æ–°å¢çš„é’©å­ ---
        # è§¦å‘è£…å¤‡çš„ on_buff_applied æ•ˆæœ
        for eq in self.all_equipment:
            if hasattr(eq, 'on_buff_applied'):
                eq.on_buff_applied(self, final_buff)
        # --- é’©å­ç»“æŸ ---

        if source is not None and source is not self and getattr(final_buff, "is_debuff", False):
            for t in source.equipped_talents: # æ³¨æ„ï¼šè¿™é‡Œæ£€æŸ¥çš„æ˜¯ source çš„å¤©èµ‹
                if hasattr(t, "on_inflict_debuff"):
                    t.on_inflict_debuff(source, self, final_buff, added_stacks)
        if getattr(final_buff, "dispellable", False) and getattr(final_buff, "is_debuff", False):
            for t in self.equipped_talents:
                if hasattr(t, "on_debuff_applied"):
                    t.on_debuff_applied(self, final_buff)
                    
    add_buff, add_debuff = add_status, add_status

    def remove_buff(self, buff): self.buffs.remove(buff); buff.on_remove(self)

    def add_exp(self, amount):
        if self.hp <= 0: return []
        
        original_amount = amount
        if any(isinstance(t, Talents.Adventurer) for t in self.equipped_talents):
            bonus_amount = int(original_amount * 0.5)
            amount += bonus_amount
            print(f"[å†’é™©è€…] å¤©èµ‹è§¦å‘ï¼é¢å¤–è·å¾— {bonus_amount} ç‚¹ç»éªŒï¼")
        self.exp += amount
        messages = [f"è·å¾—äº† {amount} ç‚¹ç»éªŒï¼ (å½“å‰: {self.exp}/{self.exp_to_next_level})"]
        if self.exp >= self.exp_to_next_level:
            messages.extend(self.level_up())
        return messages

    def level_up(self):
        level_up_messages = []
        while self.exp >= self.exp_to_next_level:
            self.level += 1; self.exp -= self.exp_to_next_level; self.exp_to_next_level = int(self.exp_to_next_level * 1.5)
            self._innate_max_hp += 10; self._innate_attack += 2; self._innate_defense += 1
            self.recalculate_stats()
            level_up_messages.append(f"ğŸ‰ ç­‰çº§æå‡ï¼ç°åœ¨æ˜¯ {self.level} çº§ï¼"); level_up_messages.append("   ç”Ÿå‘½+10ï¼Œæ”»å‡»+2ï¼Œé˜²å¾¡+1")
        return level_up_messages
    
    def gain_level(self, levels=1):
        """(æ²™ç›’ä¸“ç”¨) æå‡ç­‰çº§å¹¶å¢åŠ åŸºç¡€å±æ€§"""
        self.level += levels
        # æŒ‰ç…§ level_up çš„æ ‡å‡†å¢åŠ å›ºæœ‰å±æ€§
        self._innate_max_hp += 10 * levels
        self._innate_attack += 2 * levels
        self._innate_defense += 1 * levels
        self.recalculate_stats()
        self.hp = self.max_hp # å‡çº§åå›æ»¡è¡€
        print(f"ç­‰çº§æå‡è‡³ {self.level} çº§ã€‚")

    def lose_level(self, levels=1):
        """(æ²™ç›’ä¸“ç”¨) é™ä½ç­‰çº§å¹¶å‡å°‘åŸºç¡€å±æ€§"""
        # é˜²æ­¢é™åˆ°1çº§ä»¥ä¸‹
        actual_levels_lost = min(levels, self.level - 1)
        if actual_levels_lost <= 0:
            return
            
        self.level -= actual_levels_lost
        self._innate_max_hp -= 10 * actual_levels_lost
        self._innate_attack -= 2 * actual_levels_lost
        self._innate_defense -= 1 * actual_levels_lost
        self.recalculate_stats()
        self.hp = self.max_hp # é™çº§åä¹Ÿå›æ»¡è¡€
        print(f"ç­‰çº§é™ä½è‡³ {self.level} çº§ã€‚")


================================================================================
### æ–‡ä»¶è·¯å¾„: combine_code.py
================================================================================

import os
import datetime

# --- é…ç½® ---
# è¦æœç´¢çš„æ ¹æ–‡ä»¶å¤¹ ('.' ä»£è¡¨å½“å‰æ–‡ä»¶å¤¹)
ROOT_DIR = '.'
# è¦åŒ…å«çš„æ–‡ä»¶æ‰©å±•å
FILE_EXTENSIONS = ('.py', '.json')
# è¾“å‡ºæ–‡ä»¶å
OUTPUT_FILE = 'combined_code.txt'
# --- ç»“æŸé…ç½® ---

def combine_files():
    """
    éå†æŒ‡å®šç›®å½•åŠå…¶å­ç›®å½•ï¼Œå°†ç‰¹å®šæ‰©å±•åçš„æ–‡ä»¶å†…å®¹åˆå¹¶åˆ°ä¸€ä¸ªæ–‡ä»¶ä¸­ã€‚
    """
    print(f"å¼€å§‹æ‰«ææ–‡ä»¶å¤¹: {os.path.abspath(ROOT_DIR)}")
    print(f"å°†è¦åˆå¹¶çš„æ–‡ä»¶ç±»å‹: {FILE_EXTENSIONS}")
    
    # ä½¿ç”¨ with è¯­å¥ç¡®ä¿æ–‡ä»¶è¢«æ­£ç¡®å…³é—­
    with open(OUTPUT_FILE, 'w', encoding='utf-8') as outfile:
        # å†™å…¥æ–‡ä»¶å¤´éƒ¨ä¿¡æ¯
        outfile.write(f"--- ä»£ç åˆé›†ç”Ÿæˆäº: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')} ---\n")
        outfile.write(f"--- æ ¹ç›®å½•: {os.path.abspath(ROOT_DIR)} ---\n\n")
        
        # os.walk() ä¼šé€’å½’åœ°éå†ç›®å½•
        for dirpath, _, filenames in os.walk(ROOT_DIR):
            for filename in filenames:
                # æ£€æŸ¥æ–‡ä»¶æ‰©å±•åæ˜¯å¦ç¬¦åˆè¦æ±‚
                if filename.endswith(FILE_EXTENSIONS):
                    # æ„å»ºå®Œæ•´çš„æ–‡ä»¶è·¯å¾„
                    file_path = os.path.join(dirpath, filename)
                    # è·å–ç›¸å¯¹è·¯å¾„ï¼Œè¿™æ ·æ›´æ¸…æ™°
                    relative_path = os.path.relpath(file_path, ROOT_DIR)
                    
                    print(f"æ­£åœ¨æ·»åŠ æ–‡ä»¶: {relative_path}")
                    
                    # å†™å…¥æ–‡ä»¶åˆ†éš”ç¬¦å’Œè·¯å¾„ä¿¡æ¯
                    outfile.write("=" * 80 + "\n")
                    outfile.write(f"### æ–‡ä»¶è·¯å¾„: {relative_path}\n")
                    outfile.write("=" * 80 + "\n\n")
                    
                    try:
                        # è¯»å–æºæ–‡ä»¶å†…å®¹å¹¶å†™å…¥è¾“å‡ºæ–‡ä»¶
                        with open(file_path, 'r', encoding='utf-8') as infile:
                            outfile.write(infile.read())
                        outfile.write("\n\n\n") # åœ¨æ–‡ä»¶æœ«å°¾æ·»åŠ ä¸€äº›ç©ºè¡Œä»¥ä½œåŒºåˆ†
                    except Exception as e:
                        # å¦‚æœæ–‡ä»¶è¯»å–å¤±è´¥ï¼ˆä¾‹å¦‚å› ä¸ºç¼–ç é—®é¢˜ï¼‰ï¼Œåˆ™è®°å½•é”™è¯¯ä¿¡æ¯
                        outfile.write(f"*** æ— æ³•è¯»å–æ–‡ä»¶: {relative_path} | é”™è¯¯: {e} ***\n\n\n")

    print(f"\næˆåŠŸï¼æ‰€æœ‰ä»£ç å·²æ•´åˆåˆ°æ–‡ä»¶: {OUTPUT_FILE}")

if __name__ == '__main__':
    combine_files()


================================================================================
### æ–‡ä»¶è·¯å¾„: damage.py
================================================================================

# damage.py
from enum import Enum, auto

class DamageType(Enum):
    PHYSICAL = auto()      # æ™®é€šç‰©ç†ä¼¤å®³
    MAGIC = auto()         # é­”æ³•ä¼¤å®³
    TRUE = auto()          # çœŸå®ä¼¤å®³
    POISON = auto()        # æ¯’ç³»ä¼¤å®³
    DRAGON_SOURCE = auto() # é¾™æºä¼¤å®³

class DamagePacket:
    """ä¸€ä¸ªç”¨æ¥å°è£…æ‰€æœ‰ä¼¤å®³ä¿¡æ¯çš„æ•°æ®ç»“æ„"""
    def __init__(self, amount, damage_type, source=None,
                 is_critical=False, is_dot=False, 
                 is_sourceless=False, ignores_armor=False):
        
        self.amount = amount               # åŸºç¡€ä¼¤å®³æ•°å€¼
        self.damage_type = damage_type     # ä¼¤å®³ç±»å‹ (ç‰©ç†, é­”æ³•, çœŸå®...)
        self.source = source               # ä¼¤å®³æ¥æº (å“ªä¸ªè§’è‰²)
        
        # --- å„ç§æ ‡å¿— (Flags) ---
        self.is_critical = is_critical         # æ˜¯å¦æš´å‡»
        self.is_dot = is_dot                   # æ˜¯å¦ä¸ºæŒç»­ä¼¤å®³(DOT)
        self.is_sourceless = is_sourceless     # æ˜¯å¦ä¸ºæ— æ¥æºä¼¤å®³ (å¦‚ç¯å¢ƒã€åä¼¤)
        self.ignores_armor = ignores_armor     # æ˜¯å¦ç©¿ç”² (æ— è§†é˜²å¾¡)

    def copy(self):
        """åˆ›å»ºä¸€ä¸ªå‰¯æœ¬ï¼Œæ–¹ä¾¿åœ¨è®¡ç®—è¿‡ç¨‹ä¸­ä¿®æ”¹è€Œä¸å½±å“åŸå§‹åŒ…"""
        return DamagePacket(
            self.amount, self.damage_type, self.source,
            self.is_critical, self.is_dot, self.is_sourceless, self.ignores_armor
        )


================================================================================
### æ–‡ä»¶è·¯å¾„: dungeon_generator.py
================================================================================

# æ–‡ä»¶: dungeon_generator.py (å®Œæ•´æ›¿æ¢)

import random
from settings import SCREEN_WIDTH, SCREEN_HEIGHT

class Room:
    def __init__(self, x, y, room_type="combat"):
        self.x, self.y, self.type = x, y, room_type
        self.doors = {"N": False, "S": False, "E": False, "W": False}
        self.is_cleared = False
        self.monsters = []
        # ä½ è¿˜å¯ä»¥æ·»åŠ  event_id, treasure_contents ç­‰å­—æ®µ

class Floor:
    def __init__(self, width=21, height=21):
        self.width, self.height = width, height
        self.rooms, self.start_room, self.boss_room = {}, None, None

    def generate_floor(self, num_rooms=8, floor_data=None):
        """
        ä½¿ç”¨ä¼ å…¥çš„ floor_data åŠ¨æ€ç”Ÿæˆæ¥¼å±‚å†…å®¹
        """
        self.rooms.clear()
        grid = [[None for _ in range(self.width)] for _ in range(self.height)]
        
        # 1. åˆ›å»ºæˆ¿é—´å¸ƒå±€ (è¿™éƒ¨åˆ†é€»è¾‘ä¸å˜)
        sx, sy = self.width // 2, self.height // 2
        start_room = Room(sx, sy, "start")
        start_room.is_cleared = True
        grid[sy][sx] = start_room
        self.rooms[(sx, sy)] = start_room
        
        frontier = [(sx, sy)]
        
        while len(self.rooms) < num_rooms and frontier:
            px, py = random.choice(frontier)
            possible_neighbors = []
            directions = [(0, -1, "N", "S"), (0, 1, "S", "N"), (1, 0, "E", "W"), (-1, 0, "W", "E")]
            for dx, dy, door, opposite_door in directions:
                nx, ny = px + dx, py + dy
                if 0 <= nx < self.width and 0 <= ny < self.height and not grid[ny][nx]:
                    possible_neighbors.append((nx, ny, door, opposite_door))
            
            if possible_neighbors:
                nx, ny, door, opposite_door = random.choice(possible_neighbors)
                new_room = Room(nx, ny)
                grid[ny][nx] = new_room
                self.rooms[(nx, ny)] = new_room
                frontier.append((nx, ny))
                grid[py][px].doors[door] = True
                new_room.doors[opposite_door] = True
            else:
                frontier.remove((px, py))

        # --- 2. æ ¸å¿ƒä¿®æ”¹ï¼šæ ¹æ® floor_data å¡«å……æˆ¿é—´å†…å®¹ ---
        if not floor_data:
            print("é”™è¯¯: æœªæä¾›æ¥¼å±‚æ•°æ®ï¼Œæ— æ³•å¡«å……å†…å®¹ï¼")
            return

        # å®šä½Bossæˆ¿é—´ (é€»è¾‘ä¸å˜)
        self.start_room = self.rooms[(sx, sy)]
        farthest_dist = -1
        boss_coord = (sx, sy)
        for coord in self.rooms.keys():
            dist = abs(coord[0] - sx) + abs(coord[1] - sy)
            if dist > farthest_dist and self.rooms[coord] is not self.start_room:
                farthest_dist = dist
                boss_coord = coord
        self.boss_room = self.rooms[boss_coord]
        self.boss_room.type = "boss"
        
        # ç¡®å®šç‰¹æ®Šæˆ¿é—´ç±»å‹å’Œæ•°é‡ (é€»è¾‘ä¸å˜)
        room_type_pool = ["combat"] * 4 + ["event"] * 2 + ["treasure"]*2 + ["shop", "rest", "elite"]
        special_room_candidates = [r for r in self.rooms.values() if r.type == "combat"]
        for room_type in ["event", "treasure", "shop", "rest", "elite"]:
            if special_room_candidates:
                candidate = random.choice(special_room_candidates)
                candidate.type = room_type
                special_room_candidates.remove(candidate)

        # åŠ¨æ€å¡«å……æ€ªç‰©
        m_uid = 0
        for room in self.rooms.values():
            if room.type in ["combat", "elite", "boss"]:
                num = 1
                e_id = "slime" # é»˜è®¤å€¼

                if room.type == "boss":
                    num = 1
                    e_id = floor_data.get("boss_id", "ruin_golem")
                elif room.type == "elite":
                    num = random.randint(2, 3)
                    if floor_data.get("elite_pool"):
                        e_id = random.choice(floor_data["elite_pool"])
                else: # æ™®é€šæˆ˜æ–—
                    num = random.randint(1, 3)
                    if floor_data.get("monster_pool"):
                        e_id = random.choice(floor_data["monster_pool"])
                
                for _ in range(num):
                    px, py = random.randint(100, SCREEN_WIDTH - 100), random.randint(100, SCREEN_HEIGHT - 100)
                    room.monsters.append({'id': e_id, 'pos': (px, py), 'uid': f'm_{m_uid}'})
                    m_uid += 1


================================================================================
### æ–‡ä»¶è·¯å¾„: enemies.json
================================================================================

{
    "slime": {
        "name": "å²è±å§†",
        "stats": {
            "hp": 20,
            "defense": 2,
            "magic_resist": 0,
            "attack": 5,
            "attack_speed": 1.0
        },
        "exp_reward": 5,
        "possible_talents": [{"talent_class_name": "PoisonousTalent", "chance": 0.5}]
    },
    "goblin": {
        "name": "å“¥å¸ƒæ—",
        "stats": {
            "hp": 40,
            "defense": 4,
            "magic_resist": 2,
            "attack": 8,
            "attack_speed": 1.2
        },
        "exp_reward": 8,
        "possible_talents": [{"talent_class_name": "DualWieldTalent", "chance": 0.5}]
        
    },
    "goblin_archer": {
        "name": "å“¥å¸ƒæ—å¼“ç®­æ‰‹", "exp_reward": 30,
        "stats": {"hp": 60, "defense": 2, "magic_resist": 1, "attack": 10, "attack_speed": 1.8},
        "possible_talents": [{"talent_class_name": "FirstStrike", "chance": 0.15}]
    },
    "goblin_captain": {
        "name": "å“¥å¸ƒæ—é˜Ÿé•¿", "exp_reward": 80,
        "stats": {"hp": 150, "defense": 8, "magic_resist": 5, "attack": 18, "attack_speed": 1.2},
        "possible_talents": [{"talent_class_name": "Brawler", "chance": 0.5}]
    },
    "armored_skeleton": {
        "name": "é‡ç”²éª·é«…", "exp_reward": 40,
        "stats": {"hp": 100, "defense": 20, "magic_resist": 5, "attack": 15, "attack_speed": 0.8}
    },
    "giant_bat": {
        "name": "å·¨å‹è™è ", "exp_reward": 35,
        "stats": {"hp": 70, "defense": 3, "magic_resist": 3, "attack": 10, "attack_speed": 2.5}
    },
    "wild_boar": {
        "name": "ç‹‚é‡é‡çŒª", "exp_reward": 50,
        "stats": {"hp": 200, "defense": 5, "magic_resist": 2, "attack": 20, "attack_speed": 1.0}
    },
    "forest_spirit": {
        "name": "æ£®æ—ä¹‹çµ", "exp_reward": 60,
        "stats": {"hp": 120, "defense": 5, "magic_resist": 15, "attack": 15, "attack_speed": 1.1},
        "possible_talents": [{"talent_class_name": "MagicShield", "chance": 1.0}]
    },
    "rock_golem": {
        "name": "å²©çŸ³å‚€å„¡", "exp_reward": 70,
        "stats": {"hp": 300, "defense": 15, "magic_resist": 10, "attack": 22, "attack_speed": 0.7},
        "possible_talents": [{"talent_class_name": "Giant", "chance": 1.0}]
    },
    "ruin_golem": {
        "name": "é—è¿¹å®ˆæŠ¤è€…", "exp_reward": 200,
        "stats": {"hp": 500, "defense": 25, "magic_resist": 15, "attack": 30, "attack_speed": 0.9},
        "possible_talents": [{"talent_class_name": "LastStand", "chance": 1.0}]
    },
    "mimic": {
        "name": "å®ç®±æ€ª", "exp_reward": 100,
        "stats": {"hp": 150, "defense": 10, "magic_resist": 10, "attack": 25, "attack_speed": 1.5}

    },
    "fire_elemental": {
        "name": "ç«ç„°å…ƒç´ ", "exp_reward": 120,
        "stats": {"hp": 180, "defense": 8, "magic_resist": 20, "attack": 28, "attack_speed": 1.3},
        "possible_talents": [{"talent_class_name": "FlameAura", "chance": 1.0}]
    },
    "ice_elemental": {
        "name": "å†°éœœå…ƒç´ ", "exp_reward": 120,
        "stats": {"hp": 180, "defense": 8, "magic_resist": 20, "attack": 28, "attack_speed": 1.3},
        "possible_talents": [{"talent_class_name": "FrostAura", "chance": 1.0}]
    },
    "orc_warrior": {
        "name": "å…½äººæˆ˜å£«", "exp_reward": 150,
        "stats": {"hp": 250, "defense": 12, "magic_resist": 5, "attack": 35, "attack_speed": 1.0},
        "possible_talents": [{"talent_class_name": "Berserker", "chance": 0.5}]
    },
    "orc_shaman": {
        "name": "å…½äººè¨æ»¡", "exp_reward": 150,
        "stats": {"hp": 200, "defense": 8, "magic_resist": 15, "attack": 30, "attack_speed": 1.2},
        "possible_talents": [{"talent_class_name": "HealingWave", "chance": 0.5}]
    },
    "dark_knight": {
        "name": "é»‘æš—éª‘å£«", "exp_reward": 300,
        "stats": {"hp": 400, "defense": 20, "magic_resist": 10, "attack": 50, "attack_speed": 1.0},
        "possible_talents": [{"talent_class_name": "Executioner", "chance": 1.0}]
    },
    "necromancer": {
        "name": "æ­»çµæ³•å¸ˆ", "exp_reward": 250,
        "stats": {"hp": 300, "defense": 10, "magic_resist": 25, "attack": 40, "attack_speed": 1.1},
        "possible_talents": [{"talent_class_name": "SummonSkeletons", "chance": 1.0}]
    },
    "poisonDragon": {
        "name": "æ¯’é¾™",
        "stats": {
            "hp": 1800,
            "defense": 20,
            "magic_resist": 3,
            "attack": 18,
            "attack_speed": 1.5
        },
        "talents": [
            "PoisonousTalent",
            "BambooLeafTalent"
        ],
        "exp_reward": 800
    }
}


================================================================================
### æ–‡ä»¶è·¯å¾„: Equips.py
================================================================================

import Buffs
import Talents
from damage import DamagePacket, DamageType
from abc import ABC
import collections
from collections import defaultdict
from rich.console import Console, Group
from rich.live import Live
from rich.table import Table
from rich.panel import Panel
from rich.text import Text
import time
import random
from rich.text import Text
from rich.progress import BarColumn
import math
from collections import Counter
import sys

class Equipment:
    slot = None
    def on_battle_start(self, wearer): pass
    def before_attack(self, wearer, target, dmg): return dmg
    def after_attack(self, wearer, target, dmg): pass
    def before_take_damage(self, wearer, dmg): return dmg
    def on_critical(self, wearer, target, dmg): pass
    def on_non_critical(self, wearer, target, dmg): pass

class WoodenShield(Equipment):
    """æœ¨ç›¾ï¼šå‰¯æ‰‹æ’æ§½ï¼›+2 é˜²å¾¡ï¼›æˆ˜æ–—å¼€å§‹æ—¶è·å¾— 10 æŠ¤ç›¾"""
    slot = "offhand"
    display_name    = "æœ¨ç›¾"

    def __init__(self):
        self.type = "armor"
        self.def_bonus    = 2
        self.shield_bonus = 10

    def on_battle_start(self, wearer):
        # é˜²å¾¡æ˜¯æ°¸ä¹…å±æ€§ï¼Œç”±Character.__init__å¤„ç†
        wearer.shield  += self.shield_bonus

class WoodenSword(Equipment):
    """æœ¨å‰‘ï¼šæ­¦å™¨æ’æ§½ï¼›+3 æ”»å‡»ï¼›æ¯æ™®æ”» 3 æ¬¡ï¼Œç¬¬ 4 æ¬¡æ™®æ”»é€ æˆåŒå€ä¼¤å®³"""
    slot = "weapon"
    display_name    = "æœ¨å‰‘"

    def __init__(self):
        self.type = "weapon"
        self.rarity = "common"
        self.atk_bonus = 3
        self._count    = 0
    
    # on_battle_start å·²è¢«ç§»é™¤ï¼Œå› ä¸ºæ”»å‡»æ˜¯æ°¸ä¹…å±æ€§

    def before_attack(self, wearer, target, packet: DamagePacket):
        # æ•ˆæœç°åœ¨ä¿®æ”¹çš„æ˜¯ä¼¤å®³åŒ…çš„æ•°å€¼
        if self._count >= 3:
            packet.amount *= 2
            self._count = 0

    def after_attack(self, wearer, target, actual_dmg):
        # è¿™é‡Œçš„dmgæ˜¯é€ æˆä¼¤å®³åçš„æœ€ç»ˆæ•°å€¼ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨
        if actual_dmg <= wearer.base_attack:
            self._count += 1

class WoodenSword_Star(Equipment):
    """æœ¨å‰‘â­ï¼šæ­¦å™¨æ’æ§½ï¼›+6 æ”»å‡»ï¼›ç°åœ¨æ¯æ”»å‡» 2 æ¬¡ï¼Œç¬¬ 3 æ¬¡æ™®æ”»é€ æˆåŒå€ä¼¤å®³ã€‚"""
    slot = "weapon"
    display_name = "æœ¨å‰‘â­"
    
    def __init__(self):
        self.type = "weapon"
        self.rarity = "uncommon" # å‡çº§åï¼Œå“è´¨ä¹Ÿæå‡äº†
        self.atk_bonus = 6       # åŸºç¡€æ”»å‡»æ›´é«˜
        self._count = 0

    def before_attack(self, wearer, target, packet: DamagePacket):
        # æ•ˆæœå¢å¼ºï¼šä»3æ¬¡è§¦å‘æ”¹ä¸º2æ¬¡è§¦å‘
        if self._count >= 2:
            packet.amount *= 2
            self._count = 0

    def after_attack(self, wearer, target, actual_dmg):
        # è¿™é‡Œçš„dmgæ˜¯é€ æˆä¼¤å®³åçš„æœ€ç»ˆæ•°å€¼ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨
        self._count += 1

class WoodenArmor(Equipment):
    """æœ¨é“ ç”²ï¼šæŠ¤ç”²æ’æ§½ï¼›+2 é˜²å¾¡ï¼›30% æ¦‚ç‡é¢å¤–å‡å… 30% ç‚¹ç‰©ç†ä¼¤å®³"""
    slot = "armor"
    display_name    = "æœ¨é“ ç”²"

    def __init__(self):
        self.type = "armor"
        self.rarity = "common"
        self.def_bonus = 2

    # on_battle_start å·²è¢«ç§»é™¤ï¼Œå› ä¸ºé˜²å¾¡æ˜¯æ°¸ä¹…å±æ€§

    def before_take_damage(self, wearer, packet: DamagePacket):
        # æ•ˆæœç°åœ¨åªå¯¹ç‰©ç†ä¼¤å®³ç”Ÿæ•ˆ
        if packet.damage_type == DamageType.PHYSICAL and random.random() < 0.3:
            packet.amount = max(0, packet.amount * 0.7)

class WoodenArmor_Star(Equipment):
    """æœ¨é“ ç”²â­ï¼šæŠ¤ç”²æ’æ§½ï¼›+5 é˜²å¾¡ï¼›50% æ¦‚ç‡é¢å¤–å‡å… 50% ç‚¹ç‰©ç†ä¼¤å®³"""
    slot = "armor"
    display_name = "æœ¨é“ ç”²â­"

    def __init__(self):
        self.type = "armor"
        self.rarity = "uncommon"
        self.def_bonus = 5 # åŸºç¡€é˜²å¾¡æ›´é«˜

    def before_take_damage(self, wearer, packet: DamagePacket):
        # æ•ˆæœç°åœ¨åªå¯¹ç‰©ç†ä¼¤å®³ç”Ÿæ•ˆ
        if packet.damage_type == DamageType.PHYSICAL and random.random() < 0.5:
            packet.amount = max(0, packet.amount * 0.5)

class IronSword(Equipment):
    """é“å‰‘ï¼šæ­¦å™¨æ’æ§½ï¼›+5 æ”»å‡»ï¼›åŸºç¡€ +5% æš´å‡»ç‡ï¼›æœªæš´å‡»æ—¶ï¼Œä¸‹æ¬¡æ™®æ”»æš´å‡»ç‡ +5%ï¼Œæœ€å¤š 8 å±‚ï¼›æš´å‡»åæ¸…é™¤"""
    slot = "weapon"
    display_name = "é“å‰‘"
    def __init__(self):
        self.rarity = "common"
        self.type = "weapon"
        self.atk_bonus = 5
        self.base_crit_bonus = 0.05
        self.max_stacks = 8
        self._stacks = 0
    def on_battle_start(self, wearer):
        # æ”»å‡»å’Œæš´å‡»éƒ½æ˜¯æ°¸ä¹…å±æ€§
        # ä½†æš´å‡»ç‡éœ€è¦åœ¨æˆ˜æ–—ä¸­åŠ¨æ€å˜åŒ–ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦åœ¨æˆ˜å‰è®¾ç½®åˆå§‹å€¼
        wearer.crit_chance += self.base_crit_bonus
    def on_critical(self, wearer, target, dmg):
        wearer.crit_chance -= self._stacks * self.base_crit_bonus
        self._stacks = 0
    def on_non_critical(self, wearer, target, dmg):
        if self._stacks < self.max_stacks:
            self._stacks += 1
            wearer.crit_chance += self.base_crit_bonus

class IronRing(Equipment):
    """é“æˆ’æŒ‡ï¼šé¥°å“æ§½ï¼›+5% æš´å‡»ï¼›+10% çˆ†ä¼¤ï¼›èµ é€ä¸¤å±‚â€œåˆšæ¯…â€Buff"""
    slot = "accessory"
    display_name = "é“æˆ’æŒ‡"
    def __init__(self):
        self.rarity = "common"
        self.type = "misc" # æ·»åŠ ç±»å‹
        self.crit_bonus = 0.05
        self.crit_dmg_bonus = 0.10
    def on_battle_start(self, wearer):
        # æš´å‡»å’Œçˆ†ä¼¤æ˜¯æ°¸ä¹…å±æ€§
        # åªä¿ç•™æˆ˜æ–—å¼€å§‹æ—¶çš„æ•ˆæœ
        wearer.add_status(Buffs.SteelHeartBuff(uses=2))

class IronHammer(Equipment):
    """é“é”¤ï¼šæ­¦å™¨æ§½ï¼›+8 æ”»å‡»ï¼›+5% æš´å‡»ï¼›20% æ¦‚ç‡çœ©æ™•æ•Œäºº 2 ç§’"""
    slot = "weapon"
    display_name = "é“é”¤"
    def __init__(self):
        self.rarity = "uncommon"
        self.type = "weapon"
        self.atk_bonus = 8
        self.crit_chance_bonus = 0.05
        self.stun_chance = 0.20
        self.stun_duration = 2.0
    def on_battle_start(self, wearer):
        # æ”»å‡»å’Œæš´å‡»æ˜¯æ°¸ä¹…å±æ€§
        pass
    def after_attack(self, wearer, target, dmg):
        if random.random() < self.stun_chance:
            target.add_status(Buffs.StunDebuff(self.stun_duration), source=wearer)

class NaturalNecklace(Equipment):
    """è‡ªç„¶é¡¹é“¾ï¼šé¥°å“æ§½ï¼›æœ€å¤§ HP +20ï¼›æä¾› 2 å±‚â€œå†ç”Ÿâ€Buff"""
    slot = "accessory"
    display_name = "è‡ªç„¶é¡¹é“¾"
    def __init__(self):
        self.rarity = "uncommon"
        self.type = "misc" # æ·»åŠ ç±»å‹
        self.hp_bonus = 20
    def on_battle_start(self, wearer):
        # HPæ˜¯æ°¸ä¹…å±æ€§
        # åªä¿ç•™æˆ˜æ–—å¼€å§‹æ—¶çš„æ•ˆæœ
        wearer.add_status(Buffs.RegenerationBuff(stacks=2))

class ThornsRing(Equipment):
    """è†æ£˜ç¯ï¼šé¥°å“æ§½ï¼›+0.2 æ”»é€Ÿï¼›+10% çˆ†ä¼¤ï¼›æˆ˜æ–—å¼€å§‹æ—¶æä¾› 3 å±‚ è†æ£˜"""
    slot = "accessory"
    display_name = "è†æ£˜ç¯"
    def __init__(self):
        self.rarity = "uncommon"
        self.type = "misc" # æ·»åŠ ç±»å‹
        self.atk_speed_bonus = 0.2
        self.crit_damage_bonus = 0.10
        self.thorns_stacks = 3
    def on_battle_start(self, wearer):
        # æ”»é€Ÿå’Œçˆ†ä¼¤æ˜¯æ°¸ä¹…å±æ€§
        # åªä¿ç•™æˆ˜æ–—å¼€å§‹æ—¶çš„æ•ˆæœ
        wearer.add_status(Buffs.ThornsBuff(stacks=self.thorns_stacks))

class PhoenixCrown(Equipment):
    """ç´«é‡‘å† ï¼šå¤´ç›”æ§½ï¼›æ— åŸºç¡€å±æ€§ï¼›é™„åŠ â€œä¸ç­â€æ•ˆæœ"""
    slot = "helmet"
    display_name = "ç´«é‡‘å† "
    def __init__(self):
        self.rarity = "legendary"
        self.type = "armor" # æ·»åŠ ç±»å‹
    def on_battle_start(self, wearer):
        # è¿™ä¸ªè®¾è®¡æ˜¯å®Œç¾çš„ï¼Œåªæ·»åŠ Buff
        wearer.add_buff(Buffs.PhoenixCrownStage1Buff())

class SlimeSword(Equipment):
    """å²è±å§†ä¹‹å‰‘ï¼šæ­¦å™¨ï¼›+6 æ”»å‡»ï¼›æ”»å‡»æ—¶æœ‰15%æ¦‚ç‡ä½¿æ•Œäººä¸­æ¯’1å±‚"""
    slot = "weapon"
    display_name = "å²è±å§†ä¹‹å‰‘"
    def __init__(self):
        self.rarity = "common"
        self.type = "weapon"
        self.atk_bonus = 6
        self.poison_chance = 0.15
    def on_battle_start(self, wearer):
        # æ”»å‡»æ˜¯æ°¸ä¹…å±æ€§
        pass
    def after_attack(self, wearer, target, dmg):
        if random.random() < self.poison_chance:
            target.add_debuff(Buffs.PoisonDebuff(stacks=1), source=wearer)


class VampiresFang(Equipment):
    """å¸è¡€é¬¼ä¹‹ç‰™ï¼šé¥°å“æ§½ï¼›æ”»å‡»é€ æˆ10%ç”Ÿå‘½å·å–ï¼Œç”Ÿå‘½ä½äº50%æ—¶æ•ˆæœç¿»å€ã€‚"""
    slot = "accessory"
    display_name = "å¸è¡€é¬¼ä¹‹ç‰™"
    def __init__(self):
        self.rarity, self.type = "rare", "misc"
        self.lifesteal_ratio = 0.10

    def after_attack(self, wearer, target, actual_dmg):
        ratio = self.lifesteal_ratio
        if wearer.hp / wearer.max_hp < 0.5:
            ratio *= 2
        
        healed_amount = actual_dmg * ratio
        if healed_amount > 0:
            # ### æ ¸å¿ƒä¿®å¤ï¼šå°†è¢«æ”»å‡»çš„ target ä½œä¸º combat_target ä¼ å…¥ ###
            wearer.heal(healed_amount, combat_target=target)

class HourglassOfTime(Equipment):
    """æ—¶å…‰æ²™æ¼ï¼šå‰¯æ‰‹æ§½ï¼›æš´å‡»æ—¶æœ‰40%å‡ ç‡ç«‹å³é‡ç½®æ”»å‡»å†·å´ã€‚"""
    slot = "offhand"
    display_name = "æ—¶å…‰æ²™æ¼"
    def __init__(self):
        self.rarity, self.type = "uncommon", "armor" # å‰¯æ‰‹ç®—é˜²å…·
        self.proc_chance = 0.4

    def on_critical(self, wearer, target, dmg):
        if random.random() < self.proc_chance:
            print("[æ—¶å…‰æ²™æ¼] æ•ˆæœè§¦å‘ï¼")
            # ç›´æ¥å°†æ”»å‡»å†·å´å……æ»¡
            wearer._cd = wearer.attack_interval

class Stormcaller(Equipment):
    """é£æš´å¬å”¤è€…ï¼šæ­¦å™¨æ§½ï¼›+15æ”»å‡»ï¼›æ¯æ”»å‡»4æ¬¡ï¼Œä¸ºæ•Œäººé™„åŠ ä¸€å±‚ã€é£æš´ã€‘å°è®°ã€‚"""
    slot = "weapon"
    display_name = "é£æš´å¬å”¤è€…"
    def __init__(self):
        self.rarity, self.type = "legendary", "weapon"
        self.atk_bonus = 15
        self._attack_count = 0

    def after_attack(self, wearer, target, dmg):
        self._attack_count += 1
        if self._attack_count >= 4:
            self._attack_count = 0
            print("[é£æš´å¬å”¤è€…] é™„åŠ äº†é£æš´å°è®°ï¼")
            target.add_debuff(Buffs.StormDebuff(), source=wearer)
# --- ç™½è‰² (Common) å“è´¨æ–°è£…å¤‡ ---

class LeatherGloves(Equipment):
    """çš®æ‰‹å¥—ï¼šå‰¯æ‰‹æ§½ï¼›+0.3 æ”»å‡»é€Ÿåº¦ã€‚"""
    slot = "offhand"
    display_name = "çš®æ‰‹å¥—"
    def __init__(self):
        self.rarity, self.type = "common", "armor"
        self.atk_speed_bonus = 0.3

class RustyHelmet(Equipment):
    """ç”Ÿé”ˆçš„å¤´ç›”ï¼šå¤´ç›”æ§½ï¼›+30 æœ€å¤§ç”Ÿå‘½å€¼ã€‚"""
    slot = "helmet"
    display_name = "ç”Ÿé”ˆçš„å¤´ç›”"
    def __init__(self):
        self.rarity, self.type = "common", "armor"
        self.hp_bonus = 30

# --- ç»¿è‰² (Uncommon) å“è´¨æ–°è£…å¤‡ ---

class BarbedAxe(Equipment):
    """å€’é’©æ–§ï¼šæ­¦å™¨æ§½ï¼›+5æ”»å‡»ï¼›æ”»å‡»æ—¶æœ‰30%å‡ ç‡ä½¿æ•Œäººã€æµè¡€ã€‘5ç§’ã€‚"""
    slot = "weapon"
    display_name = "å€’é’©æ–§"
    def __init__(self):
        self.rarity, self.type = "uncommon", "weapon"
        self.atk_bonus = 5
        self.bleed_chance = 0.3
    def after_attack(self, wearer, target, dmg):
        if random.random() < self.bleed_chance:
            target.add_debuff(Buffs.BleedDebuff(stacks=1), source=wearer)

# åœ¨ Equips.py æ–‡ä»¶ä¸­ï¼Œæ‰¾åˆ°å¹¶æ›¿æ¢ TowerShield ç±»

class TowerShield(Equipment):
    """å¡”ç›¾ï¼šå‰¯æ‰‹æ§½ï¼›+3é˜²å¾¡ï¼›æˆ˜æ–—å¼€å§‹æ—¶ï¼Œè·å¾—3å±‚ã€æ ¼æŒ¡ã€‘ã€‚"""
    slot = "offhand"
    display_name = "å¡”ç›¾"
    def __init__(self):
        self.rarity, self.type = "uncommon", "armor"
        self.def_bonus = 3
        self.block_stacks = 3

    def on_battle_start(self, wearer):
        wearer.add_buff(Buffs.BlockBuff(stacks=self.block_stacks))
    

# --- è“è‰² (Rare) å“è´¨æ–°è£…å¤‡ ---


class AdventurersPouch(Equipment):
    """å†’é™©å®¶çš„é’±è¢‹ï¼šé¥°å“æ§½ï¼›æ¯æ‹¥æœ‰20é‡‘å¸ï¼Œå°±ä¸ºä½ æä¾›+1æ”»å‡»åŠ›ã€‚ï¼ˆæˆ˜æ–—å¼€å§‹æ—¶ç»“ç®—ï¼‰"""
    slot = "accessory"
    display_name = "å†’é™©å®¶çš„é’±è¢‹"
    def __init__(self):
        self.rarity, self.type = "rare", "misc"
        self.atk_bonus = 0 # åˆå§‹æ”»å‡»åŠ›åŠ æˆä¸º0

    def on_battle_start(self, wearer):
        # åœ¨æˆ˜æ–—å¼€å§‹æ—¶ï¼Œåªè®¡ç®—åº”è¯¥åŠ å¤šå°‘æ”»å‡»åŠ›ï¼Œå¹¶å­˜åˆ°è‡ªå·±çš„å±æ€§é‡Œ
        gold = getattr(wearer, 'gold', 0)
        self.atk_bonus = gold // 20
        if self.atk_bonus > 0:
            print(f"[å†’é™©å®¶çš„é’±è¢‹] ä½ è·å¾—äº† {self.atk_bonus} ç‚¹é¢å¤–æ”»å‡»åŠ›ï¼")
            # é‡æ–°è®¡ç®—ä¸€æ¬¡æ€»å±æ€§ï¼Œè®©è¿™ä¸ªæ–°çš„atk_bonusç”Ÿæ•ˆ
            wearer.recalculate_stats()

class ShadowCloak(Equipment):
    """æš—å½±æ–—ç¯·ï¼šæŠ¤ç”²æ§½ï¼›+5é˜²å¾¡ï¼›å—åˆ°æš´å‡»ä¼¤å®³æ—¶ï¼Œæœ‰30%æ¦‚ç‡å…ç–«è¯¥æ¬¡ä¼¤å®³ã€‚"""
    slot = "armor"
    display_name = "æš—å½±æ–—ç¯·"
    def __init__(self):
        self.rarity, self.type = "rare", "armor"
        self.def_bonus = 5
        self.crit_immunity_chance = 0.3
    def before_take_damage(self, wearer, packet: DamagePacket):
        if packet.damage_type == DamageType.PHYSICAL and packet.is_critical:
            if random.random() < self.crit_immunity_chance:
                print("[æš—å½±æ–—ç¯·] å…ç–«äº†æš´å‡»ä¼¤å®³ï¼")
                packet.amount = 0

# åœ¨ Equips.py æ–‡ä»¶æœ«å°¾æ·»åŠ 

# --- â€œçƒ™å°â€ä½“ç³»ç¤ºä¾‹ ---

class SunScorchedBlade(Equipment):
    """æ—¥ç¼ä¹‹åˆƒ [æ­¦å™¨-ç¨€æœ‰]ï¼šæ”»å‡»é€Ÿåº¦+0.5ï¼›å‘½ä¸­æ—¶é™„åŠ ä¸€å±‚ã€æ—¥ä¹‹çƒ™å°ã€‘ã€‚"""
    slot, display_name = "weapon", "æ—¥ç¼ä¹‹åˆƒ"
    def __init__(self):
        self.rarity, self.type = "rare", "weapon"
        self.atk_speed_bonus = 0.5
    def after_attack(self, wearer, target, actual_dmg):
        target.add_debuff(Buffs.SunstoneBrandDebuff(stacks=1), source=wearer)

class Avalanche(Equipment):
    """å±±å´© [æ­¦å™¨-å²è¯—]ï¼šæ”»å‡»åŠ›+20ï¼›æš´å‡»æ—¶å¼•çˆ†ç›®æ ‡æ‰€æœ‰ã€æ—¥ä¹‹çƒ™å°ã€‘ï¼Œæ¯å±‚é€ æˆ20é¢å¤–çœŸå®ä¼¤å®³ã€‚"""
    slot, display_name = "weapon", "å±±å´©"
    def __init__(self):
        self.rarity, self.type = "epic", "weapon"
        self.atk_bonus = 20
    def on_critical(self, wearer, target, actual_dmg):
        # å¯»æ‰¾ç›®æ ‡èº«ä¸Šçš„çƒ™å°
        brand_debuff = next((b for b in target.buffs if isinstance(b, Buffs.SunstoneBrandDebuff)), None)
        if brand_debuff:
            stacks = brand_debuff.stacks
            print(f"[å±±å´©] å¼•çˆ†äº† {stacks} å±‚çƒ™å°ï¼")
            # é€ æˆé¢å¤–ä¼¤å®³
            extra_dmg = stacks * 20
            packet = DamagePacket(amount=extra_dmg, damage_type=DamageType.TRUE, source=wearer)
            target.take_damage(packet)
            # ç§»é™¤çƒ™å°
            target.remove_buff(brand_debuff)

# --- â€œé¾™é­‚â€ä½“ç³»ç¤ºä¾‹ ---

class DragonBloodChalice(Equipment):
    """é¾™è¡€é…’æ¯ [é¥°å“-å²è¯—]ï¼šæ¯ç§’å¤±å»5ç‚¹ç”Ÿå‘½ï¼Œä½†è·å¾—1å±‚ã€é¾™é­‚ã€‘ã€‚"""
    slot, display_name = "accessory", "é¾™è¡€é…’æ¯"
    def __init__(self):
        self.rarity, self.type = "epic", "misc"
        self._timer = 0.0
    def on_battle_start(self, wearer):
        self._timer = 0.0 # é‡ç½®è®¡æ—¶å™¨
    def on_tick(self, wearer, dt): # éœ€è¦åœ¨ Character.update ä¸­è°ƒç”¨ on_tick
        self._timer += dt
        if self._timer >= 1.0:
            self._timer -= 1.0
            # æ‰£è¡€
            packet = DamagePacket(amount=5, damage_type=DamageType.TRUE, is_sourceless=True)
            wearer.take_damage(packet)
            # è·å¾—é¾™é­‚
            wearer.add_buff(Buffs.DragonSoulBuff(stacks=1))

class DragonscaleWard(Equipment):
    """é¾™é³ç›¾ [å‰¯æ‰‹-ç¨€æœ‰]ï¼šæˆ˜æ–—å¼€å§‹æ—¶ï¼Œæ¶ˆè€—æ‰€æœ‰ã€é¾™é­‚ã€‘ï¼Œæ¯å±‚æä¾›15ç‚¹æŠ¤ç›¾ã€‚"""
    slot, display_name = "offhand", "é¾™é³ç›¾"
    def __init__(self):
        self.rarity, self.type = "rare", "armor"
    def on_battle_start(self, wearer):
        soul_buff = next((b for b in wearer.buffs if isinstance(b, Buffs.DragonSoulBuff)), None)
        if soul_buff:
            stacks = soul_buff.stacks
            shield_gain = stacks * 15
            print(f"[é¾™é³ç›¾] æ¶ˆè€—äº† {stacks} å±‚é¾™é­‚ï¼Œè·å¾—äº† {shield_gain} ç‚¹æŠ¤ç›¾ï¼")
            wearer.shield += shield_gain
            wearer.remove_buff(soul_buff)

# æ–‡ä»¶: Equips.py (è¿½åŠ åˆ°æ–‡ä»¶æœ«å°¾ï¼Œä½†åœ¨UPGRADE_MAPä¹‹å‰)

class Plaguebringer(Equipment):
    """ç˜Ÿç–«ä½¿è€…: æ­¦å™¨; æ”»å‡»æ—¶å¼•çˆ†ç›®æ ‡èº«ä¸Šçš„æ‰€æœ‰ã€æ¯’ã€‘å±‚æ•°ï¼Œæ¯å±‚é€ æˆ1ç‚¹é¢å¤–æ¯’æ€§ä¼¤å®³ã€‚"""
    slot, display_name = "weapon", "ç˜Ÿç–«ä½¿è€…"
    def __init__(self):
        self.rarity, self.type = "rare", "weapon"
        self.atk_bonus = 8

    def after_attack(self, wearer, target, actual_dmg):
        poison_debuff = next((b for b in target.buffs if isinstance(b, Buffs.PoisonDebuff)), None)
        if poison_debuff:
            stacks = poison_debuff.stacks
            print(f"[ç˜Ÿç–«ä½¿è€…] å¼•çˆ†äº† {stacks} å±‚æ¯’ï¼")
            # é€ æˆé¢å¤–ä¼¤å®³
            packet = DamagePacket(amount=stacks, damage_type=DamageType.POISON, source=wearer)
            target.take_damage(packet)
            # ç§»é™¤æ¯’
            target.remove_buff(poison_debuff)

class ArmorSunderer(Equipment):
    """ç¢ç”²æˆ˜æ–§: æ­¦å™¨; æ”»å‡»æ—¶ä¸ºç›®æ ‡å åŠ 1å±‚ã€ç ´ç”²ã€‘ã€‚å½“ç›®æ ‡é˜²å¾¡ä¸º0æ—¶ï¼Œä½ çš„æ”»å‡»é€ æˆåŒå€ä¼¤å®³ã€‚"""
    slot, display_name = "weapon", "ç¢ç”²æˆ˜æ–§"
    def __init__(self):
        self.rarity, self.type = "epic", "weapon"
        self.atk_bonus = 15

    def before_attack(self, wearer, target, packet: DamagePacket):
        if target.defense <= 0:
            packet.amount *= 2

    def after_attack(self, wearer, target, actual_dmg):
        target.add_debuff(Buffs.SunderDebuff(stacks=1), source=wearer)

class Windshear(Equipment):
    """é£åˆ‡: æ­¦å™¨; æ”»å‡»æœ‰50%æ¦‚ç‡åˆ†è£‚æˆä¸¤æ¬¡50%ä¼¤å®³çš„æ”»å‡»ï¼Œåˆ†è£‚çš„æ”»å‡»æœ‰å‡åŠçš„æ¦‚ç‡ç»§ç»­åˆ†è£‚ã€‚"""
    slot, display_name = "weapon", "é£åˆ‡"
    def __init__(self):
        self.rarity, self.type = "legendary", "weapon"
        self.atk_bonus = 10

    def after_attack(self, wearer, target, actual_dmg):
        split_chance = 0.5
        while random.random() < split_chance:
            print("[é£åˆ‡] æ”»å‡»åˆ†è£‚ï¼")
            # é€ æˆä¸€æ¬¡50%ä¼¤å®³çš„é¢å¤–æ”»å‡»
            packet = DamagePacket(amount=wearer.attack * 0.5, damage_type=DamageType.PHYSICAL, source=wearer)
            target.take_damage(packet)
            split_chance /= 2 # æ¦‚ç‡å‡åŠ

class RingOfFlourishing(Equipment):
    """ç¹ç››æŒ‡ç¯: é¥°å“; å½“ä½ è·å¾—ä»»æ„Buffæ—¶ï¼Œæœ‰30%æ¦‚ç‡é¢å¤–è·å¾—ä¸€å±‚ã€ç”Ÿæœºç»½æ”¾ã€‘ã€‚"""
    slot, display_name = "accessory", "ç¹ç››æŒ‡ç¯"
    def __init__(self):
        self.rarity, self.type = "rare", "misc"

    def on_buff_applied(self, wearer, buff_applied):
        """è¿™æ˜¯ä¸€ä¸ªæ–°çš„è‡ªå®šä¹‰é’©å­ï¼Œä¼šåœ¨Character.add_statusä¸­è¢«è°ƒç”¨"""
        
        if not buff_applied.is_debuff and not isinstance(buff_applied, Buffs.VitalityBloomBuff) and random.random() < 0.3:
            print("[ç¹ç››æŒ‡ç¯] æ•ˆæœè§¦å‘ï¼")
            wearer.add_buff(Buffs.VitalityBloomBuff(stacks=1))


class RuneBlade(Equipment):
    """ç¬¦æ–‡ä¹‹åˆƒ [æ­¦å™¨-ç¨€æœ‰]
    +12 æ”»å‡»åŠ›ã€‚
    ä½ çš„æ‰€æœ‰æ™®é€šæ”»å‡»éƒ½ä¼šé€ æˆé­”æ³•ä¼¤å®³ï¼Œä¼¤å®³å€¼å–å†³äºä½ çš„æ”»å‡»åŠ›ã€‚
    """
    slot = "weapon"
    display_name = "ç¬¦æ–‡ä¹‹åˆƒ"

    def __init__(self):
        self.rarity = "rare"  # ç¨€æœ‰å“è´¨
        self.type = "weapon"
        self.atk_bonus = 12

    def before_attack(self, wearer, target, packet: DamagePacket):
        """
        åœ¨æ”»å‡»ä¼¤å®³åŒ…ï¼ˆpacketï¼‰è¢«æœ€ç»ˆè®¡ç®—å‰è¿›è¡Œä¿®æ”¹ã€‚
        è¿™ä¸ªé’©å­å‡½æ•°åœ¨ Character.try_attack ä¸­è¢«è°ƒç”¨ã€‚
        """
        # ### æ ¸å¿ƒæ•ˆæœï¼šå°†ä¼¤å®³ç±»å‹ä»é»˜è®¤çš„ç‰©ç†ä¼¤å®³æ”¹ä¸ºé­”æ³•ä¼¤å®³ ###
        packet.damage_type = DamageType.MAGIC


UPGRADE_MAP = {
    WoodenSword: WoodenSword_Star,
    WoodenArmor: WoodenArmor_Star,
    # åœ¨è¿™é‡Œç»§ç»­ä¸ºä½ å…¶ä»–çš„è£…å¤‡æ·»åŠ å‡çº§é…æ–¹...
    # ä¾‹å¦‚:
    # IronSword: IronSword_Star, 
}


================================================================================
### æ–‡ä»¶è·¯å¾„: events.json
================================================================================

{
    "fountain_of_power": {
        "title": "åŠ›é‡æºæ³‰",
        "description": "ä½ å‘ç°ä¸€ä¸ªæ•£å‘ç€å¾®å…‰çš„æºæ³‰ã€‚æ³‰æ°´ä¼¼ä¹è•´å«ç€å¥‡ç‰¹çš„åŠ›é‡ï¼Œä½ å¯ä»¥ä»ä¸­æ„Ÿå—åˆ°ç”Ÿå‘½ä¸æ¯ç­çš„æ°”æ¯ã€‚",
        "choices": [
            {
                "text": "å–ä¸€å£ (æ¢å¤å…¨éƒ¨ç”Ÿå‘½)",
                "outcomes": [
                    { "type": "HEAL", "amount": "full", "result_text": "æ³‰æ°´è®©ä½ ç²¾ç¥ç„•å‘ï¼Œæ‰€æœ‰ä¼¤ç—›éƒ½æ¶ˆå¤±äº†ï¼" }
                ]
            },
            {
                "text": "å°†æ­¦å™¨æµ¸å…¥ (é£é™©ä¸æœºé‡)",
                "outcomes": [
                    { "type": "WEAPON_UPGRADE", "chance": 0.6, "result_text": "ä½ çš„æ­¦å™¨å¸æ”¶äº†æºæ³‰çš„åŠ›é‡ï¼Œå˜å¾—æ›´åŠ é”‹åˆ©äº†ï¼(æ”»å‡»åŠ›+5)" },
                    { "type": "WEAPON_CURSE", "chance": 0.4, "result_text": "æ­¦å™¨æ— æ³•æ‰¿å—è¿™è‚¡åŠ›é‡ï¼Œåè€Œå˜å¾—è¿Ÿé’äº†...(æ”»å‡»åŠ›-3)" }
                ]
            }
        ]
    },
    "wandering_spirit": {
        "title": "è¿·é€”çš„å¤ä»£çµé­‚",
        "description": "ä¸€ä¸ªåŠé€æ˜çš„çµé­‚åœ¨ä½ é¢å‰å¾˜å¾Šï¼Œå®ƒä¼¼ä¹åœ¨å¯»æ±‚å¸®åŠ©ï¼Œåˆåƒæ˜¯åœ¨å®ˆæŠ¤ç€ä»€ä¹ˆã€‚",
        "choices": [
            {
                "text": "å¸®åŠ©å®ƒå®‰æ¯ (è·å¾—å¤©èµ‹)",
                "outcomes": [
                    { "type": "GAIN_TALENT", "talent_class_name": "HeartOfHealingTalent", "result_text": "çµé­‚æ„Ÿæ¿€åœ°æ¶ˆæ•£äº†ï¼Œä½ ä»ä¸­é¢†æ‚Ÿäº†ã€Œæ²»æ„ˆä¹‹å¿ƒã€ï¼" }
                ]
            },
            {
                "text": "æ”»å‡»å®ƒ (è§¦å‘æˆ˜æ–—)",
                "outcomes": [
                    { "type": "TRIGGER_COMBAT", "enemy_id": "goblin_captain", "result_text": "çµé­‚å‘å‡ºäº†å°–å•¸ï¼ŒåŒ–ä½œä¸€ä¸ªå¼ºå¤§çš„æ•Œäººå‘ä½ è¢­æ¥ï¼" }
                ]
            }
        ]
    }
}


================================================================================
### æ–‡ä»¶è·¯å¾„: game.py
================================================================================

# game.py (å·²æ›´æ–°)
import pygame
import pickle
import os
import time
import json
import sys
from settings import *
# <-- å¯¼å…¥ ui æ¨¡å—ï¼Œè€Œä¸ä»…ä»…æ˜¯ init_fonts
import ui
from Character import Character
import Equips
import Talents

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("æˆ‘çš„æ¸¸æˆ")
        self.clock = pygame.time.Clock()
        self.running = True
        self.fonts = ui.init_fonts()
        self.state_stack = []

        # <-- æ ¸å¿ƒæ”¹åŠ¨ï¼šåœ¨æ¸¸æˆå¯åŠ¨æ—¶åŠ è½½æ‰€æœ‰Buffå›¾æ ‡èµ„æº -->
        #ui.load_buff_icons()

        self.player = None
        self.current_stage = "1"
        self.loaded_dialogue_index = 0

        self.story_data = self._load_json("story.json")
        self.enemy_data = self._load_json("enemies.json")
        self.loot_data = self._load_json("loot_tables.json")
        self.event_data = self._load_json("events.json")

        self.dungeon_data = {}
        dungeon_folder = 'dungeons'
        for filename in os.listdir(dungeon_folder):
            if filename.endswith('.json'):
                dungeon_id = filename.split('.')[0]
                self.dungeon_data[dungeon_id] = self._load_json(os.path.join(dungeon_folder, filename))

    def run(self):
        from states.title import TitleScreen
        self.state_stack.append(TitleScreen(self))

        while self.running and self.state_stack:
            self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(60)
        
        pygame.quit()
        sys.exit()

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            if self.state_stack:
                self.state_stack[-1].handle_event(event)

    def update(self):
        if self.state_stack:
            self.state_stack[-1].update()

    def draw(self):
        # --- å…¨æ–°çš„åˆ†å±‚ç»˜åˆ¶é€»è¾‘ ---
        if not self.state_stack:
            pygame.display.flip()
            return

        # 1. æ‰¾åˆ°æœ€åº•éƒ¨çš„éå¼¹çª—ç•Œé¢
        base_state_index = -1
        for i in range(len(self.state_stack) - 1, -1, -1):
            if not getattr(self.state_stack[i], 'is_overlay', False):
                base_state_index = i
                break
        
        # 2. ç»˜åˆ¶æ‰€æœ‰åº•å±‚ç•Œé¢ (é€šå¸¸åªæœ‰ä¸€ä¸ª)
        if base_state_index != -1:
            for i in range(base_state_index + 1):
                 self.state_stack[i].draw(self.screen)

        # 3. é€ä¸ªç»˜åˆ¶æ‰€æœ‰å¼¹çª—ç•Œé¢
        for i in range(base_state_index + 1, len(self.state_stack)):
            self.state_stack[i].draw(self.screen)
        
        pygame.display.flip()

    def _load_json(self, filename):
        try:
            with open(filename, 'r', encoding='utf-8') as f: return json.load(f)
        except Exception as e:
            print(f"ERROR: Could not load {filename}: {e}")
            return None

    def get_save_filename(self, slot_number):
        return f"save_slot_{slot_number}.dat"

    def peek_save_slot(self, slot_number):
        filename = self.get_save_filename(slot_number)
        if not os.path.exists(filename): return None
        try:
            with open(filename, "rb") as f: return pickle.load(f)
        except Exception: return None

    def save_to_slot(self, slot_number):
        filename = self.get_save_filename(slot_number)
        try:
            dialogue_index = 0
            from states.story import StoryScreen
            for state in reversed(self.state_stack):
                if isinstance(state, StoryScreen):
                    dialogue_index = state.dialogue_index; break
            data_to_save = {
                "player": self.player, "current_stage": self.current_stage,
                "dialogue_index": dialogue_index, "timestamp": time.time()
            }
            with open(filename, "wb") as f: pickle.dump(data_to_save, f)
            print(f"Game saved to slot {slot_number}")
            return f"æˆåŠŸä¿å­˜åˆ°æ§½ä½ {slot_number}ï¼"
        except Exception as e:
            print(f"Save failed: {e}"); return "å­˜æ¡£å¤±è´¥ï¼"

    def load_from_slot(self, slot_number):
        data = self.peek_save_slot(slot_number)
        if data:
            self.player = data["player"]
            self.current_stage = data["current_stage"]
            self.loaded_dialogue_index = data.get("dialogue_index", 0)
            return True
        return False
   
    # æ–‡ä»¶: game.py (æ›¿æ¢è¿™ä¸ªå‡½æ•°)

    def start_new_game(self):
        player_eq = [Equips.WoodenSword(), Equips.WoodenArmor(), Equips.NaturalNecklace(), Equips.IronRing()]
        player_talents = [
            Talents.HeartOfHealingTalent(),
            Talents.DualWieldTalent(),
            Talents.Adventurer()
        ]
        
        # --- æ ¸å¿ƒä¿®æ”¹ï¼šä½¿ç”¨ä» settings.py å¯¼å…¥çš„ PLAYER_BASE_STATS ---
        # **PLAYER_BASE_STATS æ˜¯ä¸€ç§ç®€ä¾¿å†™æ³•ï¼Œå®ƒä¼šè‡ªåŠ¨æŠŠå­—å…¸é‡Œçš„æ‰€æœ‰é”®å€¼å¯¹ä½œä¸ºå‚æ•°ä¼ å…¥
        self.player = Character(
            "ç©å®¶", 
            **PLAYER_BASE_STATS, # <-- ä½¿ç”¨æˆ‘ä»¬å®šä¹‰çš„æ ‡å‡†å±æ€§
            equipment=player_eq,
            talents=player_talents
        )
        self.current_stage = "1"
        self.loaded_dialogue_index = 0


================================================================================
### æ–‡ä»¶è·¯å¾„: loot_tables.json
================================================================================

{
    "slime": [
        {
            "item_class_name": "SlimeSword",
            "chance": 0.99
        }
    ],
    "goblin": [
        {
            "item_class_name": "IronSword",
            "chance": 0.2
        },
        {
            "item_class_name": "WoodenShield",
            "chance": 0.2
        }
    ],
    "goblin_captain": [
        { "item_class_name": "IronHammer", "chance": 0.25 },
        { "item_class_name": "IronRing", "chance": 0.15 }
    ]
}


================================================================================
### æ–‡ä»¶è·¯å¾„: main.py
================================================================================

# main.py
from game import Game
import Equips
print(f"DEBUG: æ­£åœ¨ä»è¿™ä¸ªè·¯å¾„åŠ è½½ Equips.py -> {Equips.__file__}")


if __name__ == "__main__":
    g = Game()
    g.run()


================================================================================
### æ–‡ä»¶è·¯å¾„: monster_sprite.py
================================================================================

# monster_sprite.py (å·²æ›´æ–°)
import pygame
from settings import *

class Monster(pygame.sprite.Sprite):
    def __init__(self, monster_data): # <-- æ”¹ä¸ºæ¥æ”¶æ•´ä¸ª data å­—å…¸
        super().__init__()
        self.enemy_id = monster_data['id']
        self.uid = monster_data['uid'] # <-- æ–°å¢ï¼šè®°å½•è‡ªå·±çš„ uid
        
        self.image = pygame.Surface([30, 30])
        color = (255, 0, 0)
        if self.enemy_id == "slime": color = (100, 200, 100)
        elif self.enemy_id == "goblin": color = (200, 150, 50)
        elif self.enemy_id == "ruin_golem": # Bossç”¨å¤§ä¸€ç‚¹çš„æ–¹å—å’Œä¸åŒé¢œè‰²
            self.image = pygame.Surface([60, 60])
            color = (150, 50, 200)
        
        self.image.fill(color)
        self.rect = self.image.get_rect(center=monster_data['pos'])

    def update(self):
        pass


================================================================================
### æ–‡ä»¶è·¯å¾„: player_sprite.py
================================================================================

# player_sprite.py
import pygame
from settings import *

class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.image = pygame.Surface([40, 40])
        self.image.fill(TEXT_COLOR) # æš‚æ—¶ç”¨ä¸€ä¸ªç™½è‰²æ–¹å—ä»£è¡¨ç©å®¶
        self.rect = self.image.get_rect(center=(x, y))
        self.speed = 5

    def update(self):
        """æ ¹æ®æŒ‰é”®æ›´æ–°ç©å®¶ä½ç½®"""
        keys = pygame.key.get_pressed()
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.rect.x -= self.speed
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.rect.x += self.speed
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.rect.y -= self.speed
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.rect.y += self.speed

        # ç®€å•çš„è¾¹ç•Œé™åˆ¶ï¼Œé˜²æ­¢è·‘å‡ºå±å¹•
        if self.rect.left < 0: self.rect.left = 0
        if self.rect.right > SCREEN_WIDTH: self.rect.right = SCREEN_WIDTH
        if self.rect.top < 0: self.rect.top = 0
        if self.rect.bottom > SCREEN_HEIGHT: self.rect.bottom = SCREEN_HEIGHT


================================================================================
### æ–‡ä»¶è·¯å¾„: portal_sprite.py
================================================================================

# æ–‡ä»¶: portal_sprite.py (æ–°æ–‡ä»¶)

import pygame
from settings import *

class PortalSprite(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        
        # åˆ›å»ºä¸€ä¸ªå¯è§†åŒ–çš„ä¼ é€é—¨å¤–è§‚
        self.image = pygame.Surface([120, 120], pygame.SRCALPHA)
        # ç”»ä¸€ä¸ªç´«è‰²çš„å¤–åœˆ
        pygame.draw.circle(self.image, (160, 32, 240), (60, 60), 60)
        # ç”»ä¸€ä¸ªæ·±ç´«è‰²çš„å†…åœˆ
        pygame.draw.circle(self.image, (50, 10, 80), (60, 60), 50)
        self.rect = self.image.get_rect(center=(x, y))


================================================================================
### æ–‡ä»¶è·¯å¾„: settings.py
================================================================================

# settings.py
import pygame
SCREEN_WIDTH = 1280
SCREEN_HEIGHT = 720
BG_COLOR = (10, 20, 30)
TEXT_COLOR = (230, 230, 230)
HOVER_COLOR = (200, 220, 255) # é¼ æ ‡æ‚¬åœé¢œè‰²
PANEL_BG_COLOR = (20, 35, 50)
PANEL_BORDER_COLOR = (100, 180, 255)
HP_BAR_GREEN = (0, 200, 0)
SHIELD_BAR_GREY = (150, 150, 150)
FONT_SIZE_NORMAL = 28
FONT_SIZE_SMALL = 22
FONT_SIZE_LARGE = 48
FONT_NAME_CN = 'Microsoft YaHei'
FONT_NAME_EN = 'Consolas'

# --- æ–°å¢é¢œè‰²å’Œå°ºå¯¸ ---
XP_BAR_COLOR = (150, 100, 255)      # ç»éªŒæ¡é¢œè‰²
LOG_TEXT_COLOR = (200, 200, 200)    # æˆ˜æ–—æ—¥å¿—æ–‡å­—é¢œè‰²
LOG_BG_COLOR = (30, 45, 60, 200)    # æˆ˜æ–—æ—¥å¿—èƒŒæ™¯è‰² (å¸¦é€æ˜åº¦)
BUTTON_CLICK_COLOR = (150, 200, 255) # æŒ‰é’®ç‚¹å‡»é¢œè‰²

# Buff/Debuff å›¾æ ‡å°ºå¯¸
BUFF_ICON_SIZE = (32, 32)

# --- å¸ƒå±€ä½ç½® ---
# (è¿™äº›æ˜¯å»ºè®®å€¼ï¼Œä½ å¯ä»¥éšæ—¶è°ƒæ•´)
PLAYER_PANEL_RECT = pygame.Rect(50, 450, 500, 250)
ENEMY_PANEL_RECT = pygame.Rect(SCREEN_WIDTH - 550, 50, 500, 250)
BATTLE_LOG_RECT = pygame.Rect(50, 50, SCREEN_WIDTH - 650, 350)
PLAYER_ACTION_PANEL_RECT = pygame.Rect(PLAYER_PANEL_RECT.right + 20, PLAYER_PANEL_RECT.top, 200, PLAYER_PANEL_RECT.height)


# --- ç‰©å“å“è´¨é¢œè‰² ---
RARITY_COLORS = {
    "common":    (255, 255, 255),  # ç™½è‰²
    "uncommon":  (30, 255, 30),    # ç»¿è‰²
    "rare":      (0, 150, 255),   # è“è‰²
    "epic":      (180, 50, 255),   # ç´«è‰²
    "legendary": (255, 150, 0),    # æ©™è‰²
    "mythic":    (255, 50, 50),    # çº¢è‰²
}

# --- ç©å®¶è§’è‰²é…ç½® ---
PLAYER_BASE_STATS = {
    "hp": 100,
    "defense": 3,
    "magic_resist": 3,
    "attack": 10,
    "attack_speed": 1.2,
}

# æ–‡ä»¶: settings.py (åœ¨æ–‡ä»¶æœ«å°¾è¿½åŠ )

# --- æ–°å¢ï¼šä¼¤å®³ç±»å‹é¢œè‰² ---
DAMAGE_TYPE_COLORS = {
    "PHYSICAL":      (220, 220, 220), # ç‰©ç†ä¼¤å®³ - äº®ç°è‰²
    "MAGIC":         (138, 43, 226),  # é­”æ³•ä¼¤å®³ - ç´«ç½—å…°è‰²
    "TRUE":          (255, 255, 255), # çœŸå®ä¼¤å®³ - çº¯ç™½è‰²
    "POISON":        (0, 255, 0),     # å‰§æ¯’ä¼¤å®³ - ç»¿è‰²
    "DRAGON_SOURCE": (255, 165, 0),   # é¾™æºä¼¤å®³ - æ©™è‰²
    "HEAL":          (144, 238, 144), # æ²»ç–—æ•ˆæœ - äº®ç»¿è‰²
}

# --- æ–°å¢ï¼šä¼¤å®³ç±»å‹ä¸­æ–‡å ---
DAMAGE_TYPE_NAMES_CN = {
    "PHYSICAL":      "ç‰©ç†ä¼¤å®³",
    "MAGIC":         "é­”æ³•ä¼¤å®³",
    "TRUE":          "çœŸå®ä¼¤å®³",
    "POISON":        "æ¯’ç´ ä¼¤å®³",
    "DRAGON_SOURCE": "é¾™æºä¼¤å®³",
}
# æ–‡ä»¶: settings.py (è¿½åŠ )
CRIT_COLOR = (255, 215, 0)          # æš´å‡»æ–‡å­—é¢œè‰² - é‡‘è‰²



================================================================================
### æ–‡ä»¶è·¯å¾„: story.json
================================================================================

{
    "1": {
        "type": "story",
        "text": [
            { "speaker": "æ—ç™½", "line": "ä½ çå¼€çœ¼ç›ï¼Œå‘ç°è‡ªå·±èº«å¤„ä¸€ç‰‡å®é™çš„æ£®æ—ä¹‹ä¸­ã€‚" },
            { "speaker": "æ—ç™½", "line": "é˜³å…‰é€è¿‡æ ‘å¶çš„ç¼éš™æ´’ä¸‹ï¼Œç©ºæ°”ä¸­å¼¥æ¼«ç€é’è‰çš„æ°”æ¯ã€‚" },
            { "speaker": "æ—ç™½", "line": "çªç„¶ï¼Œä¸€é˜µâ€œå’•å½å’•å½â€çš„å£°éŸ³ä¼ æ¥ï¼Œä¸€åªæœå†»çŠ¶çš„ç”Ÿç‰©å‡ºç°åœ¨ä½ é¢å‰ï¼" }
        ],
        "next": "2"
    },
    "2": {
        "type": "combat",
        "enemy_id": "slime",
        "next_win": "3",
        "next_lose": "game_over"
    },
    "3": {
        "type": "story",
        "text": [
            { "speaker": "æ—ç™½", "line": "ä½ è½»æ¾åœ°æˆ˜èƒœäº†å²è±å§†ã€‚" },
            { "speaker": "ä½ ", "line": "çœ‹æ¥è¿™é‡Œçš„ç”Ÿç‰©å¹¶æ²¡æœ‰æƒ³è±¡ä¸­é‚£ä¹ˆå¼ºå¤§ã€‚" },
            { "speaker": "ä½ ", "line": "æˆ‘å†³å®šç»§ç»­æ·±å…¥æ£®æ—ï¼Œæ¢ç´¢è¿™ä¸ªæœªçŸ¥çš„ä¸–ç•Œ..." },
            { "speaker": "æ—ç™½", "line": "(æœªå®Œå¾…ç»­)" }
        ],
        "next": "4"
    },
    "4": {
        "type": "story",
        "text": [
            { "speaker": "çŒäºº", "line": "ä½ çš„ç¬¬ä¸€ä¸ªä»»åŠ¡ï¼Œå°±æ˜¯ç‹¬è‡ªè¿›å…¥é‚£åº§ã€æ—¥ä¹‹çŸ³é—è¿¹ã€..." },
            { "speaker": "çŒäºº", "line": "æŠµè¾¾æœ€æ·±å¤„çš„åœ£å ‚ï¼Œå¹¶å¸¦å›è¯•ç‚¼å®Œæˆçš„è¯æ˜ã€‚å‡†å¤‡å¥½äº†å—ï¼Ÿ" },
            { 
                "speaker": "ç©å®¶", 
                "line": "æˆ‘å‡†å¤‡å¥½äº†ã€‚",
                "action": "start_trial"
            }
        ],
        "next": "4" 
    },
    "trial_combat": {
        "type": "combat",
        "enemy_id": "slime", 
        "next_win": "map_return", 
        "next_lose": "title"
    },
    "5": {
        "type": "story",
        "text": [
            { "speaker": "æ—ç™½", "line": "â€¦â€¦" },
            { "speaker": "æ—ç™½", "line": "â€¦â€¦â€¦â€¦â€¦â€¦" },
            { "speaker": "ä½ ", "line": "â€¦â€¦å””â€¦â€¦å¥½å›°â€¦â€¦â€¦â€¦" },
            { "speaker": "æ—ç™½", "line": "æˆ‘çš„æ„è­˜å°±åƒè¢«é»åœ¨å¤©èŠ±æ¿ä¸Šçš„å£é¦™ç³–ï¼Œæ™æ‰è‘—æƒ³å¾€ä¸‹æ‰ï¼Œå»æ€éº¼ä¹Ÿæ“ºè„«ä¸äº†é‚£è‚¡é»è†©çš„ç¡æ„ã€‚" },
            { "speaker": "æ—ç™½", "line": "è€³é‚Šæ˜¯ã€Œå˜å±ã€å˜å±ã€çš„æœ¨é ­å‘»åŸè²ï¼Œé‚£è€èˆŠçš„æœ¨æ¿å¥½åƒéš¨æ™‚éƒ½æœƒæ•£æ¶ä¸€æ¨£ï¼Œé‚„æœ‰è¦å¾‹å¾—è®“äººæƒ³æ‰“çŒç¡çš„æµ·æµªæ‹æ‰“èˆ¹èº«çš„ã€Œå™—é€šã€å™—é€šã€æ‚¶éŸ¿ã€‚" },
            { "speaker": "æ—ç™½", "line": "é¼»è…”è£¡å……æ–¥è‘—ä¸€è‚¡é¹¹æ¾€çš„æµ·é¢¨ï¼Œæ··åˆè‘—è€æœ¨é ­å’Œä¸€é»é»èªªä¸æ¸…é“ä¸æ˜çš„é­šè…¥å‘³ï¼Œå—¯ï¼Œé€™å°±æ˜¯ã€Œæµ·ä¸Šç”·å…’ã€çš„æµªæ¼«å§ï¼Œå¤§æ¦‚ã€‚" },
            { "speaker": "æ—ç™½", "line": "çœ¼çš®å°±åƒçŒäº†é‰›ä¸€æ¨£æ²‰é‡ï¼Œæ¯”æˆ‘æœŸæœ«è€ƒè©¦å‰ç†¬å¤œçœ‹æ¼«ç•«çš„çœ¼ç›é‚„é‡ã€‚" },
            { "speaker": "ä½ ", "line": "ã€Œå†ç¡äº”åˆ†é˜ï¼Œå°±äº”åˆ†é˜â€¦â€¦ã€æˆ‘å¿ƒè£¡å˜€å’•è‘—ï¼Œç¿»äº†å€‹èº«ã€‚" },
            { "speaker": "ä½ ", "line": "â€¦â€¦" },
            { "speaker": "ä½ ", "line": "ç­‰ç­‰ï¼ç¾åœ¨æ˜¯ä»€éº¼æ™‚å€™äº†ï¼Ÿï¼" }
        ],
        "next": "quit"
    }
}


================================================================================
### æ–‡ä»¶è·¯å¾„: Talents.py
================================================================================

import Buffs
from abc import ABC
import collections
from collections import defaultdict
from rich.console import Console, Group
from rich.live import Live
from rich.table import Table
from rich.panel import Panel
from rich.text import Text
import time
import random
from rich.text import Text
from rich.progress import BarColumn  # å¯é€‰ï¼šä¹Ÿå¯ä»¥ç›´æ¥ç”¨ Text
import math
from collections import Counter
#import pygame
import sys
from rich.console import Console

from damage import DamagePacket, DamageType
from battle_logger import battle_logger
from settings import TEXT_COLOR, DAMAGE_TYPE_COLORS
from ui import format_damage_log

class Talent:
    """å¤©èµ‹åŸºç±»ï¼Œä¹‹åå¯æ‰©å±•æ›´å¤šé’©å­"""
    display_name = None
    def on_init(self, wearer):
        """è§’è‰²åˆ›å»º/æˆ˜å‰åˆå§‹åŒ–æ—¶è§¦å‘ï¼Œç”¨äºä¿®æ”¹æ§½ä½ä¹‹ç±»çš„å±æ€§"""
        pass
    def on_attack(self, wearer, target, dmg):
        """æ”»å‡»åè§¦å‘"""
        pass
    def on_debuff_applied(self, wearer, buff):
        """å½“ä¸€ä¸ª Debuff è¢«åŠ åˆ° wearer ä¸Šæ—¶è§¦å‘"""
        pass
        
class PoisonousTalent(Talent):
    display_name = "æ¯’ç‰©"
    def __init__(self, chance: float = 0.5):
        self.chance = chance

    def on_attack(self, wearer, target, dmg):
        if random.random() < self.chance:
            target.add_debuff(Buffs.PoisonDebuff(stacks=1), source=wearer)

class DualWieldTalent(Talent):
    """äºŒåˆ€æµï¼šæ­¦å™¨æ§½æå‡åˆ° 2"""
    display_name = "äºŒåˆ€æµ"
    def on_init(self, wearer):
        cur = wearer.SLOT_CAPACITY.get("weapon", 1)
        if cur < 2:
            wearer.SLOT_CAPACITY["weapon"] = 2

class TripleWieldTalent(Talent):
    """ä¸‰åˆ€æµï¼šæ­¦å™¨æ§½æå‡åˆ° 3"""
    display_name = "ä¸‰åˆ€æµ"
    def on_init(self, wearer):
        cur = wearer.SLOT_CAPACITY.get("weapon", 1)
        if cur < 3:
            wearer.SLOT_CAPACITY["weapon"] = 3

class ThousandWorldTalent(Talent):
    """ä¸‰åƒä¸–ç•Œï¼šæ™®æ”»æ—¶æœ‰ chance æ¦‚ç‡ç«‹å³é¢å¤–è¿ç»­æ™®æ”» 2 æ¬¡"""
    display_name = "ä¸‰åƒä¸–ç•Œ"

    def __init__(self, chance: float = 0.33):
        self.chance = chance

    # æ–‡ä»¶: Talents.py (åœ¨ ThousandWorldTalent ç±»ä¸­ï¼Œæ›¿æ¢ on_attack æ–¹æ³•)

    def on_attack(self, wearer, target, dmg):
        """
        é¢å¤–æ”»å‡»ç°åœ¨ä¼šè‡ªå·±å¤„ç†æ—¥å¿—ï¼Œæ‰€ä»¥è¿™é‡Œä¸å†éœ€è¦è¿”å›ä»»ä½•ä¸œè¥¿ã€‚
        """
        if random.random() < self.chance:
            # é¢å¤–å‡ºæ‰‹ä¸¤æ¬¡
            for _ in range(2):
                wearer.perform_extra_attack(target)
        # ä¸å†éœ€è¦è¿”å› extra_texts

class HeartOfHealingTalent(Talent):
    """æ²»æ„ˆä¹‹å¿ƒï¼šè¢«æ–½åŠ å¯é©±æ•£çš„ Debuff æ—¶ï¼Œ30% æ¦‚ç‡é©±æ•£æ­¤å±‚ï¼Œå¹¶è·å¾— 1 å±‚ å†ç”Ÿ"""
    display_name = "æ²»æ„ˆä¹‹å¿ƒ"

    def __init__(self, chance: float = 0.3):
        self.chance = chance

    def on_debuff_applied(self, wearer, buff):
        if random.random() < self.chance:
            # é©±æ•£ä¸€å±‚
            if hasattr(buff, "stacks"):
                buff.stacks -= 1
                if buff.stacks <= 0:
                    wearer.remove_buff(buff)
            else:
                wearer.remove_buff(buff)
            # è·å¾— 1 å±‚â€œå†ç”Ÿâ€
            wearer.add_buff(Buffs.RegenerationBuff(stacks=1))

class BambooLeafTalent(Talent):
    display_name = "ç«¹å¶é’"

    def __init__(self, chance: float = 1.0):
        self.chance = chance
        self._bamboo_atk_bonus = 0  # ä¸Šä¸€æ¬¡æ€»åŠ æˆ
        self._bamboo_spd_bonus = 0

    def on_inflict_debuff(self, wearer, target, buff, added_stacks):
        # åªæœ‰æ˜¯ PoisonDebuff ä¸”æ¦‚ç‡å‘½ä¸­æ‰è§¦å‘
        if not isinstance(buff, Buffs.PoisonDebuff) or random.random() >= self.chance:
            return

        # â‘  ç»™è‡ªå·±åŠ è¿™æ¬¡ç›¸åŒçš„å±‚æ•°
        own = next((b for b in wearer.buffs if isinstance(b, Buffs.PoisonDebuff)), None)
        if own:
            own.stacks = min(own.stacks + added_stacks, own.max_stacks)
        else:
            wearer.add_buff(Buffs.PoisonDebuff(stacks=added_stacks))

        # â‘¡ ç»Ÿè®¡å½“å‰æ¯’æ€»å±‚æ•°
        total_stacks = next((b.stacks for b in wearer.buffs if isinstance(b, Buffs.PoisonDebuff)), 0)

        # â‘¢ æ’¤é”€æ—§åŠ æˆ
        wearer.attack -= self._bamboo_atk_bonus
        current_as = 6.0 / wearer.attack_interval
        base_as = current_as - self._bamboo_spd_bonus

        # â‘£ é‡æ–°è®¡ç®—åŠ æˆï¼ˆåŸºäºæ€»æ¯’å±‚æ•°ï¼‰
        atk_bonus = total_stacks * 1
        spd_bonus = total_stacks * 0.1

        wearer.attack += atk_bonus
        wearer.attack_interval = 6.0 / (base_as + spd_bonus)

        # â‘¤ è®°å½•æ–°çš„åŠ æˆå€¼
        self._bamboo_atk_bonus = atk_bonus
        self._bamboo_spd_bonus = spd_bonus

class GlassCannon(Talent):
    """ã€å¤©èµ‹ã€‘ç»ç’ƒå¤§ç‚®ï¼šé€ æˆçš„ä¼¤å®³æå‡50%ï¼Œå—åˆ°çš„ä¼¤å®³ä¹Ÿæå‡30%ã€‚"""
    display_name = "ç»ç’ƒå¤§ç‚®"
    def on_init(self, wearer):
        wearer.attack *= 1.5
        wearer.damage_resistance -= 0.3

class Giant(Talent):
    """ã€å¤©èµ‹ã€‘å·¨äººï¼šæœ€å¤§ç”Ÿå‘½å€¼æå‡50%ï¼Œä½†æ”»å‡»é€Ÿåº¦é™ä½20%ã€‚"""
    display_name = "å·¨äºº"
    def on_init(self, wearer):
        wearer.max_hp *= 1.5
        wearer.hp = wearer.max_hp
        wearer.attack_speed *= 0.8
        wearer.attack_interval = 6.0 / wearer.attack_speed


class Executioner(Talent):
    """ã€å¤©èµ‹ã€‘å¤„å†³è€…ï¼šç«‹å³æ–©æ€ç”Ÿå‘½å€¼ä½äº20%çš„æ•Œäººã€‚"""
    display_name = "å¤„å†³è€…"
    
    def on_attack(self, wearer, target, dmg):
        # è¿™ä¸ªæ•ˆæœåœ¨é€ æˆä¼¤å®³åè§¦å‘
        if target.hp > 0 and (target.hp / target.max_hp < 0.2):
            print(f"[å¤„å†³è€…] æ–©æ€äº† {target.name}ï¼")
            kill_damage = target.hp
            packet = DamagePacket(amount=kill_damage, damage_type=DamageType.TRUE, source=wearer)
            target.take_damage(packet)

class Scavenger(Talent):
    """ã€å¤©èµ‹ã€‘æ¸…é“å¤«ï¼šå‡»è´¥æ•Œäººæ—¶è·å¾—çš„é‡‘å¸æå‡50%ã€‚"""
    display_name = "æ¸…é“å¤«"
    # (æ­¤å¤©èµ‹çš„é€»è¾‘éœ€è¦åœ¨ç»™äºˆé‡‘å¸çš„åœ°æ–¹æ£€æŸ¥)

class MagicShield(Talent):
    """ã€å¤©èµ‹ã€‘æ³•åŠ›æŠ¤ç›¾ï¼šè·å¾—+20é­”æ³•æŠ—æ€§ã€‚"""
    display_name = "æ³•åŠ›æŠ¤ç›¾"
    def on_init(self, wearer):
        wearer.magic_resist += 20

class FirstStrike(Talent):
    """ã€å¤©èµ‹ã€‘å…ˆå‘åˆ¶äººï¼šè¿›å…¥æˆ˜æ–—åçš„ç¬¬ä¸€æ¬¡æ”»å‡»å¿…å®šæš´å‡»ã€‚"""
    display_name = "å…ˆå‘åˆ¶äºº"
    def on_init(self, wearer):
        self._used = False
    def on_attack(self, wearer, target, dmg):
        if not self._used:
            # è¿™ä¸ªå¤©èµ‹æœ€å¥½åœ¨ before_attack é’©å­ä¸­å®ç°
            pass 
    
class LastStand(Talent):
    """ã€å¤©èµ‹ã€‘èƒŒæ°´ä¸€æˆ˜ï¼šç”Ÿå‘½å€¼ä½äº25%æ—¶ï¼Œè·å¾—50%ä¼¤å®³å‡å…ã€‚"""
    display_name = "èƒŒæ°´ä¸€æˆ˜"
    def on_init(self, wearer):
        wearer.damage_resistance_last_stand = 0.5 # è‡ªå®šä¹‰ä¸€ä¸ªå±æ€§
    # (æ­¤å¤©èµ‹çš„é€»è¾‘éœ€è¦åœ¨ take_damage ä¸­æ£€æŸ¥)

class AdrenalineRush(Talent):
    """ã€å¤©èµ‹ã€‘è‚¾ä¸Šè…ºç´ ï¼šæ¯æ¬¡æ€æ­»æ•Œäººï¼Œæ”»å‡»é€Ÿåº¦æå‡10%ï¼ŒæŒç»­åˆ°æˆ˜æ–—ç»“æŸã€‚"""
    display_name = "è‚¾ä¸Šè…ºç´ "
    # (æ­¤å¤©èµ‹é€»è¾‘å¤æ‚ï¼Œéœ€è¦æˆ˜æ–—ç³»ç»Ÿæ”¯æŒ on_kill é’©å­)

class Brawler(Talent):
    """ã€å¤©èµ‹ã€‘æ ¼æ–—å®¶ï¼šä½ æ— æ³•è£…å¤‡å‰¯æ‰‹ç‰©å“ï¼Œä½†ä½ çš„åŸºç¡€æ”»å‡»åŠ›æå‡30%ã€‚"""
    display_name = "æ ¼æ–—å®¶"
    def on_init(self, wearer):
        # åªæ˜¯ä¿®æ”¹è§„åˆ™å’ŒåŸºç¡€å€¼ï¼Œä¸å†è°ƒç”¨recalculate_stats
        wearer.SLOT_CAPACITY["offhand"] = 0
        wearer.base_attack *= 1.3 
        # ç§»é™¤ä¸‹é¢è¿™ä¸¤è¡Œ
        # wearer.attack = wearer.base_attack
        # wearer.recalculate_stats()

class Adventurer(Talent):
    """ã€å¤©èµ‹ã€‘å†’é™©è€…ï¼šè·å¾—çš„ç»éªŒå€¼æå‡50%ã€‚"""
    display_name = "å†’é™©è€…"
    # (æ­¤å¤©èµ‹çš„é€»è¾‘éœ€è¦åœ¨ add_exp ä¸­æ£€æŸ¥)

class SacredRetribution(Talent):
    """ã€ç¥åœ£æŠ¥å¿ã€‘: æ¯å½“ä½ æ¢å¤ç”Ÿå‘½æ—¶ï¼Œå¯¹æ•Œäººé€ æˆç­‰åŒäº50%æ¢å¤é‡çš„çœŸå®ä¼¤å®³ã€‚"""
    display_name = "ç¥åœ£æŠ¥å¿"

    def on_healed(self, wearer, healed_amount, combat_target):
        if combat_target and combat_target.hp > 0 and healed_amount > 0:
            damage = healed_amount * 0.5
            
            from damage import DamagePacket, DamageType
            packet = DamagePacket(amount=damage, damage_type=DamageType.TRUE, source=wearer)
            
            # ### æ ¸å¿ƒä¿®æ”¹ï¼šå…ˆè·å–ä¼¤å®³æŠ¥å‘Šï¼Œå†ç”¨å·¥å…·æ ¼å¼åŒ–æ—¥å¿— ###
            damage_details = combat_target.take_damage(packet)
            log_parts = format_damage_log(damage_details, action_name="ç¥åœ£æŠ¥å¿")
            battle_logger.log(log_parts)

            # ä¸å†éœ€è¦è¿”å›ä»»ä½•ä¸œè¥¿


class Overwhelm(Talent):
    """ã€ç ´åŠ¿ã€‘: å¯¹ç”Ÿå‘½å€¼é«˜äº50%çš„æ•Œäººï¼Œä½ çš„æ”»å‡»é€ æˆ200%ä¼¤å®³ã€‚"""
    display_name = "ç ´åŠ¿"

    def before_attack(self, wearer, target, packet: DamagePacket):
        """è¿™æ˜¯ä¸€ä¸ªæ–°çš„è‡ªå®šä¹‰é’©å­ï¼Œä¼šåœ¨Character.try_attackä¸­è¢«è°ƒç”¨"""
        if target.hp / target.max_hp > 0.5:
            packet.amount *= 2

class SunfireAura(Talent):
    """ã€æ—¥ç‚å…‰ç¯ã€‘: æˆ˜æ–—å¼€å§‹æ—¶ï¼Œå¯¹æ•Œäººæ–½åŠ ã€æ—¥ç‚ç¼çƒ§ã€‘æ•ˆæœã€‚"""
    display_name = "æ—¥ç‚å…‰ç¯"

    def on_battle_start(self, wearer, enemy):
        """è¿™æ˜¯ä¸€ä¸ªæ–°çš„è‡ªå®šä¹‰é’©å­ï¼Œä¼šåœ¨CombatScreenä¸­è¢«è°ƒç”¨"""
        print(f"[{wearer.name}çš„æ—¥ç‚å…‰ç¯] å¯¹ {enemy.name} æ–½åŠ äº†ç¼çƒ§ï¼")
        enemy.add_debuff(Buffs.SunfireAuraDebuff(source_char=wearer))


================================================================================
### æ–‡ä»¶è·¯å¾„: treasure_sprite.py
================================================================================

# treasure_sprite.py
import pygame
from settings import *

class TreasureChest(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        
        # å°†æ¥ä½ å¯ä»¥æ¢æˆæ¼‚äº®çš„å®ç®±å›¾ç‰‡
        # ç°åœ¨æˆ‘ä»¬ç”¨ä¸€ä¸ªé‡‘è‰²çš„æ–¹å—ä»£æ›¿
        self.image = pygame.Surface([60, 50])
        self.image.fill((255, 215, 0)) # é‡‘è‰²
        self.rect = self.image.get_rect(center=(x, y))


================================================================================
### æ–‡ä»¶è·¯å¾„: ui.py
================================================================================

# æ–‡ä»¶: ui.py (æœ€ç»ˆæ­£ç¡®ç‰ˆæœ¬)

import pygame
import textwrap
import inspect
import os
from collections import deque
from settings import *
from settings import DAMAGE_TYPE_NAMES_CN, DAMAGE_TYPE_COLORS, TEXT_COLOR, CRIT_COLOR

def init_fonts():
    fonts = {}
    try:
        fonts['normal'] = pygame.font.SysFont(FONT_NAME_CN, FONT_SIZE_NORMAL)
        fonts['small'] = pygame.font.SysFont(FONT_NAME_CN, FONT_SIZE_SMALL)
        fonts['large'] = pygame.font.SysFont(FONT_NAME_CN, FONT_SIZE_LARGE)
        fonts['minimap'] = pygame.font.SysFont(FONT_NAME_CN, 16) 
    except pygame.error:
        print("è­¦å‘Š: æœªæ‰¾åˆ°æŒ‡å®šä¸­æ–‡å­—ä½“ï¼Œå°†ä½¿ç”¨é»˜è®¤å­—ä½“ã€‚")
        fonts['normal'] = pygame.font.Font(None, FONT_SIZE_NORMAL + 4)
        fonts['small'] = pygame.font.Font(None, FONT_SIZE_SMALL + 4)
        fonts['large'] = pygame.font.Font(None, FONT_SIZE_LARGE + 4)
        fonts['minimap'] = pygame.font.Font(None, 18)
    return fonts

class Button:
    def __init__(self, rect, text, font):
        self.rect = pygame.Rect(rect)
        self.text = text
        self.font = font
        self.is_hovered = False
        self.is_clicked = False
    def handle_event(self, event):
        action_triggered = False
        if event.type == pygame.MOUSEMOTION:
            self.is_hovered = self.rect.collidepoint(event.pos)
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1 and self.is_hovered:
            self.is_clicked = True
            action_triggered = True
        if event.type == pygame.MOUSEBUTTONUP and event.button == 1:
            self.is_clicked = False
        return action_triggered
    def draw(self, surface):
        button_color = PANEL_BG_COLOR
        if self.is_clicked: button_color = BUTTON_CLICK_COLOR
        elif self.is_hovered: button_color = PANEL_BORDER_COLOR
        pygame.draw.rect(surface, button_color, self.rect, border_radius=10)
        pygame.draw.rect(surface, PANEL_BORDER_COLOR, self.rect, 2, border_radius=10)
        text_surf = self.font.render(self.text, True, TEXT_COLOR)
        text_rect = text_surf.get_rect(center=self.rect.center)
        surface.blit(text_surf, text_rect)

def draw_text(surface, text, font, color, rect, aa=True):
    y = rect.top
    line_spacing = -2
    font_height = font.size("Tg")[1]
    max_chars_per_line = rect.width // font.size("ä¸€")[0] if font.size("ä¸€")[0] > 0 else 1
    wrapped_text = textwrap.wrap(text, width=max_chars_per_line)
    for line in wrapped_text:
        line_surface = font.render(line, aa, color)
        surface.blit(line_surface, (rect.left, y))
        y += font_height + line_spacing

def draw_panel(surface, rect, title, font):
    pygame.draw.rect(surface, PANEL_BG_COLOR, rect, border_radius=10)
    pygame.draw.rect(surface, PANEL_BORDER_COLOR, rect, 3, border_radius=10)
    title_surf = font.render(title, True, TEXT_COLOR)
    title_rect = title_surf.get_rect(center=(rect.centerx, rect.top + 50))
    surface.blit(title_surf, title_rect)

def get_display_name(obj):
    return getattr(obj, 'display_name', obj.__class__.__name__)

def draw_character_panel(surface, char, rect, fonts):
    ui_elements = {'talents': [], 'buffs': []}
    pygame.draw.rect(surface, PANEL_BG_COLOR, rect, border_radius=15)
    pygame.draw.rect(surface, PANEL_BORDER_COLOR, rect, 3, border_radius=15)
    
    name_surf = fonts['large'].render(char.name, True, TEXT_COLOR)
    level_surf = fonts['normal'].render(f"Lv. {char.level}", True, TEXT_COLOR)
    surface.blit(name_surf, (rect.left + 20, rect.top + 15))
    surface.blit(level_surf, (rect.left + name_surf.get_width() + 30, rect.top + 28))

    hp_bar_rect = pygame.Rect(rect.left + 20, rect.top + 80, rect.width - 40, 30)
    hp_percent = char.hp / char.max_hp if char.max_hp > 0 else 0
    hp_width = (hp_bar_rect.width - 4) * hp_percent
    pygame.draw.rect(surface, (50,50,50), hp_bar_rect, border_radius=5)
    pygame.draw.rect(surface, HP_BAR_GREEN, (hp_bar_rect.left + 2, hp_bar_rect.top + 2, hp_width, hp_bar_rect.height - 4), border_radius=5)
    if char.shield > 0:
        shield_percent = min(char.shield / char.max_hp, 1.0)
        shield_width = (hp_bar_rect.width - 4) * shield_percent
        shield_rect_pos = hp_bar_rect.left + 2 + hp_width
        pygame.draw.rect(surface, SHIELD_BAR_GREY, (shield_rect_pos, hp_bar_rect.top + 2, shield_width, hp_bar_rect.height - 4), border_radius=5)
    hp_text = f"{int(char.hp)}/{int(char.max_hp)}" + (f" (+{int(char.shield)})" if char.shield > 0 else "")
    hp_text_surf = fonts['small'].render(hp_text, True, TEXT_COLOR)
    surface.blit(hp_text_surf, hp_text_surf.get_rect(center=hp_bar_rect.center))

    stats_text = f"æ”»å‡»: {int(char.attack)} | é˜²å¾¡: {int(char.defense)} | æ”»é€Ÿ: {char.attack_speed:.2f}"
    stats_surf = fonts['small'].render(stats_text, True, TEXT_COLOR)
    surface.blit(stats_surf, (rect.left + 20, rect.top + 140))

    equipped_talents_to_draw = [t for t in char.equipped_talents if t is not None]
    if equipped_talents_to_draw:
        current_x = rect.left + 20
        talent_label_surf = fonts['small'].render("å¤©èµ‹: ", True, (255, 215, 0))
        surface.blit(talent_label_surf, (current_x, rect.top + 170))
        current_x += talent_label_surf.get_width()
        for i, talent in enumerate(equipped_talents_to_draw):
            name_surf = fonts['small'].render(talent.display_name, True, (255, 215, 0))
            name_rect = name_surf.get_rect(left=current_x, top=rect.top + 170)
            surface.blit(name_surf, name_rect)
            ui_elements['talents'].append((name_rect, talent))
            current_x += name_rect.width
            if i < len(equipped_talents_to_draw) - 1:
                separator_surf = fonts['small'].render(" | ", True, (255, 215, 0))
                surface.blit(separator_surf, (current_x, rect.top + 170))
                current_x += separator_surf.get_width()

    visible_buffs = [b for b in char.buffs if not b.hidden]
    if visible_buffs:
        current_x = rect.left + 20
        status_label_surf = fonts['small'].render("çŠ¶æ€: ", True, TEXT_COLOR)
        surface.blit(status_label_surf, (current_x, rect.top + 200))
        current_x += status_label_surf.get_width()
        for i, buff in enumerate(visible_buffs):
            buff_text = buff.display_name
            if buff.max_stacks > 1 and buff.stacks > 1: buff_text += f"({buff.stacks})"
            color = (255, 80, 80) if buff.is_debuff else (80, 255, 80)
            text_surf = fonts['small'].render(buff_text, True, color)
            text_rect = text_surf.get_rect(left=current_x, top=rect.top + 200)
            surface.blit(text_surf, text_rect)
            ui_elements['buffs'].append((text_rect, buff))
            current_x += text_rect.width
            if i < len(visible_buffs) - 1:
                separator_surf = fonts['small'].render(" | ", True, TEXT_COLOR)
                surface.blit(separator_surf, (current_x, rect.top + 200))
                current_x += separator_surf.get_width()
    
    return ui_elements

# æ–‡ä»¶: ui.py (å®Œæ•´æ›¿æ¢ ScrollableTextRenderer ç±»)

class ScrollableTextRenderer:
    def __init__(self, rect, font, line_height, text_color=(200, 200, 200), bg_color=(30, 30, 30, 180)):
        self.rect = rect
        self.font = font
        self.line_height = line_height
        self.default_text_color = text_color # <-- é‡å‘½åï¼Œä»¥ç¤ºåŒºåˆ†
        self.bg_color = bg_color
        self.messages = []
        self.offset = 0
        self.visible_lines = int(self.rect.height / self.line_height)
        self.scroll_bar_width = 10
        self.padding = 5

    def add_message(self, parts, color=None):
        """
        ### æ ¸å¿ƒå‡çº§ ###
        ç°åœ¨å¯ä»¥æ¥æ”¶ä¸€ä¸ª parts åˆ—è¡¨ï¼Œæ ¼å¼ä¸º: [(text1, color1), (text2, color2), ...]
        ä¸ºäº†å‘åå…¼å®¹ï¼Œå¦‚æœä¼ å…¥çš„æ˜¯æ™®é€šå­—ç¬¦ä¸²ï¼Œåˆ™è‡ªåŠ¨åŒ…è£…ã€‚
        """
        if isinstance(parts, str):
            # å¦‚æœåªä¼ å…¥ä¸€ä¸ªæ™®é€šå­—ç¬¦ä¸²ï¼Œå°±ç”¨æä¾›çš„é¢œè‰²æˆ–é»˜è®¤é¢œè‰²åŒ…è£…å®ƒ
            self.messages.append([(parts, color if color else self.default_text_color)])
        else:
            # å¦åˆ™ï¼Œå‡å®šä¼ å…¥çš„æ˜¯ä¸€ä¸ªåˆ—è¡¨
            self.messages.append(parts)

        if len(self.messages) > self.visible_lines:
            self.offset = len(self.messages) - self.visible_lines

    def handle_event(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN:
            if self.rect.collidepoint(event.pos):
                if event.button == 4: self.scroll(-1)
                elif event.button == 5: self.scroll(1)

    def scroll(self, delta_lines):
        max_offset = max(0, len(self.messages) - self.visible_lines)
        self.offset = max(0, min(self.offset + delta_lines, max_offset))

    def draw(self, surface):
        pygame.draw.rect(surface, self.bg_color, self.rect, border_radius=5)
        pygame.draw.rect(surface, PANEL_BORDER_COLOR, self.rect, 2, border_radius=5)
        
        content_rect = pygame.Rect(
            self.rect.left + self.padding, self.rect.top + self.padding,
            self.rect.width - 2 * self.padding - (self.scroll_bar_width if len(self.messages) > self.visible_lines else 0),
            self.rect.height - 2 * self.padding
        )
        display_surface = surface.subsurface(content_rect)

        for i in range(self.visible_lines):
            msg_idx = self.offset + i
            if msg_idx < len(self.messages):
                message_parts = self.messages[msg_idx]
                current_x = 0
                
                # ### æ ¸å¿ƒå‡çº§ ###
                # éå†ä¸€è¡Œä¸­çš„æ‰€æœ‰ç‰‡æ®µï¼Œå¹¶æŒ¨ä¸ªç»˜åˆ¶
                for text, color in message_parts:
                    text_surf = self.font.render(text, True, color)
                    display_surface.blit(text_surf, (current_x, i * self.line_height))
                    current_x += text_surf.get_width() # ç§»åŠ¨ä¸‹ä¸€ä¸ªç‰‡æ®µçš„èµ·å§‹xåæ ‡

        if len(self.messages) > self.visible_lines:
            bar_height = max(10, (self.visible_lines / len(self.messages)) * content_rect.height)
            bar_y_ratio = self.offset / max(1, len(self.messages) - self.visible_lines)
            bar_y = content_rect.top + bar_y_ratio * (content_rect.height - bar_height)
            
            scroll_bg_rect = pygame.Rect(self.rect.right - self.scroll_bar_width - self.padding, self.rect.top + self.padding, self.scroll_bar_width, content_rect.height)
            pygame.draw.rect(surface, (50, 50, 50), scroll_bg_rect, border_radius=3)
            slider_rect = pygame.Rect(scroll_bg_rect.left, bar_y, self.scroll_bar_width, bar_height)
            pygame.draw.rect(surface, (150, 150, 150), slider_rect, border_radius=3)


class TooltipManager:
    def __init__(self, font, delay=500):
        self.font, self.delay = font, delay
        self.active_item, self.hover_start_time, self.tooltip_surface = None, 0, None
    def _get_description(self, item):
        if not item: return None
        doc = inspect.getdoc(item)
        if not doc: return get_display_name(item)
        display_name = getattr(item, 'display_name', item.__class__.__name__)
        return f"[ {display_name} ]\n" + "-"*20 + f"\n{doc}"
    def update(self, hovered_item):
        now = pygame.time.get_ticks()
        if hovered_item:
            if self.active_item != hovered_item:
                self.active_item, self.hover_start_time, self.tooltip_surface = hovered_item, now, None
            elif now - self.hover_start_time > self.delay and not self.tooltip_surface:
                self._create_tooltip_surface(self._get_description(self.active_item))
        else:
            self.active_item, self.tooltip_surface = None, None
    def _create_tooltip_surface(self, text):
        if not text: return
        lines, wrapped_lines, max_width = text.splitlines(), [], 0
        for line in lines:
            wrapped = textwrap.wrap(line, width=40, replace_whitespace=False)
            if not wrapped: wrapped_lines.append("")
            for wrapped_line in wrapped:
                wrapped_lines.append(wrapped_line)
                line_width = self.font.size(wrapped_line)[0]
                if line_width > max_width: max_width = line_width
        padding, line_height = 15, self.font.get_height()
        total_width, total_height = max_width + padding * 2, len(wrapped_lines) * line_height + padding * 2
        self.tooltip_surface = pygame.Surface((total_width, total_height), pygame.SRCALPHA)
        self.tooltip_surface.fill((20, 35, 50, 230))
        pygame.draw.rect(self.tooltip_surface, PANEL_BORDER_COLOR, self.tooltip_surface.get_rect(), 2, border_radius=8)
        current_y = padding
        for line in wrapped_lines:
            text_surf = self.font.render(line, True, TEXT_COLOR)
            self.tooltip_surface.blit(text_surf, (padding, current_y))
            current_y += line_height
    def draw(self, surface):
        if self.tooltip_surface:
            mouse_pos = pygame.mouse.get_pos()
            tooltip_rect = self.tooltip_surface.get_rect(topleft=(mouse_pos[0] + 15, mouse_pos[1] + 15))
            if tooltip_rect.right > SCREEN_WIDTH: tooltip_rect.right = mouse_pos[0] - 15
            if tooltip_rect.bottom > SCREEN_HEIGHT: tooltip_rect.bottom = mouse_pos[1] - 15
            surface.blit(self.tooltip_surface, tooltip_rect)

def format_damage_log(damage_details, action_name="æ•ˆæœ"):
    """
    ä¸€ä¸ªæ ‡å‡†åŒ–çš„ä¼¤å®³æ—¥å¿—æ ¼å¼åŒ–å·¥å…·ã€‚
    æ¥æ”¶ take_damage è¿”å›çš„â€œä¼¤å®³æŠ¥å‘Šâ€å­—å…¸å’Œä¸€ä¸ªåŠ¨ä½œåç§°ï¼Œ
    è¿”å›ä¸€ä¸ªå¯ä¾› log_renderer ä½¿ç”¨çš„å¯Œæ–‡æœ¬åˆ—è¡¨ã€‚
    """
    if not damage_details:
        return []

    source_name = "ç¯å¢ƒ"
    if damage_details["source"]:
        source_name = damage_details["source"].name

    target_name = damage_details["target"].name
    dmg_amount = damage_details["final_amount"]
    dmg_type_enum = damage_details["damage_type"]
    
    dmg_type_name = DAMAGE_TYPE_NAMES_CN.get(dmg_type_enum.name, "æœªçŸ¥ä¼¤å®³")
    dmg_color = DAMAGE_TYPE_COLORS.get(dmg_type_enum.name, (255, 255, 255))

    # ä½¿ç”¨é‡‘è‰²æ¥çªå‡ºæ˜¾ç¤ºåŠ¨ä½œåç§°
    action_color = (255, 215, 0) 

    log_parts = [
        (f"[{source_name}]", TEXT_COLOR),
        (f" çš„ ", TEXT_COLOR),
        (f"[{action_name}]", action_color),
        (f" å¯¹ ", TEXT_COLOR),
        (f"[{target_name}]", TEXT_COLOR),
        (f" é€ æˆäº† ", TEXT_COLOR),
        (f"{dmg_amount} ç‚¹ [{dmg_type_name}]", dmg_color),
    ]

    if damage_details["is_critical"]:
        log_parts.append((" (æš´å‡»!)", CRIT_COLOR))
        
    return log_parts


================================================================================
### æ–‡ä»¶è·¯å¾„: dungeons\sunstone_ruins.json
================================================================================


{
    "id": "sunstone_ruins",
    "name": "æ—¥ä¹‹çŸ³é—è¿¹",
    "description": "ä¸€åº§è¢«é˜³å…‰é—å¿˜çš„å¤è€é—è¿¹ï¼Œå……æ»¡äº†åŸºç¡€çš„å…ƒç´ ç”Ÿç‰©å’Œå“¥å¸ƒæ—ã€‚",

    
    "floor_pools": [
        {
            "floors": [1, 2, 3],
            "monster_pool": ["slime", "goblin", "giant_bat"], 
            "elite_pool": ["goblin_captain", "armored_skeleton"], 
            "boss_id": "ruin_golem",
            "event_pool": ["fountain_of_power", "wandering_spirit"],
            "shop_items": {
                "item_count": 3,
                "rarity_weights": { "common": 70, "uncommon": 30, "rare": 5 }
            },
            "treasure_loot": {
                "item_count": 2,
                "rarity_weights": { "common": 60, "uncommon": 35, "rare": 10, "epic": 1 }
            }
        },
        {
            "floors": [4, 5],
            "monster_pool": ["wild_boar", "forest_spirit", "rock_golem"],
            "elite_pool": ["fire_elemental", "ice_elemental"],
            "boss_id": "dark_knight",
            "event_pool": ["wandering_spirit"],
            "shop_items": {
                "item_count": 4,
                "rarity_weights": { "common": 20, "uncommon": 50, "rare": 25, "epic": 5 }
            },
            "treasure_loot": {
                "item_count": 2,
                "rarity_weights": { "common": 10, "uncommon": 40, "rare": 40, "epic": 10 }
            }
        }
    ]
}


================================================================================
### æ–‡ä»¶è·¯å¾„: states\backpack.py
================================================================================

# æ–‡ä»¶: states/backpack.py (å®Œæ•´æ›¿æ¢)

# ... (æ‰€æœ‰ import è¯­å¥ä¿æŒä¸å˜) ...
import pygame
import math
from .base import BaseState
from ui import draw_text, draw_panel, get_display_name, TooltipManager, Button
from settings import *

# ... (SLOT_CONFIG å’Œ RARITY_COLORS ä¿æŒä¸å˜) ...
SLOT_CONFIG = {
    "weapon": {"name": "æ­¦å™¨", "icon": "æ­¦", "color": (255, 100, 100)},
    "offhand": {"name": "å‰¯æ‰‹", "icon": "å‰¯", "color": (100, 255, 100)},
    "helmet": {"name": "å¤´ç›”", "icon": "å¤´", "color": (255, 255, 100)},
    "armor": {"name": "èƒ¸ç”²", "icon": "ç”²", "color": (100, 100, 255)},
    "pants": {"name": "è…¿ç”²", "icon": "è…¿", "color": (255, 100, 255)},
    "accessory": {"name": "é¥°å“", "icon": "é¥°", "color": (100, 255, 255)},
}
RARITY_COLORS = {
    "common": (156, 163, 175), "uncommon": (16, 185, 129), "rare": (59, 130, 246),
    "epic": (139, 92, 246), "legendary": (245, 158, 11),
}

class BackpackScreen(BaseState):
    def __init__(self, game, player_override=None): # <-- æ ¸å¿ƒä¿®æ”¹1
        super().__init__(game)
        self.player = player_override or self.game.player # <-- æ ¸å¿ƒä¿®æ”¹2

        # --- åç»­æ‰€æœ‰ç”¨åˆ° self.game.player çš„åœ°æ–¹ï¼Œéƒ½æ”¹æˆ self.player ---
        self.is_overlay = True
        # ... (å…¶ä»–åˆå§‹åŒ–ä»£ç ä¸å˜) ...
        self.dragging_item, self.dragging_from, self.dragging_from_info = None, None, {}
        self.selected_category, self.search_text, self.search_active = "all", "", False
        self.hover_slot = None
        self.tooltip_manager = TooltipManager(self.game.fonts['small'])
        self._setup_layout()
        self._setup_animations()

    # ... (é™¤äº†ä¸‹é¢è¢«æ›¿æ¢çš„æ–¹æ³•ï¼Œå…¶ä»–æ‰€æœ‰æ–¹æ³•éƒ½ä¸å˜) ...
    def _get_font(self, font_name, default_size=20):
        try:
            if hasattr(self.game, 'fonts') and font_name in self.game.fonts: return self.game.fonts[font_name]
        except: pass
        return pygame.font.Font(None, default_size)

    def _setup_layout(self):
        margin, header_height, sidebar_width, char_panel_width = 40, 80, 200, 280
        self.container_rect = pygame.Rect(margin, margin, SCREEN_WIDTH - 2*margin, SCREEN_HEIGHT - 2*margin)
        self.header_rect = pygame.Rect(self.container_rect.x, self.container_rect.y, self.container_rect.width, header_height)
        content_y, content_height = self.header_rect.bottom + 10, self.container_rect.height - header_height - 10
        self.sidebar_rect = pygame.Rect(self.container_rect.x, content_y, sidebar_width, content_height)
        self.character_panel_rect = pygame.Rect(self.container_rect.right - char_panel_width, content_y, char_panel_width, content_height)
        self.inventory_rect = pygame.Rect(self.sidebar_rect.right + 10, content_y, self.character_panel_rect.left - self.sidebar_rect.right - 20, content_height)
        self.search_rect = pygame.Rect(self.inventory_rect.x + 10, self.inventory_rect.y + 10, self.inventory_rect.width - 20, 35)
        self.grid_rect = pygame.Rect(self.inventory_rect.x + 10, self.search_rect.bottom + 15, self.inventory_rect.width - 20, self.inventory_rect.height - 60)
        self._generate_ui_elements()

    def _setup_animations(self): self.hover_animation, self.glow_animation = {}, 0

    def _generate_ui_elements(self):
        self.category_buttons = []
        categories = [("all", "å…¨éƒ¨"), ("weapon", "æ­¦å™¨"), ("armor", "é˜²å…·"), ("consumable", "æ¶ˆè€—"), ("material", "ææ–™"), ("misc", "å…¶ä»–")]
        btn_h, btn_s, start_y = 45, 8, self.sidebar_rect.y + 20
        for i, (cat_id, name) in enumerate(categories):
            rect = pygame.Rect(self.sidebar_rect.x + 15, start_y + i * (btn_h + btn_s), self.sidebar_rect.width - 30, btn_h)
            self.category_buttons.append({"id": cat_id, "name": name, "rect": rect, "hover": False})
        self.backpack_slots = []
        cols, rows, slot_size = 10, 6, min((self.grid_rect.width - 20) // 10 - 5, (self.grid_rect.height - 20) // 6 - 5)
        for row in range(rows):
            for col in range(cols):
                x, y = self.grid_rect.x + 10 + col * (slot_size + 5), self.grid_rect.y + 10 + row * (slot_size + 5)
                self.backpack_slots.append(pygame.Rect(x, y, slot_size, slot_size))
        self._generate_equipment_slots()
        close_btn_rect = pygame.Rect(self.container_rect.right - 45, self.container_rect.top + 10, 35, 35)
        self.close_button = Button(close_btn_rect, "X", self.game.fonts['normal'])

    def _generate_equipment_slots(self):
        self.equipment_slots = {}
        player = self.player # <-- ä¿®æ”¹ç‚¹
        model_rect = pygame.Rect(self.character_panel_rect.x + 15, self.character_panel_rect.y + 15, self.character_panel_rect.width - 30, 300)
        slot_size, spacing = 50, 10
        center_x = model_rect.centerx

        self.equipment_slots["helmet"] = [pygame.Rect(center_x - slot_size/2, model_rect.top + 10, slot_size, slot_size)]
        armor_rect = pygame.Rect(center_x - slot_size/2, model_rect.top + slot_size + spacing + 10, slot_size, slot_size)
        self.equipment_slots["armor"] = [armor_rect]
        self.equipment_slots["pants"] = [pygame.Rect(center_x - slot_size/2, armor_rect.bottom + spacing, slot_size, slot_size)]

        weapon_slots = []
        num_weapon_slots = player.SLOT_CAPACITY.get("weapon", 1)
        for i in range(num_weapon_slots):
            x = armor_rect.left - slot_size - spacing
            y = armor_rect.centery - slot_size/2 + i * (slot_size + spacing)
            weapon_slots.append(pygame.Rect(x, y, slot_size, slot_size))
        self.equipment_slots["weapon"] = weapon_slots

        if player.SLOT_CAPACITY.get("offhand", 0) > 0:
            self.equipment_slots["offhand"] = [pygame.Rect(armor_rect.right + spacing, armor_rect.centery - slot_size/2, slot_size, slot_size)]
        else:
            self.equipment_slots["offhand"] = []

        accessory_slots = []
        num_accessory_slots = player.SLOT_CAPACITY.get("accessory", 0)
        total_accessory_width = num_accessory_slots * slot_size + (num_accessory_slots - 1) * 5
        start_x = model_rect.centerx - total_accessory_width / 2
        accessory_y = model_rect.bottom - slot_size - 10
        for i in range(num_accessory_slots):
            x = start_x + i * (slot_size + 5)
            accessory_slots.append(pygame.Rect(x, accessory_y, slot_size, slot_size))
        self.equipment_slots["accessory"] = accessory_slots

    def handle_event(self, event):
        if self.close_button.handle_event(event): self.game.state_stack.pop(); return
        if event.type == pygame.KEYDOWN:
            if event.key in [pygame.K_b, pygame.K_ESCAPE]:
                if self.dragging_item: self._return_dragging_item()
                self.game.state_stack.pop(); return
            elif event.key == pygame.K_BACKSPACE and self.search_active: self.search_text = self.search_text[:-1]
            elif self.search_active and event.unicode.isprintable(): self.search_text += event.unicode
        elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            if not self.close_button.rect.collidepoint(event.pos): self._handle_mouse_down(event.pos)
        elif event.type == pygame.MOUSEBUTTONUP and event.button == 1: self._handle_mouse_up(event.pos)
        elif event.type == pygame.MOUSEMOTION: self._handle_mouse_motion(event.pos)

    def _handle_mouse_down(self, pos):
        player = self.player # <-- ä¿®æ”¹ç‚¹
        if self.search_rect.collidepoint(pos): self.search_active = True; return
        else: self.search_active = False
        for button in self.category_buttons:
            if button["rect"].collidepoint(pos): self.selected_category = button["id"]; return
        if self.dragging_item: return
        for slot_type, slot_rects in self.equipment_slots.items():
            for i, rect in enumerate(slot_rects):
                if rect.collidepoint(pos) and player.slots[slot_type][i] is not None:
                    item_to_drag = player.slots[slot_type][i]
                    self.dragging_item = player.unequip(item_to_drag)
                    self.dragging_from = 'equipment'
                    self.dragging_from_info = {'slot_type': slot_type, 'index': i}
                    return
        filtered_items = self._get_filtered_items()
        for i, rect in enumerate(self.backpack_slots):
            if rect.collidepoint(pos) and i < len(filtered_items):
                original_item = filtered_items[i]
                original_index_in_backpack = player.backpack.index(original_item)
                self.dragging_item = player.backpack.pop(original_index_in_backpack)
                self.dragging_from = 'backpack'
                self.dragging_from_info = {'index': original_index_in_backpack}
                return

    def _handle_mouse_up(self, pos):
        if not self.dragging_item: return
        player = self.player # <-- ä¿®æ”¹ç‚¹
        source_type, source_info = self.dragging_from, self.dragging_from_info
        for slot_type, slot_rects in self.equipment_slots.items():
            for i, rect in enumerate(slot_rects):
                if rect.collidepoint(pos) and self.dragging_item.slot == slot_type:
                    replaced_item = player.equip(self.dragging_item, specific_index=i)
                    if replaced_item:
                        if source_type == 'backpack':
                            player.backpack.append(replaced_item)
                        elif source_type == 'equipment':
                            player.equip(replaced_item, specific_index=source_info['index'])
                    self.dragging_item = None
                    return
        if self.grid_rect.collidepoint(pos):
            player.backpack.append(self.dragging_item)
            self.dragging_item = None
            return
        self._return_dragging_item()
        self.dragging_item = None

    def _handle_mouse_motion(self, pos):
        for button in self.category_buttons: button["hover"] = button["rect"].collidepoint(pos)
        self.hover_slot = None
        for slot_type, slot_rects in self.equipment_slots.items():
            for i, rect in enumerate(slot_rects):
                if rect.collidepoint(pos): self.hover_slot = (slot_type, i); break

    def _get_filtered_items(self):
        items = self.player.backpack.copy() # <-- ä¿®æ”¹ç‚¹
        if self.selected_category != "all":
            items = [item for item in items if hasattr(item, 'type') and item.type == self.selected_category]
        if self.search_text:
            items = [item for item in items if self.search_text.lower() in get_display_name(item).lower()]
        return items

    def _return_dragging_item(self):
        if not self.dragging_item: return
        player = self.player # <-- ä¿®æ”¹ç‚¹
        if self.dragging_from == 'backpack': 
            player.backpack.insert(self.dragging_from_info.get('index', 0), self.dragging_item)
        elif self.dragging_from == 'equipment': 
            player.equip(self.dragging_item)

    def _update_hovers(self):
        if self.dragging_item: self.tooltip_manager.update(None); return
        mouse_pos = pygame.mouse.get_pos()
        player = self.player # <-- ä¿®æ”¹ç‚¹
        hovered_item = None
        all_elements = []
        for slot_type, slot_rects in self.equipment_slots.items():
            equipped_items = player.slots.get(slot_type, [])
            for i, rect in enumerate(slot_rects):
                if equipped_items[i] is not None: all_elements.append((rect, equipped_items[i]))
        filtered_items = self._get_filtered_items()
        for i, rect in enumerate(self.backpack_slots):
            if i < len(filtered_items): all_elements.append((rect, filtered_items[i]))
        for rect, obj in all_elements:
            if rect.collidepoint(mouse_pos): hovered_item = obj; break
        self.tooltip_manager.update(hovered_item)

    def update(self, dt=0):
        current_time = pygame.time.get_ticks()
        if not hasattr(self, '_last_time'): self._last_time = current_time
        dt_ms = current_time - self._last_time; self._last_time = current_time; dt_sec = dt_ms / 1000.0
        self.glow_animation = (self.glow_animation + dt_sec * 3) % (2 * math.pi)
        self.animation_offset = math.sin(self.glow_animation) * 2; self._update_hovers()

    def draw(self, surface):
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA); overlay.fill((0, 0, 0, 160)); surface.blit(overlay, (0, 0))
        self._draw_modern_panel(surface, self.container_rect, (25, 30, 50, 240))
        self._draw_header(surface); self._draw_sidebar(surface); self._draw_inventory_area(surface)
        self._draw_character_panel(surface); self._draw_dragging_item(surface)
        self.close_button.draw(surface); self.tooltip_manager.draw(surface)
        if hasattr(self, 'update'): self.update()

    def _draw_modern_panel(self, surface, rect, color, border_color=None):
        pygame.draw.rect(surface, color, rect, border_radius=12)
        if border_color is None: border_color = (70, 80, 100, 180)
        pygame.draw.rect(surface, border_color, rect, width=2, border_radius=12)
        glow_rect = rect.inflate(-4, -4); pygame.draw.rect(surface, (255, 255, 255, 10), glow_rect, width=1, border_radius=10)

    def _draw_header(self, surface):
        header_bg = self.header_rect.inflate(-10, -10); self._draw_modern_panel(surface, header_bg, (35, 40, 65, 200))
        title_font = self._get_font('large', 32); title_text = title_font.render("èƒŒåŒ…ç³»ç»Ÿ", True, (255, 215, 0))
        title_rect = title_text.get_rect(x=header_bg.x + 20, centery=header_bg.centery); surface.blit(title_text, title_rect)

    def _draw_sidebar(self, surface):
        sidebar_bg = self.sidebar_rect.inflate(-5, -5); self._draw_modern_panel(surface, sidebar_bg, (30, 35, 55, 200))
        for button in self.category_buttons:
            is_active, is_hover = button["id"] == self.selected_category, button["hover"]
            if is_active: bg_color, border_color, text_color = (255, 215, 0, 100), (255, 215, 0), (255, 255, 255)
            elif is_hover: bg_color, border_color, text_color = (70, 80, 100, 120), (100, 110, 130), (240, 240, 240)
            else: bg_color, border_color, text_color = (40, 50, 70, 80), (60, 70, 90), (180, 180, 180)
            button_rect = button["rect"]; 
            if is_hover: button_rect = button_rect.move(2 + self.animation_offset, 0)
            pygame.draw.rect(surface, bg_color, button_rect, border_radius=8); pygame.draw.rect(surface, border_color, button_rect, width=2, border_radius=8)
            font = self._get_font('small', 18); text = f"{button['name']}"; text_surface = font.render(text, True, text_color); text_rect = text_surface.get_rect(center=button_rect.center); surface.blit(text_surface, text_rect)

    def _draw_inventory_area(self, surface):
        inventory_bg = self.inventory_rect.inflate(-5, -5); self._draw_modern_panel(surface, inventory_bg, (30, 35, 55, 200))
        search_bg_color, border_color = ((50, 60, 80, 150), (255, 215, 0)) if self.search_active else ((40, 50, 70, 120), (70, 80, 100))
        pygame.draw.rect(surface, search_bg_color, self.search_rect, border_radius=6); pygame.draw.rect(surface, border_color, self.search_rect, width=2, border_radius=6)
        search_font = self._get_font('small', 18); display_text = self.search_text or "æœç´¢ç‰©å“..."; text_color = (255, 255, 255) if self.search_text else (150, 150, 150)
        search_surface = search_font.render(display_text, True, text_color); search_text_rect = search_surface.get_rect(x=self.search_rect.x + 10, centery=self.search_rect.centery); surface.blit(search_surface, search_text_rect)
        if self.search_active and int(self.glow_animation * 2) % 2: pygame.draw.line(surface, (255, 255, 255), (search_text_rect.right + 2, self.search_rect.y + 8), (search_text_rect.right + 2, self.search_rect.bottom - 8), 2)
        self._draw_backpack_grid(surface)

    def _draw_backpack_grid(self, surface):
        filtered_items = self._get_filtered_items()
        for i, slot_rect in enumerate(self.backpack_slots):
            rarity_color = RARITY_COLORS['common']; bg_color, border_color = (40, 50, 70, 60), (60, 70, 90, 120)
            if i < len(filtered_items): item = filtered_items[i]; rarity = getattr(item, 'rarity', 'common'); rarity_color = RARITY_COLORS.get(rarity, RARITY_COLORS['common']); bg_color, border_color = (*rarity_color, 30), (*rarity_color, 180)
            pygame.draw.rect(surface, bg_color, slot_rect, border_radius=6); pygame.draw.rect(surface, border_color, slot_rect, width=2, border_radius=6)
            if i < len(filtered_items):
                item = filtered_items[i]
                if item != self.dragging_item:
                    item_name = get_display_name(item); font = self._get_font('small', 12) 
                    item_surface = font.render(item_name, True, (255, 255, 255)); 
                    if item_surface.get_width() > slot_rect.width - 8: 
                        item_name = item_name[:5] + ".."
                        item_surface = font.render(item_name, True, (255, 255, 255))
                    item_rect = item_surface.get_rect(center=slot_rect.center); surface.blit(item_surface, item_rect)
                    pygame.draw.rect(surface, rarity_color, (slot_rect.x, slot_rect.y, slot_rect.width, 3), border_top_left_radius=2, border_top_right_radius=2)

    def _draw_character_panel(self, surface):
        panel_bg = self.character_panel_rect.inflate(-5, -5); self._draw_modern_panel(surface, panel_bg, (30, 35, 55, 200))
        model_area = pygame.Rect(panel_bg.x + 15, panel_bg.y + 15, panel_bg.width - 30, 300)
        pygame.draw.rect(surface, (20, 25, 40, 150), model_area, border_radius=10)
        self._draw_equipment_slots(surface); self._draw_character_stats(surface, panel_bg)

    def _draw_equipment_slots(self, surface):
        player = self.player # <-- ä¿®æ”¹ç‚¹
        for slot_type, slot_rects in self.equipment_slots.items():
            slot_config = SLOT_CONFIG.get(slot_type, {"name": slot_type, "icon": "?", "color": (100, 100, 100)})
            for i, slot_rect in enumerate(slot_rects):
                is_hover = self.hover_slot == (slot_type, i)
                bg_color, border_color = ((*slot_config["color"], 50), slot_config["color"]) if is_hover else ((40, 50, 70, 100), (70, 80, 100))
                pygame.draw.rect(surface, bg_color, slot_rect, border_radius=8)
                pygame.draw.rect(surface, border_color, slot_rect, width=2, border_radius=8)
                item_in_slot = player.slots[slot_type][i]
                if item_in_slot is not None:
                    if item_in_slot != self.dragging_item:
                        item_name = get_display_name(item_in_slot)
                        font = self._get_font('small', 13)
                        if font.size(item_name)[0] > slot_rect.width - 6: 
                            item_name = item_name[:3] + ".."
                        text = font.render(item_name, True, (255, 255, 255))
                        text_rect = text.get_rect(center=slot_rect.center)
                        surface.blit(text, text_rect)
                else:
                    font = self._get_font('small', 14)
                    text_surf = font.render(slot_config["name"], True, (80, 90, 110))
                    text_rect = text_surf.get_rect(center=slot_rect.center)
                    surface.blit(text_surf, text_rect)

    def _draw_character_stats(self, surface, panel_bg):
        stats_area = pygame.Rect(panel_bg.x + 15, panel_bg.bottom - 185, panel_bg.width - 30, 170)
        pygame.draw.rect(surface, (20, 25, 40, 150), stats_area, border_radius=10)
        player = self.player # <-- ä¿®æ”¹ç‚¹
        stats_data = [("æœ€å¤§ç”Ÿå‘½", f"{int(getattr(player, 'max_hp', 0))}"), ("æ”»å‡»", f"{int(getattr(player, 'attack', 0))}"), ("é˜²å¾¡", f"{int(getattr(player, 'defense', 0))}"), ("æ”»å‡»é€Ÿåº¦", f"{getattr(player, 'attack_speed', 0):.2f}"), ("æš´å‡»ç‡", f"{getattr(player, 'crit_chance', 0) * 100:.1f}%"), ("æš´å‡»ä¼¤å®³", f"{getattr(player, 'crit_multiplier', 0) * 100:.1f}%")]
        stats_font = self.game.fonts['small']; line_height = 26; y_offset = stats_area.y + 12
        for i, (name, value) in enumerate(stats_data):
            y_pos = y_offset + i * line_height
            name_surface = stats_font.render(f"{name}:", True, (180, 180, 180)); name_rect = name_surface.get_rect(x=stats_area.x + 15, centery=y_pos); surface.blit(name_surface, name_rect)
            value_surface = stats_font.render(str(value), True, (255, 215, 0)); value_rect = value_surface.get_rect(right=stats_area.right - 15, centery=y_pos); surface.blit(value_surface, value_rect)

    def _draw_dragging_item(self, surface):
        if self.dragging_item:
            mouse_pos = pygame.mouse.get_pos(); item_name = get_display_name(self.dragging_item)
            font = self._get_font('normal', 20); text_surface = font.render(item_name, True, (255, 255, 255)); text_rect = text_surface.get_rect(center=mouse_pos)
            bg_rect = text_rect.inflate(20, 12); pygame.draw.rect(surface, (40, 50, 80, 220), bg_rect, border_radius=8); pygame.draw.rect(surface, (255, 215, 0), bg_rect, width=2, border_radius=8); surface.blit(text_surface, text_rect)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\base.py
================================================================================

# states/base.py
class BaseState:
    def __init__(self, game):
        self.game = game

    def handle_event(self, event):
        """å¤„ç†è¯¥çŠ¶æ€ä¸‹çš„å•ä¸ªäº‹ä»¶"""
        pass

    def update(self):
        """æ›´æ–°è¯¥çŠ¶æ€ä¸‹çš„é€»è¾‘ï¼ˆéäº‹ä»¶é©±åŠ¨ï¼‰"""
        pass

    def draw(self, surface):
        """ç»˜åˆ¶è¯¥çŠ¶æ€çš„ç”»é¢"""
        pass


================================================================================
### æ–‡ä»¶è·¯å¾„: states\choice_screen.py
================================================================================

# æ–‡ä»¶: states/choice_screen.py (ç°ä»£åŒ–é‡å†™ç‰ˆæœ¬)

import pygame
import math
import inspect
from .base import BaseState
from ui import Button, draw_text
from settings import *

class ChoiceScreen(BaseState):
    def __init__(self, game, item_choices, origin_room):
        super().__init__(game)
        self.is_overlay = True
        self.item_choices = item_choices
        self.origin_room = origin_room
        self.choice_buttons = []
        self.choice_made = False
        
        # åŠ¨ç”»ç³»ç»Ÿ
        self.hover_animations = {}
        self.glow_animation = 0
        self.entrance_animation = 0
        self.card_offsets = []
        
        self._setup_ui()

    def _get_font(self, font_name, default_size=20):
        """å®‰å…¨è·å–å­—ä½“"""
        try:
            if hasattr(self.game, 'fonts') and font_name in self.game.fonts:
                return self.game.fonts[font_name]
        except:
            pass
        return pygame.font.Font(None, default_size)

    def _setup_ui(self):
        num_choices = len(self.item_choices)
        
        # åŠ¨æ€è°ƒæ•´é¢æ¿å¤§å°
        base_card_width, base_card_height = 320, 450
        spacing = 30
        total_width = base_card_width * num_choices + spacing * (num_choices - 1) + 100
        
        # å¦‚æœå¤ªå®½ï¼Œè°ƒæ•´å¡ç‰‡å¤§å°
        if total_width > SCREEN_WIDTH - 100:
            available_width = SCREEN_WIDTH - 200
            card_width = (available_width - spacing * (num_choices - 1)) // num_choices
            card_width = max(280, card_width)  # æœ€å°å®½åº¦
        else:
            card_width = base_card_width
        
        card_height = base_card_height
        panel_width = min(total_width, SCREEN_WIDTH - 100)
        panel_height = card_height + 180
        
        self.panel_rect = pygame.Rect(0, 0, panel_width, panel_height)
        self.panel_rect.center = (SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2)
        
        # åˆ›å»ºå¡ç‰‡æŒ‰é’®
        actual_spacing = 30 if num_choices <= 3 else 20
        total_cards_width = card_width * num_choices + actual_spacing * (num_choices - 1)
        start_x = self.panel_rect.centerx - total_cards_width // 2
        
        self.choice_buttons = []
        self.card_offsets = []
        
        for i, item in enumerate(self.item_choices):
            card_x = start_x + i * (card_width + actual_spacing)
            card_rect = pygame.Rect(card_x, self.panel_rect.y + 90, card_width, card_height)
            button = Button(card_rect, "", self._get_font('normal'))
            self.choice_buttons.append((button, item))
            self.card_offsets.append(0)  # åˆå§‹åŒ–åŠ¨ç”»åç§»
            self.hover_animations[i] = 0

    def handle_event(self, event):
        if self.choice_made or self.entrance_animation < 1.0:
            return

        for i, (button, item) in enumerate(self.choice_buttons):
            if button.handle_event(event):
                self.choice_made = True 
                
                # æ·»åŠ é€‰æ‹©åŠ¨ç”»æ•ˆæœ
                self._animate_selection(i)
                
                # å¤„ç†é€‰æ‹©é€»è¾‘
                feedback = self.game.player.pickup_item(item)
                print(f"ç©å®¶é€‰æ‹©äº†: {getattr(item, 'display_name', item.__class__.__name__)}")
                
                self.origin_room.is_cleared = True
                
                # æ›´æ–°åœ°ç‰¢ç•Œé¢
                from .dungeon_screen import DungeonScreen
                if len(self.game.state_stack) > 1:
                    prev_state = self.game.state_stack[-2]
                    if isinstance(prev_state, DungeonScreen):
                        prev_state.door_rects = prev_state._generate_doors()
                
                # é€€å‡ºå½“å‰ç•Œé¢
                self.game.state_stack.pop() 

                # æ˜¾ç¤ºé€šçŸ¥
                if feedback:
                    from .notification_screen import NotificationScreen
                    self.game.state_stack.append(NotificationScreen(self.game, feedback))
                
                return

    def _animate_selection(self, selected_index):
        """é€‰æ‹©åŠ¨ç”»æ•ˆæœ"""
        for i in range(len(self.choice_buttons)):
            if i != selected_index:
                self.hover_animations[i] = -1  # æ ‡è®°ä¸ºæœªé€‰ä¸­

    def update(self, dt=0):
        """æ›´æ–°åŠ¨ç”»"""
        current_time = pygame.time.get_ticks()
        if not hasattr(self, '_last_time'): 
            self._last_time = current_time
            
        dt_ms = current_time - self._last_time
        self._last_time = current_time
        dt_sec = dt_ms / 1000.0
        
        # å…¥åœºåŠ¨ç”»
        self.entrance_animation = min(1.0, self.entrance_animation + dt_sec * 3)
        
        # å‘å…‰åŠ¨ç”»
        self.glow_animation = (self.glow_animation + dt_sec * 2) % (2 * math.pi)
        
        # æ‚¬åœæ£€æµ‹å’ŒåŠ¨ç”»
        mouse_pos = pygame.mouse.get_pos()
        for i, (button, item) in enumerate(self.choice_buttons):
            if button.rect.collidepoint(mouse_pos) and not self.choice_made:
                self.hover_animations[i] = min(1.0, self.hover_animations[i] + dt_sec * 4)
                # è½»å¾®æµ®åŠ¨æ•ˆæœ
                self.card_offsets[i] = math.sin(current_time * 0.003 + i) * 3
            else:
                if self.hover_animations[i] >= 0:  # åªæœ‰éé€‰æ‹©çŠ¶æ€æ‰è¡°å‡
                    self.hover_animations[i] = max(0, self.hover_animations[i] - dt_sec * 3)
                    self.card_offsets[i] = 0

    def draw(self, surface):
        # åŠé€æ˜é®ç½©
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, int(200 * self.entrance_animation)))
        surface.blit(overlay, (0, 0))
        
        # ä¸»é¢æ¿ï¼ˆå…¥åœºåŠ¨ç”»ï¼‰
        panel_rect = self.panel_rect.copy()
        if self.entrance_animation < 1.0:
            scale = 0.8 + 0.2 * self.entrance_animation
            panel_rect = pygame.Rect(0, 0, 
                                   int(self.panel_rect.width * scale),
                                   int(self.panel_rect.height * scale))
            panel_rect.center = (SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2)
        
        self._draw_modern_panel(surface, panel_rect, (25, 30, 50, 240))
        
        # ç»˜åˆ¶æ ‡é¢˜
        self._draw_header(surface, panel_rect)
        
        # ç»˜åˆ¶é€‰æ‹©å¡ç‰‡
        self._draw_choice_cards(surface)

    def _draw_modern_panel(self, surface, rect, color, border_color=None):
        """ç»˜åˆ¶ç°ä»£åŒ–é¢æ¿"""
        pygame.draw.rect(surface, color, rect, border_radius=15)
        if border_color is None: 
            border_color = (70, 80, 100, 200)
        pygame.draw.rect(surface, border_color, rect, width=3, border_radius=15)
        
        # å†…å‘å…‰æ•ˆæœ
        glow_rect = rect.inflate(-6, -6)
        pygame.draw.rect(surface, (255, 255, 255, 20), glow_rect, width=2, border_radius=12)

    def _draw_header(self, surface, panel_rect):
        """ç»˜åˆ¶æ ‡é¢˜åŒºåŸŸ"""
        title_rect = pygame.Rect(panel_rect.x + 30, panel_rect.y + 20, 
                                panel_rect.width - 60, 60)
        
        # æ ‡é¢˜èƒŒæ™¯
        title_bg = title_rect.inflate(20, 10)
        self._draw_modern_panel(surface, title_bg, (35, 40, 65, 180), (100, 120, 150))
        
        # ä¸»æ ‡é¢˜
        title_font = self._get_font('large', 28)
        title_text = "é€‰æ‹©å¥–åŠ±"
        title_surface = title_font.render(title_text, True, (255, 215, 0))
        title_pos = title_surface.get_rect(center=title_bg.center)
        surface.blit(title_surface, title_pos)
        
        # å‰¯æ ‡é¢˜
        subtitle_font = self._get_font('small', 16)
        subtitle_text = "ä»ä»¥ä¸‹é€‰é¡¹ä¸­é€‰æ‹©ä¸€ä¸ªå¥–åŠ±"
        subtitle_surface = subtitle_font.render(subtitle_text, True, (180, 180, 180))
        subtitle_pos = subtitle_surface.get_rect(centerx=title_bg.centerx, 
                                                top=title_pos.bottom + 5)
        surface.blit(subtitle_surface, subtitle_pos)

    def _draw_choice_cards(self, surface):
        """ç»˜åˆ¶é€‰æ‹©å¡ç‰‡"""
        for i, (button, item) in enumerate(self.choice_buttons):
            # è®¡ç®—åŠ¨ç”»åç§»
            hover_alpha = max(0, self.hover_animations[i])
            entrance_offset = (1 - self.entrance_animation) * 100
            card_rect = button.rect.copy()
            card_rect.y += entrance_offset + self.card_offsets[i]
            
            # ç»˜åˆ¶å¡ç‰‡
            self._draw_item_card(surface, card_rect, item, hover_alpha, i)

    def _draw_item_card(self, surface, rect, item, hover_alpha, card_index):
        """ç»˜åˆ¶å•ä¸ªç‰©å“å¡ç‰‡"""
        # è·å–ç‰©å“ä¿¡æ¯
        name = getattr(item, 'display_name', item.__class__.__name__)
        rarity = getattr(item, 'rarity', 'common')
        rarity_color = RARITY_COLORS.get(rarity, RARITY_COLORS['common'])
        
        # å¡ç‰‡èƒŒæ™¯è‰²ï¼ˆæ ¹æ®æ‚¬åœçŠ¶æ€è°ƒæ•´ï¼‰
        if self.hover_animations[card_index] == -1:  # æœªé€‰ä¸­çŠ¶æ€
            bg_alpha = 100
            border_alpha = 120
            scale = 0.95
        else:
            bg_alpha = int(120 + hover_alpha * 40)
            border_alpha = int(160 + hover_alpha * 95)
            scale = 1.0 + hover_alpha * 0.05
        
        # ç¼©æ”¾å¡ç‰‡
        if scale != 1.0:
            scaled_size = (int(rect.width * scale), int(rect.height * scale))
            scaled_rect = pygame.Rect(0, 0, *scaled_size)
            scaled_rect.center = rect.center
            rect = scaled_rect
        
        # å¡ç‰‡ä¸»ä½“
        card_bg_color = (*rarity_color, bg_alpha)
        border_color = (*rarity_color, border_alpha)
        
        pygame.draw.rect(surface, card_bg_color, rect, border_radius=12)
        pygame.draw.rect(surface, border_color, rect, width=3, border_radius=12)
        
        # ç¨€æœ‰åº¦è£…é¥°æ¡
        decoration_rect = pygame.Rect(rect.x, rect.y, rect.width, 8)
        pygame.draw.rect(surface, rarity_color, decoration_rect, 
                        border_top_left_radius=12, border_top_right_radius=12)
        
        # å‘å…‰æ•ˆæœï¼ˆæ‚¬åœæ—¶ï¼‰
        if hover_alpha > 0:
            glow_intensity = int((math.sin(self.glow_animation) + 1) * hover_alpha * 30 + 10)
            glow_surface = pygame.Surface(rect.size, pygame.SRCALPHA)
            pygame.draw.rect(glow_surface, (*rarity_color, glow_intensity), 
                           (0, 0, rect.width, rect.height), border_radius=12)
            surface.blit(glow_surface, rect.topleft)
        
        # ç‰©å“åç§°
        name_font = self._get_font('normal', 20)
        name_surface = name_font.render(name, True, (255, 255, 255))
        name_rect = name_surface.get_rect(centerx=rect.centerx, top=rect.top + 25)
        
        # åç§°èƒŒæ™¯
        name_bg_rect = name_rect.inflate(20, 8)
        pygame.draw.rect(surface, (0, 0, 0, 120), name_bg_rect, border_radius=6)
        surface.blit(name_surface, name_rect)
        
        # ç¨€æœ‰åº¦æ ‡ç­¾
        rarity_font = self._get_font('small', 14)
        rarity_text = rarity.upper()
        rarity_surface = rarity_font.render(rarity_text, True, rarity_color)
        rarity_rect = rarity_surface.get_rect(centerx=rect.centerx, 
                                             top=name_rect.bottom + 10)
        surface.blit(rarity_surface, rarity_rect)
        
        # åˆ†å‰²çº¿
        line_y = rarity_rect.bottom + 15
        pygame.draw.line(surface, (100, 100, 100), 
                        (rect.x + 20, line_y), (rect.right - 20, line_y), 2)
        
        # ç‰©å“æè¿°
        description = inspect.getdoc(item) or "è¿™æ˜¯ä¸€ä¸ªç¥ç§˜çš„ç‰©å“ã€‚"
        desc_rect = pygame.Rect(rect.x + 15, line_y + 15, 
                               rect.width - 30, rect.height - (line_y - rect.y) - 30)
        self._draw_wrapped_text(surface, description, self._get_font('small', 14), 
                               (200, 200, 200), desc_rect)
        
        # é€‰æ‹©æç¤ºï¼ˆæ‚¬åœæ—¶ï¼‰
        if hover_alpha > 0.5:
            hint_font = self._get_font('small', 16)
            hint_text = "ç‚¹å‡»é€‰æ‹©"
            hint_surface = hint_font.render(hint_text, True, (255, 255, 100))
            hint_rect = hint_surface.get_rect(centerx=rect.centerx, 
                                             bottom=rect.bottom - 15)
            
            # æç¤ºèƒŒæ™¯
            hint_bg = hint_rect.inflate(16, 6)
            pygame.draw.rect(surface, (50, 50, 0, 150), hint_bg, border_radius=4)
            surface.blit(hint_surface, hint_rect)

    def _draw_wrapped_text(self, surface, text, font, color, rect):
        """ç»˜åˆ¶è‡ªåŠ¨æ¢è¡Œæ–‡æœ¬"""
        words = text.split(' ')
        lines = []
        current_line = ""
        
        for word in words:
            test_line = current_line + (" " if current_line else "") + word
            if font.size(test_line)[0] <= rect.width:
                current_line = test_line
            else:
                if current_line:
                    lines.append(current_line)
                current_line = word
        
        if current_line:
            lines.append(current_line)
        
        # ç»˜åˆ¶è¡Œ
        line_height = font.get_height() + 3
        y_offset = rect.y
        
        for line in lines:
            if y_offset + line_height > rect.bottom:
                break
            line_surface = font.render(line, True, color)
            surface.blit(line_surface, (rect.x, y_offset))
            y_offset += line_height


================================================================================
### æ–‡ä»¶è·¯å¾„: states\combat.py
================================================================================

# states/combat.py (å·²æ›´æ–°)
import pygame
import time
import random # å¯¼å…¥ random
from .base import BaseState
from ui import ScrollableTextRenderer, draw_character_panel, TooltipManager, Button, draw_panel, draw_text
from settings import *
from Character import Character
import Talents
from battle_logger import battle_logger

# æ–‡ä»¶: states/combat.py (æ›¿æ¢æ•´ä¸ªç±»)

class CombatScreen(BaseState):
    def __init__(self, game, enemy_id, origin_identifier=None):
        super().__init__(game)
        self.enemy_id = enemy_id
        self.origin_id = origin_identifier
        
        self.tooltip_manager = TooltipManager(self.game.fonts['small'])

        # è¿™ä¼šåˆ›å»º self.enemy
        self._initialize_combat()
        
        # ### æ ¸å¿ƒä¿®å¤ï¼šåœ¨è¿™é‡Œï¼Œæ­£å¼ä¸ºåŒæ–¹æŒ‡å®šå¯¹æ‰‹ï¼###
        self.game.player.current_opponent = self.enemy
        self.enemy.current_opponent = self.game.player

        self.player_ui_elements, self.enemy_ui_elements = {}, {}
        self.is_paused = False
        pause_button_rect = pygame.Rect(SCREEN_WIDTH - 60, 10, 50, 50)
        self.pause_button = Button(pause_button_rect, "||", self.game.fonts['normal'])

        self.battle_ended = False
        self.end_timer = 0.0
        self.END_DELAY = 2.0
        
        self.log_renderer = ScrollableTextRenderer(
            BATTLE_LOG_RECT, 
            self.game.fonts['small'], 
            line_height=20,
            bg_color=(30, 30, 30, 180)
        )
        
        battle_logger.register_renderer(self.log_renderer)
        self.log_renderer.add_message(f"æˆ˜æ–—å¼€å§‹ï¼é­é‡äº† {self.enemy.name}ï¼")


    def _initialize_combat(self):
        enemy_preset = self.game.enemy_data[self.enemy_id]
        rolled_talents = []
        
        possible_talents = enemy_preset.get("possible_talents", [])
        for talent_info in possible_talents:
            if random.random() < talent_info["chance"]:
                talent_class_name = talent_info["talent_class_name"]
                if hasattr(Talents, talent_class_name):
                    talent_class = getattr(Talents, talent_class_name)
                    rolled_talents.append(talent_class())

        guaranteed_talents = enemy_preset.get("talents", [])
        for talent_class_name in guaranteed_talents:
            if hasattr(Talents, talent_class_name):
                talent_class = getattr(Talents, talent_class_name)
                rolled_talents.append(talent_class())
        
        self.enemy = Character(
            id=self.enemy_id, name=enemy_preset["name"], 
            talents=rolled_talents, **enemy_preset["stats"]
        )
        
        self.game.player.on_enter_combat()
        self.enemy.on_enter_combat()
        self.last_update_time = time.time()
        
        for talent in self.game.player.equipped_talents:
            if talent and hasattr(talent, 'on_battle_start'):
                talent.on_battle_start(self.game.player, self.enemy)
        for talent in self.enemy.equipped_talents:
            if talent and hasattr(talent, 'on_battle_start'):
                talent.on_battle_start(self.enemy, self.game.player)

        for eq in self.game.player.all_equipment: eq.on_battle_start(self.game.player)
        for eq in self.enemy.all_equipment: eq.on_battle_start(self.enemy)

    def handle_event(self, event):
        if self.pause_button.handle_event(event) or (event.type == pygame.KEYDOWN and event.key == pygame.K_p):
            self.is_paused = not self.is_paused
            self.pause_button.text = "ç»§ç»­" if self.is_paused else "||"
            if not self.is_paused: self.last_update_time = time.time()
            return

        if self.is_paused: return
        self.log_renderer.handle_event(event)

        from .confirm_dialog import ConfirmDialog
        from .title import TitleScreen
        if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
            def on_confirm_action(): self.game.state_stack = [TitleScreen(self.game)]
            confirm_dialog = ConfirmDialog(self.game, "æ‰€æœ‰æˆ˜æ–—è¿›åº¦éƒ½å°†ä¸¢å¤±ï¼Œç¡®å®šè¦è¿”å›ä¸»èœå•å—ï¼Ÿ", on_confirm_action)
            self.game.state_stack.append(confirm_dialog)

    def _on_victory(self):
            # ### æ ¸å¿ƒä¿®å¤ï¼šæˆ˜æ–—èƒœåˆ©åï¼Œæ¸…é™¤å¯¹æ‰‹ä¿¡æ¯ ###
            self.game.player.current_opponent = None
            if hasattr(self, 'enemy'):
                self.enemy.current_opponent = None
            battle_logger.unregister_renderer()

            from .dungeon_screen import DungeonScreen
            from .loot import LootScreen
            # ... (åç»­çš„èƒœåˆ©é€»è¾‘ä¸å˜) ...
            next_story_stage_id = None
            if len(self.game.state_stack) > 1 and isinstance(self.game.state_stack[-2], DungeonScreen):
                dungeon_screen = self.game.state_stack[-2]
                if self.origin_id:
                    dungeon_screen.on_monster_defeated(self.origin_id)
            else:
                current_stage_data = self.game.story_data.get(self.game.current_stage, {})
                next_story_stage_id = current_stage_data.get("next_win")

            self.game.state_stack.pop()
            self.game.state_stack.append(LootScreen(self.game, self.enemy, next_story_stage=next_story_stage_id))


    def update(self):
        from .title import TitleScreen

        self._update_hovers()

        if self.is_paused:
            return
            
        now = time.time()
        dt = now - self.last_update_time
        self.last_update_time = now

        if self.battle_ended:
            self.end_timer += dt
            if self.end_timer >= self.END_DELAY:
                if self.enemy.hp <= 0:
                    self._on_victory()
                elif self.game.player.hp <= 0:
                    # ### æ ¸å¿ƒä¿®å¤ï¼šæˆ˜æ–—å¤±è´¥åï¼Œä¹Ÿè¦æ¸…é™¤å¯¹æ‰‹ä¿¡æ¯ ###
                    self.game.player.current_opponent = None
                    if hasattr(self, 'enemy'):
                        self.enemy.current_opponent = None
                    battle_logger.unregister_renderer()
                    self.game.state_stack = [TitleScreen(self.game)]
            return

        for msg in self.game.player.update(dt): self.log_renderer.add_message(msg)
        for msg in self.enemy.update(dt): self.log_renderer.add_message(msg)
        
        player_res = self.game.player.try_attack(self.enemy, dt)
        if player_res:
            log_parts, extra_logs = player_res
            self.log_renderer.add_message(log_parts)
            [self.log_renderer.add_message(f"  â”” {e}") for e in extra_logs]
            
        enemy_res = self.enemy.try_attack(self.game.player, dt)
        if enemy_res:
            log_parts, extra_logs = enemy_res
            self.log_renderer.add_message(log_parts)
            [self.log_renderer.add_message(f"  â”” {e}") for e in extra_logs]
        
        if self.enemy.hp <= 0 or self.game.player.hp <= 0:
            self.battle_ended = True


    def _update_hovers(self):
        mouse_pos = pygame.mouse.get_pos()
        hovered_object = None
        all_elements = self.player_ui_elements.get('talents', []) + self.player_ui_elements.get('buffs', []) + \
                       self.enemy_ui_elements.get('talents', []) + self.enemy_ui_elements.get('buffs', [])
        for rect, obj in all_elements:
            if rect.collidepoint(mouse_pos):
                hovered_object = obj
                break
        self.tooltip_manager.update(hovered_object)

    def draw(self, surface):
        surface.fill(BG_COLOR)
        
        self.player_ui_elements = draw_character_panel(surface, self.game.player, PLAYER_PANEL_RECT, self.game.fonts)
        self.enemy_ui_elements = draw_character_panel(surface, self.enemy, ENEMY_PANEL_RECT, self.game.fonts)
        
        self._draw_combat_actions(surface, self.game.player, PLAYER_ACTION_PANEL_RECT)
        
        # --- æ ¸å¿ƒä¿®å¤ï¼šä½¿ç”¨æ–°çš„ log_renderer å±æ€§æ¥ç»˜åˆ¶æ—¥å¿— ---
        self.log_renderer.draw(surface)
        
        self.pause_button.draw(surface)
        self.tooltip_manager.draw(surface)
        
    def _draw_combat_actions(self, surface, char, rect):
        """(å ä½ç¬¦) ç»˜åˆ¶è§’è‰²çš„æˆ˜æ–—è¡ŒåŠ¨é€‰é¡¹ï¼Œå¦‚æŠ€èƒ½ã€é“å…·"""
        draw_panel(surface, rect, "è¡ŒåŠ¨", self.game.fonts['normal'])
        text_rect = rect.inflate(-20, -80)
        draw_text(surface, "æŠ€èƒ½/é“å…·ç³»ç»Ÿ\nå³å°†æ¨å‡º!", self.game.fonts['small'], TEXT_COLOR, text_rect)
        


================================================================================
### æ–‡ä»¶è·¯å¾„: states\combat_victory.py
================================================================================

# states/combat_victory.py
import pygame
from .base import BaseState
# <-- å¯¼å…¥æ–°çš„UIå·¥å…·
from ui import draw_character_panel, draw_panel, Button
from settings import *

class CombatVictoryScreen(BaseState):
    def __init__(self, game, final_enemy):
        super().__init__(game)
        self.final_enemy = final_enemy
        # <-- æ–°å¢ï¼šåˆ›å»ºä¸€ä¸ªç»§ç»­æŒ‰é’®
        self.continue_button = Button(
            (SCREEN_WIDTH / 2 - 150, SCREEN_HEIGHT - 100, 300, 60),
            "è¿›å…¥ç»“ç®—",
            self.game.fonts['normal']
        )

    def handle_event(self, event):
        from states.loot import LootScreen
        # <-- ä½¿ç”¨æŒ‰é’®çš„ handle_event æ–¹æ³•
        if self.continue_button.handle_event(event) or \
           (event.type == pygame.KEYDOWN and event.key in [pygame.K_RETURN, pygame.K_SPACE]):
            self.game.state_stack.pop()
            self.game.state_stack.append(LootScreen(self.game))

    def draw(self, surface):
        surface.fill(BG_COLOR)
        # <-- ä¿æŒé£æ ¼ç»Ÿä¸€ï¼Œç»§ç»­ä½¿ç”¨è§’è‰²é¢æ¿æ˜¾ç¤ºæœ€ç»ˆçŠ¶æ€
        draw_character_panel(surface, self.game.player, PLAYER_PANEL_RECT, self.game.fonts)
        draw_character_panel(surface, self.final_enemy, ENEMY_PANEL_RECT, self.game.fonts)

        # <-- ä½¿ç”¨ä¸€ä¸ªé¢æ¿æ¥æ˜¾ç¤ºèƒœåˆ©ä¿¡æ¯ï¼Œæ›´æœ‰ä»ªå¼æ„Ÿ
        victory_panel_rect = pygame.Rect(SCREEN_WIDTH * 0.25, SCREEN_HEIGHT / 2 - 100, SCREEN_WIDTH * 0.5, 200)
        draw_panel(surface, victory_panel_rect, "æˆ˜æ–—èƒœåˆ©ï¼", self.game.fonts['large'])
        
        # <-- ç»˜åˆ¶æŒ‰é’®
        self.continue_button.draw(surface)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\confirm_dialog.py
================================================================================

# states/confirm_dialog.py
import pygame
from .base import BaseState
from ui import Button, draw_text, draw_panel
from settings import *

class ConfirmDialog(BaseState):
    def __init__(self, game, text, on_confirm):
        super().__init__(game)
        self.is_overlay = True
        self.text = text
        self.on_confirm = on_confirm # æ¥å—ä¸€ä¸ªâ€œç¡®è®¤â€åè¦æ‰§è¡Œçš„å‡½æ•°

        # å®šä¹‰UIå…ƒç´ 
        panel_w, panel_h = 600, 300
        self.panel_rect = pygame.Rect((SCREEN_WIDTH - panel_w) / 2, (SCREEN_HEIGHT - panel_h) / 2, panel_w, panel_h)
        
        btn_w, btn_h = 150, 60
        self.yes_button = Button((self.panel_rect.centerx - btn_w - 20, self.panel_rect.bottom - 100, btn_w, btn_h), "ç¡®è®¤", self.game.fonts['normal'])
        self.no_button = Button((self.panel_rect.centerx + 20, self.panel_rect.bottom - 100, btn_w, btn_h), "å–æ¶ˆ", self.game.fonts['normal'])

    def handle_event(self, event):
        if self.yes_button.handle_event(event):
            self.on_confirm() # æ‰§è¡Œç¡®è®¤æ“ä½œ
        
        if self.no_button.handle_event(event):
            self.game.state_stack.pop() # ç‚¹å‡»â€œå–æ¶ˆâ€ï¼Œåªå¼¹å‡ºè‡ªå·±

        if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
            self.game.state_stack.pop() # æŒ‰ESCä¹Ÿè§†ä¸ºå–æ¶ˆ

    def draw(self, surface):
        
        
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))

        # 2. ç»˜åˆ¶å¯¹è¯æ¡†é¢æ¿
        draw_panel(surface, self.panel_rect, "è¯·ç¡®è®¤", self.game.fonts['large'])
        
        # 3. ç»˜åˆ¶æç¤ºæ–‡å­—
        text_rect = self.panel_rect.inflate(-80, -80)
        text_rect.h = 100 # é™åˆ¶æ–‡å­—åŒºåŸŸé«˜åº¦
        draw_text(surface, self.text, self.game.fonts['normal'], TEXT_COLOR, text_rect)

        # 4. ç»˜åˆ¶æŒ‰é’®
        self.yes_button.draw(surface)
        self.no_button.draw(surface)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\dungeon_screen.py
================================================================================

import pygame
import random
from .base import BaseState
from dungeon_generator import Floor
from player_sprite import Player
from monster_sprite import Monster
from treasure_sprite import TreasureChest
import Equips
from settings import *
from ui import Button
from portal_sprite import PortalSprite # <-- æ–°å¢è¿™ä¸€è¡Œ

NODE_STYLE = {"start": {"color": (100, 255, 100)},"combat": {"color": (200, 200, 200)}, "event": {"color": (255, 255, 100)},"treasure": {"color": (255, 215, 0)},"elite": {"color": (255, 50, 50)},"boss": {"color": (160, 32, 240)},"rest": {"color": (100, 200, 255)},"shop": {"color": (100, 255, 200)},"forge": {"color": (150, 150, 150)}}

# File: states/dungeon_screen.py

class DungeonScreen(BaseState):
    def __init__(self, game, dungeon_id="sunstone_ruins", floor_number=1):
        super().__init__(game)

        self.dungeon_id = dungeon_id
        self.floor_number = floor_number
        self.dungeon_data = self.game.dungeon_data[dungeon_id]

        self.current_floor_data = None
        for pool in self.dungeon_data.get("floor_pools", []):
            if self.floor_number in pool["floors"]:
                self.current_floor_data = pool
                break

        self.floor = Floor()
        self.floor.generate_floor(num_rooms=8, floor_data=self.current_floor_data)

        self.player = Player(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2)
        self.player_group = pygame.sprite.GroupSingle(self.player)
        self.monster_group = pygame.sprite.Group()
        self.chest_group = pygame.sprite.GroupSingle()
        self.portal_group = pygame.sprite.GroupSingle() # <-- æ–°å¢ä¼ é€é—¨ç»„

        self.door_rects = {}
        # self.exit_portal_button = None <-- åˆ é™¤è¿™ä¸€è¡Œ

        self.current_room = self.floor.start_room
        self._enter_room(self.current_room)

        backpack_button_rect = pygame.Rect(SCREEN_WIDTH - 160, 10, 140, 50)
        self.backpack_button = Button(backpack_button_rect, "èƒŒåŒ… (B)", self.game.fonts['small'])
        talents_button_rect = pygame.Rect(backpack_button_rect.left - 150, 10, 140, 50)
        self.talents_button = Button(talents_button_rect, "å¤©èµ‹ (T)", self.game.fonts['small'])
        
        # æ–‡ä»¶: states/dungeon_screen.py (æ›¿æ¢è¿™ä¸ªå‡½æ•°)

    def _enter_room(self, room):
        self.current_room = room
        if not (self.current_room.type == 'boss' and self.current_room.is_cleared):
            self.exit_portal_button = None
        print(f"è¿›å…¥æˆ¿é—´ ({room.x}, {room.y}), ç±»å‹: {room.type}")

        # --- æ ¸å¿ƒæ”¹åŠ¨åœ¨è¿™é‡Œ ---
        room_type = self.current_room.type
        is_cleared = self.current_room.is_cleared

        # åªæœ‰æœªæ¸…ç†è¿‡çš„ç‰¹æ®Šæˆ¿é—´æ‰ä¼šè§¦å‘ä¸€æ¬¡æ€§äº‹ä»¶
        if not is_cleared:
            if room_type == "event":
                from .event_screen import EventScreen
                event_id = random.choice(list(self.game.event_data.keys()))
                self.game.state_stack.append(EventScreen(self.game, event_id, self.current_room))
            elif room_type == "shop":
                from .shop_screen import ShopScreen
                self.game.state_stack.append(ShopScreen(self.game, self.current_room))
            
            # --- æ–°å¢çš„åˆ†æ”¯ ---
            elif room_type == "rest":
                from .rest_screen import RestScreen # å¯¼å…¥æˆ‘ä»¬åˆšåˆ›å»ºçš„ä¼‘æ¯ç•Œé¢
                # å¼¹å‡ºä¼‘æ¯ç•Œé¢ï¼Œå¹¶æŠŠå½“å‰æˆ¿é—´ä¿¡æ¯ä¼ è¿‡å»
                self.game.state_stack.append(RestScreen(self.game, self.current_room))

        self._sync_sprites()
        self.door_rects = self._generate_doors()

    def _generate_doors(self):
        if not self.current_room.is_cleared: return {}
        doors = {}; door_size, margin = 60, 10
        if self.current_room.doors["N"]: doors["N"] = pygame.Rect(SCREEN_WIDTH/2 - door_size/2, 0, door_size, margin)
        if self.current_room.doors["S"]: doors["S"] = pygame.Rect(SCREEN_WIDTH/2 - door_size/2, SCREEN_HEIGHT - margin, door_size, margin)
        if self.current_room.doors["W"]: doors["W"] = pygame.Rect(0, SCREEN_HEIGHT/2 - door_size/2, margin, door_size)
        if self.current_room.doors["E"]: doors["E"] = pygame.Rect(SCREEN_WIDTH - margin, SCREEN_HEIGHT/2 - door_size/2, margin, door_size)
        return doors

    # ç”¨è¿™ä¸ªç‰ˆæœ¬å®Œæ•´æ›¿æ¢ä½ çš„ handle_event æ–¹æ³•
    # æ–‡ä»¶: states/dungeon_screen.py (æ›¿æ¢ handle_event æ–¹æ³•)
    def handle_event(self, event):
        from .backpack import BackpackScreen
        from .talents_screen import TalentsScreen

        if self.backpack_button.handle_event(event):
            self.game.state_stack.append(BackpackScreen(self.game))
            return

        if self.talents_button.handle_event(event):
            self.game.state_stack.append(TalentsScreen(self.game))
            return

        # --- æ—§çš„ä¼ é€é—¨æŒ‰é’®ç‚¹å‡»é€»è¾‘å·²ä»è¿™é‡Œç§»é™¤ ---

        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_b:
                self.game.state_stack.append(BackpackScreen(self.game))
            elif event.key == pygame.K_t:
                self.game.state_stack.append(TalentsScreen(self.game))

        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            pass # è¿™é‡Œä¸å†éœ€è¦å¤„ç†å®ç®±ç‚¹å‡»ï¼Œæ‰€ä»¥æ˜¯ç©ºçš„
                            
    def _sync_sprites(self):
        self.monster_group.empty()
        self.chest_group.empty()

        if not self.current_room.is_cleared:
            if self.current_room.type in ["combat", "elite", "boss"]:
                for monster_data in self.current_room.monsters:
                    self.monster_group.add(Monster(monster_data))
            elif self.current_room.type == "treasure":
                self.chest_group.add(TreasureChest(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2))

    def _open_treasure_chest(self, chest_sprite):
        """æ‰“å¼€å®ç®±ï¼Œå¹¶æ ¹æ®å½“å‰æ¥¼å±‚é…ç½®(JSON)ç”Ÿæˆé€‰é¡¹ (å¸¦è¯¦ç»†è°ƒè¯•)"""
        print("--- è¿›å…¥ _open_treasure_chest æ–¹æ³• ---")
        
        # æ£€æŸ¥ç‚¹ A: æ£€æŸ¥æ¥¼å±‚æ•°æ®æ˜¯å¦å­˜åœ¨
        if not self.current_floor_data or "treasure_loot" not in self.current_floor_data:
            print(">>> é”™è¯¯ï¼šåœ¨dungeon_data.jsonä¸­æœªæ‰¾åˆ°å½“å‰æ¥¼å±‚çš„ treasure_loot é…ç½®ï¼")
            return

        loot_config = self.current_floor_data["treasure_loot"]
        rarity_weights = loot_config.get("rarity_weights", {"common": 100})
        item_count = loot_config.get("item_count", 2)
        print(f"ä½¿ç”¨é…ç½®: {item_count}ä¸ªç‰©å“, æ‰è½ç‡: {rarity_weights}")

        # --- ç‰©å“ç”Ÿæˆé€»è¾‘ (ä¸å˜) ---
        item_pool = {rarity: [] for rarity in rarity_weights.keys()}
        all_item_classes = [getattr(Equips, name) for name in dir(Equips) if isinstance(getattr(Equips, name), type) and issubclass(getattr(Equips, name), Equips.Equipment) and getattr(Equips, name) is not Equips.Equipment]
        for item_class in all_item_classes:
            temp_item = item_class()
            if hasattr(temp_item, 'rarity') and temp_item.rarity in item_pool:
                item_pool[temp_item.rarity].append(item_class)
        
        rarities_to_spawn = random.choices(list(rarity_weights.keys()), weights=list(rarity_weights.values()), k=item_count)
        choices = []
        for rarity in rarities_to_spawn:
            if item_pool.get(rarity):
                item_class = random.choice(item_pool[rarity])
                choices.append(item_class())
        
        # æ£€æŸ¥ç‚¹ B: æ£€æŸ¥æ˜¯å¦æˆåŠŸç”Ÿæˆäº†ç‰©å“
        print(f"æˆåŠŸç”Ÿæˆäº† {len(choices)} ä¸ªç‰©å“é€‰é¡¹ã€‚")

        if not choices:
            print(">>> é”™è¯¯: æœªèƒ½ç”Ÿæˆä»»ä½•ç‰©å“ï¼æ–¹æ³•æå‰é€€å‡ºã€‚")
            self.current_room.is_cleared = True
            self.door_rects = self._generate_doors()
            chest_sprite.kill()
            return

        # æ£€æŸ¥ç‚¹ C: å‡†å¤‡å¼¹å‡ºé€‰æ‹©ç•Œé¢
        print(f"å‡†å¤‡å¼¹å‡ºé€‰æ‹©ç•Œé¢ï¼Œç‰©å“ä¸º: {[getattr(c, 'display_name', 'æœªçŸ¥') for c in choices]}")
        from .choice_screen import ChoiceScreen
        self.game.state_stack.append(ChoiceScreen(self.game, choices, self.current_room))
        
        # æ£€æŸ¥ç‚¹ D: ç¡®è®¤ç•Œé¢å·²å¼¹å‡º
        print(">>> é€‰æ‹©ç•Œé¢å·²å¼¹å‡ºåˆ°çŠ¶æ€æ ˆã€‚ killing chest...")
        
        chest_sprite.kill()

    def on_monster_defeated(self, defeated_monster_uid):
        self.current_room.monsters = [m for m in self.current_room.monsters if m['uid'] != defeated_monster_uid]
        self._sync_sprites()
        if not self.current_room.monsters:
            self.current_room.is_cleared = True
            self.door_rects = self._generate_doors()
            if self.current_room.type == "boss":
                # ä¸å†åˆ›å»ºæŒ‰é’®ï¼Œè€Œæ˜¯åˆ›å»ºä¼ é€é—¨ç²¾çµå¹¶æ·»åŠ åˆ°ç»„é‡Œ
                self.portal_group.add(PortalSprite(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2))
                
    # æ–‡ä»¶: states/dungeon_screen.py (æ›¿æ¢ update æ–¹æ³•)
    def update(self):
        self.player_group.update()

        if not self.current_room.is_cleared:
            # æ£€æŸ¥ä¸æ€ªç‰©çš„ç¢°æ’
            collided_monster = pygame.sprite.spritecollideany(self.player, self.monster_group)
            if collided_monster:
                from .combat import CombatScreen
                self.game.state_stack.append(CombatScreen(self.game, collided_monster.enemy_id, collided_monster.uid))
                self.monster_group.empty()
                return

            # æ£€æŸ¥ä¸å®ç®±çš„ç¢°æ’
            collided_chest = pygame.sprite.spritecollideany(self.player, self.chest_group)
            if collided_chest:
                self._open_treasure_chest(collided_chest)
                return

        else: # æˆ¿é—´å·²æ¸…ç†
            # --- æ ¸å¿ƒä¿®æ”¹åœ¨è¿™é‡Œ ---
            # æ£€æŸ¥ä¸ä¼ é€é—¨çš„ç¢°æ’
            collided_portal = pygame.sprite.spritecollideany(self.player, self.portal_group)
            if collided_portal:
                print("è¿›å…¥ä¸‹ä¸€å±‚ï¼")
                next_floor_number = self.floor_number + 1
                self.game.state_stack.pop()
                self.game.state_stack.append(DungeonScreen(self.game, self.dungeon_id, next_floor_number))
                return
            # --- ä¿®æ”¹ç»“æŸ ---

            # æ£€æŸ¥ä¸é—¨çš„ç¢°æ’
            for direction, door_rect in self.door_rects.items():
                if self.player.rect.colliderect(door_rect):
                    self._change_room(direction)
                    break
                
    def _change_room(self, direction):
        x, y = self.current_room.x, self.current_room.y; next_room_coord = None
        if direction == "N": next_room_coord = (x, y - 1)
        if direction == "S": next_room_coord = (x, y + 1)
        if direction == "W": next_room_coord = (x - 1, y)
        if direction == "E": next_room_coord = (x + 1, y)
        if next_room_coord in self.floor.rooms:
            next_room = self.floor.rooms[next_room_coord]; self._enter_room(next_room)
            if direction == "N": self.player.rect.bottom = SCREEN_HEIGHT - 15
            if direction == "S": self.player.rect.top = 15
            if direction == "W": self.player.rect.right = SCREEN_WIDTH - 15
            if direction == "E": self.player.rect.left = 15

    # æ–‡ä»¶: states/dungeon_screen.py (æ›¿æ¢ draw æ–¹æ³•)
    def draw(self, surface):
        surface.fill(BG_COLOR)
        for door_rect in self.door_rects.values(): pygame.draw.rect(surface, (100, 200, 100), door_rect)

        # if self.exit_portal_button: self.exit_portal_button.draw(surface) <-- åˆ é™¤è¿™è¡Œ
        self.portal_group.draw(surface) # <-- æ–°å¢è¿™è¡Œï¼Œç»˜åˆ¶ä¼ é€é—¨ç²¾çµ

        self.monster_group.draw(surface)
        self.chest_group.draw(surface)
        self.player_group.draw(surface)
        self._draw_minimap(surface)
        self.backpack_button.draw(surface)
        self.talents_button.draw(surface)
        
    def _draw_minimap(self, surface):
        minimap_rect = pygame.Rect(10, 10, 230, 230)
        pygame.draw.rect(surface, PANEL_BG_COLOR, minimap_rect); pygame.draw.rect(surface, PANEL_BORDER_COLOR, minimap_rect, 2)
        cell_size = 15
        for (x, y), room in self.floor.rooms.items():
            map_x, map_y = minimap_rect.x + x*cell_size + 5, minimap_rect.y + y*cell_size + 5
            cell_rect = pygame.Rect(map_x, map_y, cell_size - 1, cell_size - 1)
            base_color = NODE_STYLE.get(room.type, {"color": (255,255,255)})["color"]
            final_color = base_color
            if not room.is_cleared and room.type != "start":
                final_color = (base_color[0] // 2, base_color[1] // 2, base_color[2] // 2)
            pygame.draw.rect(surface, final_color, cell_rect)
            if room is self.current_room:
                p1 = (cell_rect.centerx, cell_rect.top + 3); p2 = (cell_rect.left + 3, cell_rect.bottom - 3); p3 = (cell_rect.right - 3, cell_rect.bottom - 3)
                pygame.draw.polygon(surface, (255, 255, 255, 200), [p1, p2, p3])


================================================================================
### æ–‡ä»¶è·¯å¾„: states\event_screen.py
================================================================================

# states/event_screen.py
import pygame
import random
from .base import BaseState
from ui import Button, draw_panel, draw_text
from settings import *
import Talents # å¯¼å…¥å¤©èµ‹æ¨¡å—

class EventScreen(BaseState):
    def __init__(self, game, event_id, origin_room):
        super().__init__(game)
        self.is_overlay = True
        self.event_data = self.game.event_data[event_id]
        self.origin_room = origin_room
        
        # ç•Œé¢çŠ¶æ€ç®¡ç†ï¼š'choosing' (é€‰æ‹©ä¸­) æˆ– 'showing_result' (æ˜¾ç¤ºç»“æœ)
        self.view_mode = 'choosing' 
        self.result_text = ""
        
        self._setup_ui()

    def _setup_ui(self):
        # é¢æ¿
        panel_w, panel_h = 800, 500
        self.panel_rect = pygame.Rect((SCREEN_WIDTH - panel_w) / 2, (SCREEN_HEIGHT - panel_h) / 2, panel_w, panel_h)
        
        # é€‰é¡¹æŒ‰é’®
        self.choice_buttons = []
        btn_w, btn_h = 600, 60
        num_choices = len(self.event_data["choices"])
        start_y = self.panel_rect.bottom - (btn_h + 20) * num_choices - 20
        
        for i, choice in enumerate(self.event_data["choices"]):
            rect = pygame.Rect(self.panel_rect.centerx - btn_w / 2, start_y + i * (btn_h + 20), btn_w, btn_h)
            self.choice_buttons.append(Button(rect, choice["text"], self.game.fonts['normal']))
            
        # â€œç»§ç»­â€æŒ‰é’®ï¼ˆç”¨äºæ˜¾ç¤ºç»“æœåï¼‰
        self.continue_button = Button(self.choice_buttons[-1].rect, "ç»§ç»­...", self.game.fonts['normal'])

    def handle_event(self, event):
        if self.view_mode == 'choosing':
            for i, button in enumerate(self.choice_buttons):
                if button.handle_event(event):
                    self._process_choice(i)
                    return
        elif self.view_mode == 'showing_result':
            if self.continue_button.handle_event(event):
                self._leave_event()

    # åœ¨ states/event_screen.py æ–‡ä»¶ä¸­ï¼Œæ‰¾åˆ°å¹¶æ›¿æ¢è¿™ä¸ªå‡½æ•°

    def _process_choice(self, choice_index):
        """å¤„ç†ç©å®¶çš„é€‰æ‹©å¹¶è®¡ç®—ç»“æœ"""
        choice_data = self.event_data["choices"][choice_index]
        outcomes = choice_data["outcomes"]
        
        rand_val = random.random()
        cumulative_chance = 0.0
        selected_outcome = None
        for outcome in outcomes:
            cumulative_chance += outcome.get("chance", 1.0)
            if rand_val < cumulative_chance:
                selected_outcome = outcome
                break
        
        if not selected_outcome: return

        outcome_type = selected_outcome["type"]
        self.result_text = selected_outcome["result_text"]
        
        player = self.game.player
        if outcome_type == "HEAL":
            if selected_outcome["amount"] == "full":
                player.hp = player.max_hp
        
        elif outcome_type == "WEAPON_UPGRADE":
            player.base_attack += 5
            player.attack += 5
        
        elif outcome_type == "WEAPON_CURSE":
            player.base_attack = max(1, player.base_attack - 3)
            player.attack = max(1, player.attack - 3)
            
        # --- æ ¸å¿ƒä¿®å¤ï¼šä½¿ç”¨æ–°çš„å¤©èµ‹å­¦ä¹ å’Œè£…å¤‡é€»è¾‘ ---
        elif outcome_type == "GAIN_TALENT":
            talent_class_name = selected_outcome["talent_class_name"]
            if hasattr(Talents, talent_class_name):
                talent_instance = getattr(Talents, talent_class_name)()
                
                # 1. å°è¯•å­¦ä¹ æ–°å¤©èµ‹
                was_new = player.learn_talent(talent_instance)
                
                if was_new:
                    # 2. å¦‚æœæ˜¯æ–°å­¦ä¼šçš„ï¼Œå°è¯•è‡ªåŠ¨è£…å¤‡å®ƒ
                    was_equipped = player.equip_talent(talent_instance)
                    if not was_equipped:
                        self.result_text += " (å¤©èµ‹æ§½å·²æ»¡ï¼Œè¯·åœ¨å¤©èµ‹ç•Œé¢(T)æ‰‹åŠ¨è£…å¤‡)"
                else:
                    self.result_text = "ä½ ä¼¼ä¹å·²ç»é¢†æ‚Ÿè¿‡ç±»ä¼¼çš„èƒ½åŠ›äº†..."

        elif outcome_type == "TRIGGER_COMBAT":
            from .combat import CombatScreen
            enemy_id = selected_outcome["enemy_id"]
            self._leave_event()
            # å‰§æƒ…æˆ˜æ–—ä¸éœ€è¦ origin_id
            self.game.state_stack.append(CombatScreen(self.game, enemy_id)) 
            return
            
        self.view_mode = 'showing_result'

    def _leave_event(self):
        """ç¦»å¼€äº‹ä»¶ï¼Œæ›´æ–°åœ°å›¾å¹¶å…³é—­ç•Œé¢"""
        from .dungeon_screen import DungeonScreen
        self.origin_room.is_cleared = True
        if len(self.game.state_stack) > 1:
            prev_state = self.game.state_stack[-2]
            if isinstance(prev_state, DungeonScreen):
                prev_state.door_rects = prev_state._generate_doors()
        self.game.state_stack.pop()

    def draw(self, surface):
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180)); surface.blit(overlay, (0, 0))
        
        draw_panel(surface, self.panel_rect, self.event_data["title"], self.game.fonts['large'])
        
        if self.view_mode == 'choosing':
            desc_rect = self.panel_rect.inflate(-80, -250)
            desc_rect.top = self.panel_rect.top + 100
            draw_text(surface, self.event_data["description"], self.game.fonts['normal'], TEXT_COLOR, desc_rect)
            for button in self.choice_buttons:
                button.draw(surface)
        elif self.view_mode == 'showing_result':
            result_rect = self.panel_rect.inflate(-80, -250)
            result_rect.top = self.panel_rect.top + 150
            draw_text(surface, self.result_text, self.game.fonts['normal'], HOVER_COLOR, result_rect)
            self.continue_button.draw(surface)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\loading.py
================================================================================

# states/loading.py
import pygame
import time
from .base import BaseState
from ui import draw_text, Button
from settings import *

class LoadScreen(BaseState):
    def __init__(self, game):
        super().__init__(game)
        self.back_button = Button((SCREEN_WIDTH / 2 - 150, SCREEN_HEIGHT - 100, 300, 60), "è¿”å›", self.game.fonts['normal'])
        self.slot_rects = [pygame.Rect(100, 120 + i * 50, SCREEN_WIDTH - 200, 50) for i in range(10)]
        self.load_fail_message = None

    def handle_event(self, event):
        if self.back_button.handle_event(event) or (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
            self.game.state_stack.pop()
            return

        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            for i, rect in enumerate(self.slot_rects):
                if rect.collidepoint(event.pos):
                    # --- è¿™æ˜¯æ ¸å¿ƒä¿®å¤ ---
                    # load_from_slot ä¼šæ›´æ–° self.game çš„ player, current_stage ç­‰
                    if self.game.load_from_slot(i):
                        from states.story import StoryScreen
                        # æ¸…ç©ºæ•´ä¸ªçŠ¶æ€æ ˆï¼Œç„¶åå‹å…¥ä¸€ä¸ªæ–°çš„ã€åŸºäºå·²åŠ è½½æ•°æ®çš„ StoryScreen
                        self.game.state_stack = [StoryScreen(self.game)]
                    else:
                        self.load_fail_message = f"æ§½ä½ {i} ä¸ºç©ºæˆ–æŸåï¼"
                    return
                    # --- ä¿®å¤ç»“æŸ ---

    def draw(self, surface):
        surface.fill(BG_COLOR)
        title_font = self.game.fonts['large']
        draw_text(surface, "é€‰æ‹©è¦åŠ è½½çš„å­˜æ¡£", title_font, TEXT_COLOR, pygame.Rect(0, 50, SCREEN_WIDTH, 100))

        for i, rect in enumerate(self.slot_rects):
            slot_data = self.game.peek_save_slot(i)
            is_hovered = rect.collidepoint(pygame.mouse.get_pos())
            if is_hovered:
                pygame.draw.rect(surface, PANEL_BORDER_COLOR, rect.inflate(10, 10), 2, border_radius=5)
            
            text = f"{i}. " + ("(è‡ªåŠ¨)" if i == 0 else "")
            if slot_data and slot_data.get("player"):
                player = slot_data["player"]
                save_time = time.strftime('%Y-%m-%d %H:%M', time.localtime(slot_data.get("timestamp", 0)))
                text += f"{player.name} - ç­‰çº§ {player.level} ({save_time})"
            else:
                text += "-- ç©º --"
            draw_text(surface, text, self.game.fonts['normal'], TEXT_COLOR, rect)

        if self.load_fail_message:
            fail_rect = pygame.Rect(0, SCREEN_HEIGHT - 150, SCREEN_WIDTH, 40)
            draw_text(surface, self.load_fail_message, self.game.fonts['normal'], (255, 100, 100), fail_rect)

        self.back_button.draw(surface)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\loot.py
================================================================================

# states/loot.py (å·²ä¿®æ­£)
import pygame
import random
from .base import BaseState
from ui import draw_panel, draw_text
from settings import *
import Equips
from Character import Character # éœ€è¦å¯¼å…¥Characterç±»ç”¨äºç±»å‹æ£€æŸ¥

class LootScreen(BaseState):
    def __init__(self, game, defeated_enemy_object=None, next_story_stage=None):
        super().__init__(game)
        self.is_overlay = True

        # --- æ ¸å¿ƒä¿®æ”¹åœ¨è¿™é‡Œ ---
        # defeated_enemy_object ç°åœ¨æ˜¯å®Œæ•´çš„æ•Œäººå¯¹è±¡
        self.defeated_enemy_object = defeated_enemy_object
        # æˆ‘ä»¬ä»ç„¶éœ€è¦ enemy_id æ¥æŸ¥è¯¢è£…å¤‡æ‰è½è¡¨
        self.defeated_enemy_id = defeated_enemy_object.id if isinstance(defeated_enemy_object, Character) else None

        self.next_story_stage = next_story_stage

        panel_w = SCREEN_WIDTH * 0.7
        panel_h = SCREEN_HEIGHT * 0.7
        self.panel_rect = pygame.Rect(
            (SCREEN_WIDTH - panel_w) / 2,
            (SCREEN_HEIGHT - panel_h) / 2,
            panel_w, panel_h
        )
        self._process_rewards()

    def _process_rewards(self):
        self.exp_messages = []
        if self.defeated_enemy_id:
            enemy_preset = self.game.enemy_data.get(self.defeated_enemy_id, {})
            self.exp_messages = self.game.player.add_exp(enemy_preset.get("exp_reward", 0))
        
        self.loot_messages = self._generate_loot()
        self.game.save_to_slot(0)
        
    # æ–‡ä»¶: states/loot.py (æ›¿æ¢è¿™ä¸ªå‡½æ•°)

    # æ–‡ä»¶: states/loot.py (æ›¿æ¢è¿™ä¸ªå‡½æ•°)

    def _generate_loot(self):
        messages = []
        found_any_loot = False
        
        # --- Part 1: è£…å¤‡æ‰è½é€»è¾‘ ---
        if self.defeated_enemy_id:
            equipment_drops = self.game.loot_data.get(self.defeated_enemy_id, [])
            if equipment_drops:
                equipment_header_added = False
                for drop_info in equipment_drops:
                    if random.random() < drop_info.get("chance", 1.0):
                        if not equipment_header_added:
                            messages.append("--- æˆ˜åˆ©å“ ---")
                            equipment_header_added = True
                        
                        found_any_loot = True
                        item_class_name = drop_info["item_class_name"]
                        try:
                            item_class = getattr(Equips, item_class_name)
                            new_item = item_class()
                            display_name = getattr(new_item, 'display_name', item_class_name)
                            feedback = self.game.player.pickup_item(new_item)
                            if "æ”¾å…¥ä½ çš„èƒŒåŒ…" in feedback:
                                messages.append(f"è·å¾—äº†è£…å¤‡ï¼š{display_name}ï¼")
                            else:
                                messages.append(feedback)
                        except AttributeError:
                            messages.append(f"é”™è¯¯ï¼šæœªæ‰¾åˆ°ç‰©å“ {item_class_name}ã€‚")

        # --- Part 2: å¤©èµ‹æ‰è½é€»è¾‘ ---
        import Talents
        if self.defeated_enemy_object and self.defeated_enemy_object.equipped_talents:
            talent_header_added = False
            for possessed_talent in self.defeated_enemy_object.equipped_talents:
                
                # --- æ ¸å¿ƒä¿®å¤ï¼šåœ¨å¤„ç†å‰ï¼Œå…ˆç¡®ä¿è¿™ä¸ªæ§½ä½é‡Œçš„å¤©èµ‹ä¸æ˜¯ç©ºçš„ (None) ---
                if possessed_talent and random.random() < 0.15: # 15% çš„æ‰è½ç‡
                    was_new = self.game.player.learn_talent(possessed_talent)
                    if was_new:
                        if not talent_header_added:
                            messages.append("--- èƒ½åŠ›é¢†æ‚Ÿ ---")
                            talent_header_added = True
                            
                        found_any_loot = True
                        messages.append(f"ä½ ä»æ•Œäººèº«ä¸Šé¢†æ‚Ÿäº†ã€Œ{possessed_talent.display_name}ã€ï¼")

        # --- Part 3: æœ€ç»ˆæ€»ç»“ ---
        if not found_any_loot:
            messages.append("æ•Œäººæ²¡æœ‰ç•™ä¸‹ä»»ä½•æœ‰ä»·å€¼çš„ä¸œè¥¿ã€‚")
            
        return messages

    def handle_event(self, event):
        if (event.type == pygame.MOUSEBUTTONDOWN and event.button == 1) or \
           (event.type == pygame.KEYDOWN and event.key in [pygame.K_RETURN, pygame.K_SPACE]):
            
            if self.next_story_stage:
                from .story import StoryScreen
                self.game.current_stage = self.next_story_stage
                self.game.state_stack.pop()
                if self.game.state_stack and isinstance(self.game.state_stack[-1], StoryScreen):
                    self.game.state_stack.pop()
                self.game.state_stack.append(StoryScreen(self.game))
            else:
                self.game.state_stack.pop()

    def draw(self, surface):
        # ç»˜åˆ¶åº•å±‚ç•Œé¢
        if len(self.game.state_stack) > 1:
            self.game.state_stack[-2].draw(surface)
        
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180)); surface.blit(overlay, (0, 0))
        
        # --- æ ¸å¿ƒä¿®å¤ï¼šä½¿ç”¨ self.panel_rect ---
        title = "æˆ˜æ–—èƒœåˆ©" if self.defeated_enemy_id else "æ‰“å¼€å®ç®±"
        draw_panel(surface, self.panel_rect, title, self.game.fonts['large'])
        
        all_messages = self.exp_messages + self.loot_messages
        current_y = self.panel_rect.top + 120
        for line in all_messages:
            clean_line = line.replace("ğŸ‰ ", "")
            text_surf = self.game.fonts['normal'].render(clean_line, True, TEXT_COLOR)
            text_rect = text_surf.get_rect(center=(self.panel_rect.centerx, current_y))
            surface.blit(text_surf, text_rect); current_y += 35
            
        prompt_surf = self.game.fonts['small'].render("ç‚¹å‡»ä»»æ„å¤„ç»§ç»­...", True, TEXT_COLOR)
        prompt_rect = prompt_surf.get_rect(center=(self.panel_rect.centerx, self.panel_rect.bottom - 40))
        surface.blit(prompt_surf, prompt_rect)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\notification_screen.py
================================================================================

# states/notification_screen.py
import pygame
from .base import BaseState
from ui import draw_text
from settings import *

class NotificationScreen(BaseState):
    def __init__(self, game, message, duration=2.0):
        super().__init__(game)
        self.is_overlay = True
        self.message = message
        self.duration = duration # ç§’
        self.start_time = pygame.time.get_ticks()

    def update(self):
        # è®¡æ—¶ç»“æŸï¼Œè‡ªåŠ¨å…³é—­
        if pygame.time.get_ticks() - self.start_time > self.duration * 1000:
            self.game.state_stack.pop()

    def draw(self, surface):
        # åˆ›å»ºä¸€ä¸ªä½äºå±å¹•åº•éƒ¨ä¸­å¤®çš„å¯¹è¯æ¡†
        box_width = 600
        box_height = 80
        box_rect = pygame.Rect(
            (SCREEN_WIDTH - box_width) / 2,
            SCREEN_HEIGHT - box_height - 30, # ç¦»åº•éƒ¨30åƒç´ 
            box_width,
            box_height
        )
        
        # ç»˜åˆ¶åŠé€æ˜èƒŒæ™¯
        bg_surface = pygame.Surface(box_rect.size, pygame.SRCALPHA)
        bg_surface.fill((20, 35, 50, 200)) # ä½¿ç”¨é¢æ¿èƒŒæ™¯è‰²ï¼Œå¸¦é€æ˜åº¦
        surface.blit(bg_surface, box_rect.topleft)
        pygame.draw.rect(surface, PANEL_BORDER_COLOR, box_rect, 2, border_radius=10)

        # ç»˜åˆ¶æ¶ˆæ¯æ–‡æœ¬
        draw_text(surface, self.message, self.game.fonts['normal'], TEXT_COLOR, box_rect)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\rest_screen.py
================================================================================

# æ–‡ä»¶: states/rest_screen.py (æ–°æ–‡ä»¶)

import pygame
import random
from .base import BaseState
from ui import Button, draw_panel, draw_text
from settings import *

class RestScreen(BaseState):

    def __init__(self, game, origin_room):
        super().__init__(game)
        self.is_overlay = True
        self.origin_room = origin_room

        self.rest_used = False
        self.forge_used = False
        self.feedback_message = ""

        # --- æ ¸å¿ƒä¿®æ”¹åœ¨è¿™é‡Œ ---
        from Equips import UPGRADE_MAP 

        # 1. åˆ›å»ºä¸€ä¸ªåŒ…å«ç©å®¶æ‰€æœ‰ç‰©å“ï¼ˆå·²è£…å¤‡çš„ + èƒŒåŒ…é‡Œçš„ï¼‰çš„æ€»åˆ—è¡¨
        all_player_items = self.game.player.all_equipment + self.game.player.backpack

        # 2. ä»è¿™ä¸ªæ€»åˆ—è¡¨ä¸­ï¼Œç­›é€‰å‡ºæ‰€æœ‰å¯ä»¥è¢«å‡çº§çš„ç‰©å“
        self.upgradable_items = [
            item for item in all_player_items
            if item.__class__ in UPGRADE_MAP
        ]

        self._setup_ui()

    def _setup_ui(self):
        """åˆå§‹åŒ–ç”¨æˆ·ç•Œé¢å…ƒç´ """
        panel_w, panel_h = 800, 500
        self.panel_rect = pygame.Rect((SCREEN_WIDTH - panel_w) / 2, (SCREEN_HEIGHT - panel_h) / 2, panel_w, panel_h)

        # å®šä¹‰ä¸¤ä¸ªæ ¸å¿ƒé€‰é¡¹æŒ‰é’®çš„ä½ç½®
        btn_w, btn_h = 300, 180
        spacing = 50
        start_x = self.panel_rect.centerx - (btn_w * 2 + spacing) / 2

        self.rest_button = Button(
            (start_x, self.panel_rect.centery - btn_h/2, btn_w, btn_h),
            "ä¼‘æ¯", # æŒ‰é’®çš„åˆå§‹æ–‡å­—
            self.game.fonts['large']
        )
        self.forge_button = Button(
            (start_x + btn_w + spacing, self.panel_rect.centery - btn_h/2, btn_w, btn_h),
            "é”»é€ ",
            self.game.fonts['large']
        )
        
        # ç¦»å¼€æŒ‰é’®
        self.leave_button = Button(
            (self.panel_rect.centerx - 150, self.panel_rect.bottom - 100, 300, 60),
            "ç¦»å¼€",
            self.game.fonts['normal']
        )

    def handle_event(self, event):
        """å¤„ç†ç©å®¶çš„è¾“å…¥äº‹ä»¶"""
        # --- ä¼‘æ¯æŒ‰é’®çš„é€»è¾‘ (ä¸å˜) ---
        if not self.rest_used and self.rest_button.handle_event(event):
            self.rest_used = True
            heal_amount = int(self.game.player.max_hp * 0.3)
            self.game.player.heal(heal_amount)
            self.feedback_message = f"ä½ æ¢å¤äº† {heal_amount} ç‚¹ç”Ÿå‘½ï¼"
            self.forge_used = True # ä¼‘æ¯å’Œé”»é€ äºŒé€‰ä¸€
            return

        # --- å…¨æ–°çš„ã€æ›´å¼ºå¤§çš„é”»é€ é€»è¾‘ ---
        if not self.forge_used and len(self.upgradable_items) > 0 and self.forge_button.handle_event(event):
            self.forge_used = True
            self.rest_used = True # ä¼‘æ¯å’Œé”»é€ äºŒé€‰ä¸€

            player = self.game.player

            # 1. ä»å¯å‡çº§åˆ—è¡¨ä¸­éšæœºé€‰ä¸€ä»¶ (ç°åœ¨è¿™ä¸ªåˆ—è¡¨åŒ…å«äº†èƒŒåŒ…ç‰©å“)
            item_to_upgrade = random.choice(self.upgradable_items)
            item_name = getattr(item_to_upgrade, 'display_name', 'è£…å¤‡')

            from Equips import UPGRADE_MAP
            upgraded_class = UPGRADE_MAP.get(item_to_upgrade.__class__)

            if upgraded_class:
                # 2. åˆ›å»ºå‡çº§åçš„æ–°è£…å¤‡å®ä¾‹
                upgraded_item = upgraded_class()

                # 3. ä»åŸæ¥çš„ä½ç½®ç§»é™¤æ—§è£…å¤‡
                #    æ£€æŸ¥å®ƒæ˜¯åœ¨èº«ä¸Šè¿˜æ˜¯åœ¨èƒŒåŒ…é‡Œ
                if item_to_upgrade in player.all_equipment:
                    player.unequip(item_to_upgrade)
                elif item_to_upgrade in player.backpack:
                    player.backpack.remove(item_to_upgrade)

                # 4. å°†é”»é€ å¥½çš„æ–°è£…å¤‡æ”¾å…¥èƒŒåŒ…
                #    æˆ‘ä»¬ä½¿ç”¨ pickup_item æ–¹æ³•ï¼Œå› ä¸ºå®ƒèƒ½è‡ªåŠ¨å¤„ç†é‡å¤ç‰©å“è½¬åŒ–ä¸ºé‡‘å¸çš„é€»è¾‘
                feedback = player.pickup_item(upgraded_item)
                if "æ”¾å…¥ä½ çš„èƒŒåŒ…" in feedback:
                    self.feedback_message = f"é”»é€ æˆåŠŸï¼æ–°çš„ã€Œ{upgraded_item.display_name}ã€å·²æ”¾å…¥ä½ çš„èƒŒåŒ…ï¼"
                else: # å¦‚æœç©å®¶å·²ç»æœ‰å‡çº§ç‰ˆçš„è£…å¤‡äº†ï¼Œä¼šè‡ªåŠ¨è½¬åŒ–æˆé‡‘å¸
                    self.feedback_message = f"é”»é€ æˆåŠŸï¼ä½†ä½ å·²æ‹¥æœ‰åŒåè£…å¤‡ï¼Œè½¬åŒ–ä¸ºé‡‘å¸ï¼"

            else:
                self.feedback_message = f"ã€Œ{item_name}ã€ä¼¼ä¹æ— æ³•è¢«å¼ºåŒ–..."

            return

        # --- å¤„ç†ç¦»å¼€æŒ‰é’® (ä¸å˜) ---
        if self.leave_button.handle_event(event):
            self._leave_room()
            
    def _leave_room(self):
        """å¤„ç†ç¦»å¼€ä¼‘æ¯å®¤çš„é€»è¾‘"""
        from .dungeon_screen import DungeonScreen
        # æ ‡è®°è¿™ä¸ªæˆ¿é—´ä¸ºâ€œå·²æ¢ç´¢å®Œæ¯•â€
        self.origin_room.is_cleared = True
        
        # æ›´æ–°åœ°ç‰¢ç•Œé¢ï¼Œè®©å‡ºå£çš„é—¨æ˜¾ç¤ºå‡ºæ¥
        if len(self.game.state_stack) > 1:
            prev_state = self.game.state_stack[-2]
            if isinstance(prev_state, DungeonScreen):
                prev_state.door_rects = prev_state._generate_doors()
        
        # å°†è‡ªå·±ä»çŠ¶æ€æ ˆä¸­å¼¹å‡ºï¼Œè¿”å›åœ°ç‰¢ç•Œé¢
        self.game.state_stack.pop()

    def draw(self, surface):
        """ç»˜åˆ¶æ‰€æœ‰UIå…ƒç´ åˆ°å±å¹•ä¸Š"""
        # ç»˜åˆ¶åŠé€æ˜çš„èƒŒæ™¯é®ç½©
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))

        # ç»˜åˆ¶ä¸»é¢æ¿
        draw_panel(surface, self.panel_rect, "ç¯ç«æ—çš„ì‰¼í„°", self.game.fonts['large'])

        # --- ç»˜åˆ¶ä¼‘æ¯æŒ‰é’®å’Œæè¿° ---
        self.rest_button.draw(surface)
        rest_desc = "æ¢å¤30%æœ€å¤§ç”Ÿå‘½å€¼"
        rest_desc_rect = self.rest_button.rect.copy()
        rest_desc_rect.y += 190 # è°ƒæ•´æè¿°æ–‡æœ¬çš„ä½ç½®
        draw_text(surface, rest_desc, self.game.fonts['small'], TEXT_COLOR, rest_desc_rect)
        if self.rest_used: # å¦‚æœå·²ä½¿ç”¨ï¼Œç»˜åˆ¶ä¸€ä¸ªé®ç½©
            s = pygame.Surface(self.rest_button.rect.size, pygame.SRCALPHA)
            s.fill((50,50,50,180))
            surface.blit(s, self.rest_button.rect.topleft)

        # --- ç»˜åˆ¶é”»é€ æŒ‰é’®å’Œæè¿° ---
        self.forge_button.draw(surface)
        forge_desc = "éšæœºå¼ºåŒ–ä¸€ä»¶è£…å¤‡"
        if len(self.upgradable_items) == 0:
            forge_desc = "æ²¡æœ‰å¯å¼ºåŒ–çš„è£…å¤‡"
        forge_desc_rect = self.forge_button.rect.copy()
        forge_desc_rect.y += 190
        draw_text(surface, forge_desc, self.game.fonts['small'], TEXT_COLOR, forge_desc_rect)
        if self.forge_used or len(self.upgradable_items) == 0: # å¦‚æœå·²ä½¿ç”¨æˆ–æ²¡æœ‰è£…å¤‡ï¼Œç»˜åˆ¶é®ç½©
            s = pygame.Surface(self.forge_button.rect.size, pygame.SRCALPHA)
            s.fill((50,50,50,180))
            surface.blit(s, self.forge_button.rect.topleft)

        # ç»˜åˆ¶æ“ä½œåé¦ˆä¿¡æ¯
        if self.feedback_message:
            feedback_rect = pygame.Rect(0, self.panel_rect.top + 100, self.panel_rect.width, 40)
            feedback_rect.centerx = self.panel_rect.centerx
            draw_text(surface, self.feedback_message, self.game.fonts['normal'], HOVER_COLOR, feedback_rect)

        # ç»˜åˆ¶ç¦»å¼€æŒ‰é’®
        self.leave_button.draw(surface)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\sandbox_screen.py
================================================================================

# æ–‡ä»¶: states/sandbox_screen.py (æ–°æ–‡ä»¶)

import pygame
import inspect
from .base import BaseState
from ui import Button, draw_panel, draw_text
from settings import *
from Character import Character
import Equips
import Talents

class SandboxScreen(BaseState):
# æ–‡ä»¶: states/sandbox_screen.py (æ›¿æ¢è¿™ä¸ªå‡½æ•°)

    def __init__(self, game):
        super().__init__(game)
        
        # --- æ ¸å¿ƒä¿®æ”¹ï¼šåŒæ ·ä½¿ç”¨ PLAYER_BASE_STATS æ¥åˆ›å»ºæµ‹è¯•è§’è‰² ---
        self.sandbox_player = Character(
            "æµ‹è¯•è‹±é›„",
            **PLAYER_BASE_STATS # <-- ä½¿ç”¨æˆ‘ä»¬å®šä¹‰çš„æ ‡å‡†å±æ€§
        )
        
        # 2. è§£é”æ‰€æœ‰è£…å¤‡åˆ°èƒŒåŒ…
        all_equipment_classes = [cls for name, cls in inspect.getmembers(Equips, inspect.isclass) if issubclass(cls, Equips.Equipment) and cls is not Equips.Equipment]
        for eq_class in all_equipment_classes:
            self.sandbox_player.backpack.append(eq_class())
            
        # 3. è§£é”æ‰€æœ‰å¤©èµ‹
        all_talent_classes = [cls for name, cls in inspect.getmembers(Talents, inspect.isclass) if issubclass(cls, Talents.Talent) and cls is not Talents.Talent]
        for talent_class in all_talent_classes:
            self.sandbox_player.learn_talent(talent_class())

        # 4. è®¾ç½®UI
        self.enemy_ids = list(self.game.enemy_data.keys())
        self.selected_enemy_index = 0
        
        self._setup_ui()

# æ–‡ä»¶: states/sandbox_screen.py (æ›¿æ¢è¿™ä¸‰ä¸ªå‡½æ•°)

    def _setup_ui(self):
        # æŒ‰é’®å®šä¹‰
        self.backpack_button = Button((100, 150, 300, 60), "é…ç½®èƒŒåŒ…", self.game.fonts['normal'])
        self.talents_button = Button((100, 230, 300, 60), "é…ç½®å¤©èµ‹", self.game.fonts['normal'])
        
        # --- æ–°å¢ï¼šç­‰çº§æ§åˆ¶æŒ‰é’® ---
        level_y = self.talents_button.rect.bottom + 40
        self.level_down_button = Button((100, level_y, 60, 60), "-", self.game.fonts['large'])
        self.level_up_button = Button((100 + 240, level_y, 60, 60), "+", self.game.fonts['large'])
        # --- æ–°å¢ç»“æŸ ---

        self.start_combat_button = Button((100, 450, 300, 80), "å¼€å§‹æˆ˜æ–—", self.game.fonts['large'])
        self.back_button = Button((20, 20, 100, 50), "è¿”å›", self.game.fonts['small'])

        # æ•Œäººé€‰æ‹©å™¨
        self.prev_enemy_button = Button((SCREEN_WIDTH - 450, 250, 50, 50), "<", self.game.fonts['normal'])
        self.next_enemy_button = Button((SCREEN_WIDTH - 100, 250, 50, 50), ">", self.game.fonts['normal'])
        
    def handle_event(self, event):
        from .backpack import BackpackScreen
        from .talents_screen import TalentsScreen
        from .combat import CombatScreen

        if self.back_button.handle_event(event):
            self.game.state_stack.pop()
            return
            
        if self.backpack_button.handle_event(event):
            self.game.state_stack.append(BackpackScreen(self.game, player_override=self.sandbox_player))
            return
            
        if self.talents_button.handle_event(event):
            self.game.state_stack.append(TalentsScreen(self.game, player_override=self.sandbox_player))
            return

        # --- æ–°å¢ï¼šå¤„ç†ç­‰çº§æ§åˆ¶æŒ‰é’®çš„ç‚¹å‡»äº‹ä»¶ ---
        if self.level_up_button.handle_event(event):
            self.sandbox_player.gain_level()
            return
        
        if self.level_down_button.handle_event(event):
            self.sandbox_player.lose_level()
            return
        # --- æ–°å¢ç»“æŸ ---
            
        if self.prev_enemy_button.handle_event(event):
            self.selected_enemy_index = (self.selected_enemy_index - 1 + len(self.enemy_ids)) % len(self.enemy_ids)
        
        if self.next_enemy_button.handle_event(event):
            self.selected_enemy_index = (self.selected_enemy_index + 1) % len(self.enemy_ids)

        if self.start_combat_button.handle_event(event):
            original_player = self.game.player
            self.game.player = self.sandbox_player
            selected_enemy_id = self.enemy_ids[self.selected_enemy_index]
            self.game.state_stack.append(CombatScreen(self.game, selected_enemy_id))
            return

    def draw(self, surface):
        surface.fill(BG_COLOR)
        draw_panel(surface, pygame.Rect(50, 50, 400, SCREEN_HEIGHT - 100), "é…ç½®è§’è‰²", self.game.fonts['large'])
        draw_panel(surface, pygame.Rect(SCREEN_WIDTH - 500, 50, 450, SCREEN_HEIGHT - 100), "é€‰æ‹©æ•Œäºº", self.game.fonts['large'])

        # ç»˜åˆ¶æŒ‰é’®
        self.backpack_button.draw(surface)
        self.talents_button.draw(surface)
        self.start_combat_button.draw(surface)
        self.back_button.draw(surface)
        self.prev_enemy_button.draw(surface)
        self.next_enemy_button.draw(surface)
        
        # --- æ–°å¢ï¼šç»˜åˆ¶ç­‰çº§æ§åˆ¶å™¨ ---
        self.level_up_button.draw(surface)
        self.level_down_button.draw(surface)
        
        # ç»˜åˆ¶å½“å‰ç­‰çº§æ–‡æœ¬
        level_text = f"ç­‰çº§: {self.sandbox_player.level}"
        level_rect = pygame.Rect(self.level_down_button.rect.right, self.level_down_button.rect.top, 
                                 self.level_up_button.rect.left - self.level_down_button.rect.right, 60)
        draw_text(surface, level_text, self.game.fonts['large'], TEXT_COLOR, level_rect)
        # --- æ–°å¢ç»“æŸ ---

        # ç»˜åˆ¶å½“å‰é€‰æ‹©çš„æ•Œäºº
        selected_enemy_id = self.enemy_ids[self.selected_enemy_index]
        enemy_name = self.game.enemy_data[selected_enemy_id]['name']
        enemy_rect = pygame.Rect(self.prev_enemy_button.rect.right, self.prev_enemy_button.rect.top, 
                                 self.next_enemy_button.rect.left - self.prev_enemy_button.rect.right, 50)
        draw_text(surface, enemy_name, self.game.fonts['large'], TEXT_COLOR, enemy_rect)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\saving.py
================================================================================

# states/saving.py
import pygame
import time
from .base import BaseState
from ui import draw_text, Button
from settings import *

class SaveScreen(BaseState):
    def __init__(self, game):
        super().__init__(game)
        self.back_button = Button((SCREEN_WIDTH / 2 - 150, SCREEN_HEIGHT - 100, 300, 60), "è¿”å›", self.game.fonts['normal'])
        self.slot_rects = [pygame.Rect(100, 120 + (i-1) * 50, SCREEN_WIDTH - 200, 50) for i in range(1, 10)]
        self.feedback_message = None
        self.feedback_timer = 0

    def update(self):
        if self.feedback_message and pygame.time.get_ticks() - self.feedback_timer > 2000:
            self.feedback_message = None

    def handle_event(self, event):
        if self.back_button.handle_event(event) or (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
            self.game.state_stack.pop()
            return

        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            for i, rect in enumerate(self.slot_rects, 1):
                if rect.collidepoint(event.pos):
                    self.feedback_message = self.game.save_to_slot(i)
                    self.feedback_timer = pygame.time.get_ticks()
                    return

    def draw(self, surface):
        surface.fill(BG_COLOR)
        title_font = self.game.fonts['large']
        draw_text(surface, "é€‰æ‹©è¦è¦†ç›–çš„å­˜æ¡£æ§½", title_font, TEXT_COLOR, pygame.Rect(0, 50, SCREEN_WIDTH, 100))

        for i, rect in enumerate(self.slot_rects, 1):
            slot_data = self.game.peek_save_slot(i) # <-- ä½¿ç”¨ peek_save_slot
            is_hovered = rect.collidepoint(pygame.mouse.get_pos())
            if is_hovered:
                pygame.draw.rect(surface, PANEL_BORDER_COLOR, rect.inflate(10, 10), 2, border_radius=5)
            
            text = f"{i}. "
            if slot_data and slot_data.get("player"):
                player = slot_data["player"]
                save_time = time.strftime('%Y-%m-%d %H:%M', time.localtime(slot_data.get("timestamp", 0)))
                text += f"{player.name} - ç­‰çº§ {player.level} ({save_time})"
            else:
                text += "-- ç©º --"
            draw_text(surface, text, self.game.fonts['normal'], TEXT_COLOR, rect)

        if self.feedback_message:
            feedback_rect = pygame.Rect(0, SCREEN_HEIGHT - 150, SCREEN_WIDTH, 40)
            draw_text(surface, self.feedback_message, self.game.fonts['normal'], (100, 255, 100), feedback_rect)
        
        self.back_button.draw(surface)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\shop_screen.py
================================================================================


# states/shop_screen.py (ç°ä»£åŒ–é‡å†™ç‰ˆæœ¬ï¼Œå·²è¡¥å…¨)
import pygame
import random
import math
import inspect
from .base import BaseState
from ui import Button, TooltipManager
from settings import *
import Equips

# å®‰å…¨è·å– RARITY_COLORSï¼ˆé˜²æ­¢ settings æœªå®šä¹‰æ—¶å´©æºƒï¼‰
_DEFAULT_RARITY_COLORS = {
    "common": (180, 180, 180),
    "uncommon": (80, 200, 120),
    "rare": (80, 160, 255),
    "epic": (180, 80, 255),
    "legendary": (255, 180, 60),
}
try:
    RARITY_COLORS = dict(RARITY_COLORS)  # type: ignore
except Exception:
    RARITY_COLORS = _DEFAULT_RARITY_COLORS

RARITY_PRICES = {"common": 50, "uncommon": 100, "rare": 250, "epic": 500, "legendary": 1000}

class ShopScreen(BaseState):
    def __init__(self, game, origin_room):
        super().__init__(game)
        self.is_overlay = True
        self.origin_room = origin_room
        self.shop_items = []
        self.feedback_message = ""
        self.feedback_timer = 0
        
        # åŠ¨ç”»ç³»ç»Ÿ
        self.hover_animations = {}
        self.glow_animation = 0.0
        self.entrance_animation = 0.0
        self.coin_particles = []
        self.card_bounce_offsets = []
        
        self.tooltip_manager = TooltipManager(self._get_font('small', 16))
        
        self._generate_inventory()
        self._setup_ui()

    def _get_font(self, font_name, default_size=20):
        """å®‰å…¨è·å–å­—ä½“"""
        try:
            if hasattr(self.game, 'fonts') and font_name in self.game.fonts:
                return self.game.fonts[font_name]
        except Exception:
            pass
        return pygame.font.Font(None, default_size)

    def _generate_inventory(self):
        """ç”Ÿæˆå•†åº—ç‰©å“"""
        all_item_classes = [getattr(Equips, name) for name in dir(Equips) 
                           if isinstance(getattr(Equips, name), type) 
                           and issubclass(getattr(Equips, name), Equips.Equipment) 
                           and getattr(Equips, name) is not Equips.Equipment]
        
        choices = random.sample(all_item_classes, min(4, len(all_item_classes)))  # 4ä¸ªå•†å“
        
        for item_class in choices:
            item = item_class()
            rarity = getattr(item, 'rarity', 'common')
            base_price = RARITY_PRICES.get(rarity, 9999)
            # æ·»åŠ ä»·æ ¼æ³¢åŠ¨
            price_variation = random.uniform(0.85, 1.15)
            price = int(base_price * price_variation)
            self.shop_items.append([None, item, price, False])

    def _setup_ui(self):
        """è®¾ç½®UIå¸ƒå±€"""
        # åŠ¨æ€è°ƒæ•´é¢æ¿å¤§å°
        num_items = len(self.shop_items)
        card_width, card_height = 280, 380
        spacing = 25
        
        # è®¡ç®—å¸ƒå±€
        cards_per_row = min(4, num_items)
        rows = (num_items + cards_per_row - 1) // cards_per_row
        
        total_width = cards_per_row * card_width + (cards_per_row - 1) * spacing + 80
        total_height = rows * card_height + (rows - 1) * spacing + 200
        
        self.panel_rect = pygame.Rect(0, 0, total_width, total_height)
        self.panel_rect.center = (SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2)
        
        # åˆ›å»ºå•†å“å¡ç‰‡
        cards_start_x = self.panel_rect.x + 40
        cards_start_y = self.panel_rect.y + 120
        
        for i, item_tuple in enumerate(self.shop_items):
            row = i // cards_per_row
            col = i % cards_per_row
            
            # å¦‚æœæœ€åä¸€è¡Œå•†å“æ•°é‡ä¸è¶³ï¼Œå±…ä¸­æ˜¾ç¤º
            if row == rows - 1:
                items_in_last_row = num_items - row * cards_per_row
                if items_in_last_row < cards_per_row:
                    # è®¡ç®—å±…ä¸­åç§»
                    empty_slots = cards_per_row - items_in_last_row
                    center_offset = (empty_slots * (card_width + spacing)) // 2
                    card_x = cards_start_x + center_offset + col * (card_width + spacing)
                else:
                    card_x = cards_start_x + col * (card_width + spacing)
            else:
                card_x = cards_start_x + col * (card_width + spacing)
            
            card_y = cards_start_y + row * (card_height + spacing)
            card_rect = pygame.Rect(card_x, card_y, card_width, card_height)
            
            button = Button(card_rect, "", self._get_font('normal', 20))
            item_tuple[0] = button
            
            # åˆå§‹åŒ–åŠ¨ç”»
            self.hover_animations[i] = 0.0
            self.card_bounce_offsets.append(random.uniform(0, math.pi * 2))  # éšæœºç›¸ä½
        
        # ç¦»å¼€æŒ‰é’®
        leave_rect = pygame.Rect(self.panel_rect.centerx - 100, 
                                self.panel_rect.bottom - 60, 200, 45)
        self.leave_button = Button(leave_rect, "ç¦»å¼€å•†åº—", self._get_font('normal', 20))
        self.hover_animations['leave'] = 0.0

    def handle_event(self, event):
        """å¤„ç†äº‹ä»¶"""
        if self.entrance_animation < 1.0:
            return
        
        if self.leave_button.handle_event(event):
            self.origin_room.is_cleared = True
            from .dungeon_screen import DungeonScreen
            if len(self.game.state_stack) > 1 and isinstance(self.game.state_stack[-2], DungeonScreen):
                self.game.state_stack[-2].door_rects = self.game.state_stack[-2]._generate_doors()
            self.game.state_stack.pop()
            return
        
        for i, (button, item, price, is_sold) in enumerate(self.shop_items):
            if not is_sold and button.handle_event(event):
                if self.game.player.gold >= price:
                    # è´­ä¹°æˆåŠŸ
                    self.game.player.gold -= price
                    feedback = self.game.player.pickup_item(item)
                    
                    # åˆ›å»ºé‡‘å¸ç²’å­æ•ˆæœ
                    self._create_coin_particles(button.rect.center)
                    
                    if feedback:
                        from .notification_screen import NotificationScreen
                        self.game.state_stack.append(NotificationScreen(self.game, feedback))
                    
                    self.feedback_message = f"æˆåŠŸè´­ä¹° {getattr(item, 'display_name', 'ç‰©å“')}ï¼"
                    # å°†è¯¥å•†å“æ ‡è®°ä¸ºå·²å”®å‡º
                    self.shop_items[i][3] = True
                else:
                    self.feedback_message = "é‡‘å¸ä¸è¶³ï¼"
                    
                self.feedback_timer = pygame.time.get_ticks()
                return

    def _create_coin_particles(self, center):
        """åˆ›å»ºé‡‘å¸ç²’å­æ•ˆæœ"""
        for _ in range(18):
            particle = {
                'x': center[0] + random.uniform(-15, 15),
                'y': center[1] + random.uniform(-10, 10),
                'vx': random.uniform(-3.2, 3.2),
                'vy': random.uniform(-6, -2),
                'life': 60,
                'max_life': 60,
                'size': random.uniform(3, 7)
            }
            self.coin_particles.append(particle)

    def update(self):
        """æ›´æ–°åŠ¨ç”»å’ŒçŠ¶æ€"""
        current_time = pygame.time.get_ticks()
        if not hasattr(self, '_last_time'): 
            self._last_time = current_time
            
        dt_ms = current_time - self._last_time
        self._last_time = current_time
        dt_sec = dt_ms / 1000.0
        
        # å…¥åœºåŠ¨ç”»
        self.entrance_animation = min(1.0, self.entrance_animation + dt_sec * 2.5)
        
        # å‘å…‰åŠ¨ç”»
        self.glow_animation = (self.glow_animation + dt_sec * 2) % (2 * math.pi)
        
        # æ›´æ–°ç²’å­
        for particle in self.coin_particles[:]:
            particle['x'] += particle['vx']
            particle['y'] += particle['vy']
            particle['vy'] += 0.22  # é‡åŠ›
            particle['life'] -= 1
            if particle['life'] <= 0:
                self.coin_particles.remove(particle)
        
        # æ‚¬åœæ£€æµ‹å’ŒåŠ¨ç”»
        mouse_pos = pygame.mouse.get_pos()
        hovered_item = None
        
        # æ£€æŸ¥å•†å“å¡ç‰‡æ‚¬åœ
        for i, (button, item, price, is_sold) in enumerate(self.shop_items):
            if button.rect.collidepoint(mouse_pos) and not is_sold:
                self.hover_animations[i] = min(1.0, self.hover_animations[i] + dt_sec * 4.0)
                hovered_item = item
            else:
                self.hover_animations[i] = max(0.0, self.hover_animations[i] - dt_sec * 3.0)
        
        # æ£€æŸ¥ç¦»å¼€æŒ‰é’®æ‚¬åœ
        if self.leave_button.rect.collidepoint(mouse_pos):
            self.hover_animations['leave'] = min(1.0, self.hover_animations['leave'] + dt_sec * 4.0)
        else:
            self.hover_animations['leave'] = max(0.0, self.hover_animations['leave'] - dt_sec * 3.0)
        
        # æ›´æ–°tooltip
        self.tooltip_manager.update(hovered_item)
        
        # æ¸…é™¤è¿‡æœŸåé¦ˆæ¶ˆæ¯
        if self.feedback_message and current_time - self.feedback_timer > 2000:
            self.feedback_message = ""

    def draw(self, surface):
        """ç»˜åˆ¶ç•Œé¢"""
        # åŠé€æ˜é®ç½©
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, int(200 * self.entrance_animation)))
        surface.blit(overlay, (0, 0))
        
        # ä¸»é¢æ¿ï¼ˆå…¥åœºåŠ¨ç”»ï¼‰
        panel_rect = self.panel_rect.copy()
        if self.entrance_animation < 1.0:
            scale = 0.7 + 0.3 * self.entrance_animation
            panel_rect = pygame.Rect(0, 0, 
                                   int(self.panel_rect.width * scale),
                                   int(self.panel_rect.height * scale))
            panel_rect.center = (SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2)
        
        self._draw_modern_panel(surface, panel_rect, (25, 30, 50, 240))
        
        # ç»˜åˆ¶å„éƒ¨åˆ†
        self._draw_header(surface, panel_rect)
        self._draw_shop_items(surface)
        self._draw_leave_button(surface)
        self._draw_feedback(surface, panel_rect)
        self._draw_particles(surface)
        
        # ç»˜åˆ¶tooltip
        self.tooltip_manager.draw(surface)

    def _draw_modern_panel(self, surface, rect, color, border_color=None):
        """ç»˜åˆ¶ç°ä»£åŒ–é¢æ¿"""
        pygame.draw.rect(surface, color, rect, border_radius=15)
        if border_color is None: 
            border_color = (70, 80, 100, 200)
        pygame.draw.rect(surface, border_color, rect, width=3, border_radius=15)
        
        # å†…å‘å…‰æ•ˆæœ
        glow_rect = rect.inflate(-6, -6)
        pygame.draw.rect(surface, (255, 255, 255, 25), glow_rect, width=2, border_radius=12)

    def _draw_header(self, surface, panel_rect):
        """ç»˜åˆ¶å•†åº—æ ‡é¢˜å’Œé‡‘å¸æ˜¾ç¤º"""
        header_rect = pygame.Rect(panel_rect.x + 30, panel_rect.y + 20, 
                                 panel_rect.width - 60, 80)
        
        # æ ‡é¢˜èƒŒæ™¯
        self._draw_modern_panel(surface, header_rect, (35, 40, 65, 180), (100, 120, 150))
        
        # å•†åº—æ ‡é¢˜
        title_font = self._get_font('large', 32)
        title_text = "âœ¨ ç¥ç§˜å•†åº— âœ¨"
        title_surface = title_font.render(title_text, True, (255, 215, 0))
        title_rect = title_surface.get_rect(x=header_rect.x + 25, centery=header_rect.centery - 10)
        surface.blit(title_surface, title_rect)
        
        # é‡‘å¸æ˜¾ç¤º
        gold_font = self._get_font('normal', 24)
        gold_text = f"ğŸ’° {self.game.player.gold} G"
        gold_surface = gold_font.render(gold_text, True, (255, 215, 0))
        gold_rect = gold_surface.get_rect(right=header_rect.right - 25, centery=header_rect.centery - 10)
        
        # é‡‘å¸èƒŒæ™¯
        gold_bg = gold_rect.inflate(20, 10)
        pygame.draw.rect(surface, (50, 40, 20, 150), gold_bg, border_radius=8)
        pygame.draw.rect(surface, (255, 215, 0, 100), gold_bg, width=2, border_radius=8)
        surface.blit(gold_surface, gold_rect)
        
        # å‰¯æ ‡é¢˜
        subtitle_font = self._get_font('small', 16)
        subtitle_text = "ç²¾é€‰è£…å¤‡ï¼Œç‰©è¶…æ‰€å€¼ï¼"
        subtitle_surface = subtitle_font.render(subtitle_text, True, (180, 180, 180))
        subtitle_rect = subtitle_surface.get_rect(x=header_rect.x + 25, top=title_rect.bottom + 5)
        surface.blit(subtitle_surface, subtitle_rect)

    def _draw_shop_items(self, surface):
        """ç»˜åˆ¶å•†åº—ç‰©å“"""
        current_time = pygame.time.get_ticks()
        
        for i, (button, item, price, is_sold) in enumerate(self.shop_items):
            # è®¡ç®—å…¥åœºåŠ¨ç”»åç§»
            entrance_delay = i * 0.1
            entrance_progress = max(0.0, min(1.0, (self.entrance_animation - entrance_delay) / 0.8))
            entrance_offset = (1.0 - entrance_progress) * 50.0
            
            # è®¡ç®—æµ®åŠ¨åç§»
            bounce_phase = self.card_bounce_offsets[i] + current_time * 0.001
            bounce_offset = math.sin(bounce_phase) * 2.0 if not is_sold else 0.0
            
            # è°ƒæ•´å¡ç‰‡ä½ç½®
            card_rect = button.rect.copy()
            card_rect.y += int(entrance_offset + bounce_offset)
            
            # ç»˜åˆ¶å•†å“å¡ç‰‡
            hover_alpha = self.hover_animations[i]
            self._draw_item_card(surface, card_rect, item, price, is_sold, hover_alpha)

    def _wrap_text(self, font, text, max_width, max_lines=None):
        """åŸºäºåƒç´ å®½åº¦çš„ç®€å•è‡ªåŠ¨æ¢è¡Œï¼Œè¿”å›è¡Œåˆ—è¡¨"""
        words = text.split()
        lines = []
        cur = ""
        for w in words:
            test = (cur + " " + w).strip()
            if font.size(test)[0] <= max_width:
                cur = test
            else:
                if cur:
                    lines.append(cur)
                cur = w
                if max_lines and len(lines) >= max_lines:
                    break
        if cur and (not max_lines or len(lines) < max_lines):
            lines.append(cur)
        return lines

    def _draw_item_card(self, surface, rect, item, price, is_sold, hover_alpha):
        """ç»˜åˆ¶å•ä¸ªå•†å“å¡ç‰‡"""
        # è·å–ç‰©å“ä¿¡æ¯
        name = getattr(item, 'display_name', 'æœªçŸ¥ç‰©å“')
        rarity = getattr(item, 'rarity', 'common')
        rarity_color = RARITY_COLORS.get(rarity, RARITY_COLORS.get('common', (180,180,180)))
        
        # å¡ç‰‡çŠ¶æ€
        if is_sold:
            bg_alpha = 60
            border_alpha = 80
            text_color = (200, 200, 200)
            scale = 0.95
        else:
            bg_alpha = int(140 + hover_alpha * 40)
            border_alpha = int(180 + hover_alpha * 75)
            text_color = (255, 255, 255)
            scale = 1.0 + hover_alpha * 0.03
        
        # ç¼©æ”¾æ•ˆæœ
        target_rect = rect
        if scale != 1.0:
            scaled_size = (int(rect.width * scale), int(rect.height * scale))
            scaled_rect = pygame.Rect(0, 0, *scaled_size)
            scaled_rect.center = rect.center
            target_rect = scaled_rect
        
        # å¡ç‰‡èƒŒæ™¯
        card_color = (*rarity_color, bg_alpha) if not is_sold else (60, 60, 60, bg_alpha)
        border_color = (*rarity_color, border_alpha) if not is_sold else (80, 80, 80, border_alpha)
        
        pygame.draw.rect(surface, card_color, target_rect, border_radius=12)
        pygame.draw.rect(surface, border_color, target_rect, width=3, border_radius=12)
        
        # ç¨€æœ‰åº¦è£…é¥°
        decoration_rect = pygame.Rect(target_rect.x, target_rect.y, target_rect.width, 8)
        decoration_color = rarity_color if not is_sold else (80, 80, 80)
        pygame.draw.rect(surface, decoration_color, decoration_rect, 
                        border_top_left_radius=12, border_top_right_radius=12)
        
        # å‘å…‰æ•ˆæœï¼ˆæ‚¬åœä¸”æœªå”®å‡ºï¼‰
        if hover_alpha > 0 and not is_sold:
            glow_intensity = int((math.sin(self.glow_animation) + 1) * hover_alpha * 25 + 15)
            glow_surface = pygame.Surface(target_rect.size, pygame.SRCALPHA)
            pygame.draw.rect(glow_surface, (*rarity_color, glow_intensity), 
                           (0, 0, target_rect.width, target_rect.height), border_radius=12)
            surface.blit(glow_surface, target_rect.topleft)
        
        # å·²å”®å‡ºæ ‡è®°
        if is_sold:
            sold_font = self._get_font('large', 28)
            sold_text = sold_font.render("å·²å”®ç½„", True, (255, 100, 100))
            sold_rect = sold_text.get_rect(center=target_rect.center)
            
            # åŠé€æ˜èƒŒæ™¯
            sold_bg = sold_rect.inflate(30, 15)
            pygame.draw.rect(surface, (0, 0, 0, 150), sold_bg, border_radius=8)
            pygame.draw.rect(surface, (255, 100, 100), sold_bg, width=2, border_radius=8)
            surface.blit(sold_text, sold_rect)
            return
        
        # ç‰©å“åç§°
        name_font = self._get_font('normal', 18)
        display_name = name
        if name_font.size(display_name)[0] > target_rect.width - 20:
            while name_font.size(display_name + "...")[0] > target_rect.width - 20 and len(display_name) > 1:
                display_name = display_name[:-1]
            display_name += "..."
        
        name_surface = name_font.render(display_name, True, text_color)
        name_rect = name_surface.get_rect(centerx=target_rect.centerx, top=target_rect.top + 18)
        
        # åç§°èƒŒæ™¯
        name_bg_rect = name_rect.inflate(16, 6)
        pygame.draw.rect(surface, (0, 0, 0, 100), name_bg_rect, border_radius=4)
        surface.blit(name_surface, name_rect)
        
        # ç¨€æœ‰åº¦æ ‡ç­¾
        rarity_font = self._get_font('small', 14)
        rarity_text = str(rarity).upper()
        rarity_surface = rarity_font.render(rarity_text, True, rarity_color)
        rarity_rect = rarity_surface.get_rect(centerx=target_rect.centerx, top=name_rect.bottom + 6)
        surface.blit(rarity_surface, rarity_rect)
        
        # åˆ†å‰²çº¿
        line_y = rarity_rect.bottom + 10
        pygame.draw.line(surface, (100, 100, 100), 
                        (target_rect.x + 15, line_y), (target_rect.right - 15, line_y), 1)
        
        # ç‰©å“æè¿°ï¼ˆåŸºäº docstring çš„ç®€è¦ä¿¡æ¯ï¼‰
        description = inspect.getdoc(item) or getattr(item, 'description', '') or "ç¥ç§˜çš„è£…å¤‡"
        desc_words = description.split()
        # é™åˆ¶å­—æ•°å¹¶è‡ªåŠ¨æ¢è¡Œ
        desc_text = " ".join(desc_words[:40]) + ("..." if len(desc_words) > 40 else "")
        desc_area = pygame.Rect(target_rect.x + 14, line_y + 8, target_rect.width - 28, target_rect.height - (line_y + 8) - 80)
        desc_font = self._get_font('small', 14)
        lines = self._wrap_text(desc_font, desc_text, desc_area.width, max_lines=5)
        y = desc_area.y
        for ln in lines:
            surf = desc_font.render(ln, True, (220, 220, 220))
            surface.blit(surf, (desc_area.x, y))
            y += desc_font.get_height() + 2
        
        # åº•éƒ¨ä»·æ ¼æŒ‰é’®åŒº
        price_area = pygame.Rect(target_rect.x + 12, target_rect.bottom - 64, target_rect.width - 24, 50)
        if self.game.player.gold < price:
            btn_bg = (40, 30, 30, 160)
            btn_border = (150, 80, 80)
            price_text = f"é‡‘å¸ä¸è¶³ï¼ˆ{price} Gï¼‰"
            price_color = (230, 120, 120)
        else:
            # æ‚¬åœå¢å¼º
            hover = hover_alpha if hover_alpha > 0 else 0.0
            base_alpha = 160 + int(60 * hover)
            btn_bg = (30, 40, 30, base_alpha)
            btn_border = (80, 200, 120)
            price_text = f"è´­ä¹°ï¼ˆ{price} Gï¼‰"
            price_color = (200, 255, 200)
        
        # ç»˜åˆ¶æŒ‰é’®æ„Ÿ
        pygame.draw.rect(surface, btn_bg, price_area, border_radius=10)
        pygame.draw.rect(surface, btn_border, price_area, width=2, border_radius=10)
        
        price_font = self._get_font('normal', 20)
        price_surf = price_font.render(price_text, True, price_color)
        price_rect = price_surf.get_rect(center=price_area.center)
        surface.blit(price_surf, price_rect)
        
        # è´­ä¹°æç¤º
        hint_font = self._get_font('small', 14)
        hint_text = "ç‚¹å‡»å¡ç‰‡ä»¥è´­ä¹°" if self.game.player.gold >= price else "å»å†’é™©èµšç‚¹é’±å§"
        hint_surf = hint_font.render(hint_text, True, (180, 180, 180))
        hint_rect = hint_surf.get_rect(midtop=(price_area.centerx, price_area.bottom + 2))
        surface.blit(hint_surf, hint_rect)

    def _draw_leave_button(self, surface):
        rect = self.leave_button.rect.copy()
        hover = self.hover_animations.get('leave', 0.0)
        bg = (35, 45, 70, int(200 + 40 * hover))
        border = (120, 140, 170)
        text_color = (255, 255, 255)
        
        # èƒŒæ™¯
        pygame.draw.rect(surface, bg, rect, border_radius=10)
        pygame.draw.rect(surface, border, rect, width=2, border_radius=10)
        
        # æ–‡æœ¬
        font = self._get_font('normal', 22)
        txt = font.render("ç¦»å¼€å•†åº—", True, text_color)
        surface.blit(txt, txt.get_rect(center=rect.center))

    def _draw_feedback(self, surface, panel_rect):
        if not self.feedback_message:
            return
        msg_font = self._get_font('small', 18)
        msg_surf = msg_font.render(self.feedback_message, True, (255, 230, 150))
        msg_rect = msg_surf.get_rect(centerx=panel_rect.centerx, y=panel_rect.top + 95)
        # èƒŒæ™¯
        bg = msg_rect.inflate(16, 8)
        pygame.draw.rect(surface, (0, 0, 0, 140), bg, border_radius=8)
        pygame.draw.rect(surface, (255, 215, 0), bg, width=2, border_radius=8)
        surface.blit(msg_surf, msg_rect)

    def _draw_particles(self, surface):
        for p in self.coin_particles:
            # life-based alpha
            alpha = max(0, min(255, int(255 * (p['life'] / p['max_life']))))
            coin = pygame.Surface((int(p['size']*2), int(p['size']*2)), pygame.SRCALPHA)
            pygame.draw.circle(coin, (255, 215, 0, alpha), (int(p['size']), int(p['size'])), int(p['size']))
            surface.blit(coin, (p['x']-p['size'], p['y']-p['size']))



================================================================================
### æ–‡ä»¶è·¯å¾„: states\story.py
================================================================================

# æ–‡ä»¶: states/story.py (å®Œæ•´æ›¿æ¢)

import pygame
from .base import BaseState
from .dungeon_screen import DungeonScreen
from .saving import SaveScreen
from .loading import LoadScreen
from .backpack import BackpackScreen
from .talents_screen import TalentsScreen
from ui import draw_text, Button
from settings import *

class StoryScreen(BaseState):
    def __init__(self, game):
        super().__init__(game)
        
        # --- æ ¸å¿ƒä¿®æ”¹ 1: é‡æ–°å¸ƒå±€ï¼Œä¸ºâ€œå¤©èµ‹â€æŒ‰é’®è…¾å‡ºç©ºé—´ ---
        button_w, button_h = 120, 40
        padding = 15
        # ä»å³å¾€å·¦ä¾æ¬¡æ˜¯ ä¿å­˜ -> åŠ è½½ -> èƒŒåŒ… -> å¤©èµ‹
        save_rect = pygame.Rect(SCREEN_WIDTH - padding - button_w, SCREEN_HEIGHT - padding - button_h - 250, button_w, button_h)
        load_rect = pygame.Rect(save_rect.left - padding - button_w, save_rect.top, button_w, button_h)
        backpack_rect = pygame.Rect(load_rect.left - padding - button_w, load_rect.top, button_w, button_h)
        talents_rect = pygame.Rect(backpack_rect.left - padding - button_w, backpack_rect.top, button_w, button_h)
        
        self.buttons = {
            "save": Button(save_rect, "ä¿å­˜(S)", self.game.fonts['small']),
            "load": Button(load_rect, "åŠ è½½(L)", self.game.fonts['small']),
            "backpack": Button(backpack_rect, "èƒŒåŒ…(B)", self.game.fonts['small']),
            "talents": Button(talents_rect, "å¤©èµ‹(T)", self.game.fonts['small']) # <-- æ–°å¢å¤©èµ‹æŒ‰é’®
        }
        self._initialize_story()

    def _initialize_story(self):
        start_index = getattr(self.game, "loaded_dialogue_index", 0)
        self.dialogue_index = start_index
        self.displayed_chars = 0
        self.typing_complete = False
        self.last_char_time = 0
        self.typewriter_speed = 30
        self.game.loaded_dialogue_index = 0

    def update(self):
        if not self.typing_complete:
            now = pygame.time.get_ticks()
            if now - self.last_char_time > self.typewriter_speed:
                stage_data = self.game.story_data.get(self.game.current_stage, {})
                dialogue_list = stage_data.get("text", [])
                if not dialogue_list or self.dialogue_index >= len(dialogue_list):
                    self.typing_complete = True
                    return
                line = dialogue_list[self.dialogue_index].get("line", "")
                if self.displayed_chars < len(line):
                    self.displayed_chars += 1
                    self.last_char_time = now
                else:
                    self.typing_complete = True
    
    def handle_event(self, event):
        # --- æ ¸å¿ƒä¿®æ”¹ 2: å¢åŠ å¯¹æ–°æŒ‰é’®å’Œå¿«æ·é”®çš„å¤„ç† ---
        if self.buttons['save'].handle_event(event):
            self.game.state_stack.append(SaveScreen(self.game))
            return
        if self.buttons['load'].handle_event(event):
            self.game.state_stack.append(LoadScreen(self.game))
            return
        if self.buttons['backpack'].handle_event(event):
            self.game.state_stack.append(BackpackScreen(self.game))
            return
        # <-- æ–°å¢ï¼šå¤„ç†å¤©èµ‹æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        if self.buttons['talents'].handle_event(event):
            self.game.state_stack.append(TalentsScreen(self.game))
            return

        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            is_over_button = any(btn.rect.collidepoint(event.pos) for btn in self.buttons.values())
            if not is_over_button:
                self._advance_dialogue()
        
        if event.type == pygame.KEYDOWN:
            if event.key in [pygame.K_RETURN, pygame.K_SPACE]:
                self._advance_dialogue()
            elif event.key == pygame.K_s:
                self.game.state_stack.append(SaveScreen(self.game))
            elif event.key == pygame.K_l:
                self.game.state_stack.append(LoadScreen(self.game))
            elif event.key == pygame.K_b:
                self.game.state_stack.append(BackpackScreen(self.game))
            # <-- æ–°å¢ï¼šå¤„ç†å¤©èµ‹å¿«æ·é”® 'T'
            elif event.key == pygame.K_t:
                self.game.state_stack.append(TalentsScreen(self.game))

    def _advance_dialogue(self):
        from .combat import CombatScreen
        from .title import TitleScreen

        stage_data = self.game.story_data.get(self.game.current_stage)
        if not stage_data:
            self.game.state_stack = [TitleScreen(self.game)]
            return
            
        dialogue_list = stage_data.get("text", [])

        if not self.typing_complete:
            self.typing_complete = True
            if self.dialogue_index < len(dialogue_list):
                current_line = dialogue_list[self.dialogue_index].get("line", "")
                self.displayed_chars = len(current_line)
            return

        if self.dialogue_index < len(dialogue_list):
            current_dialogue = dialogue_list[self.dialogue_index]
            action = current_dialogue.get("action")
            if action == "start_trial":
                self.game.state_stack.pop()
                self.game.state_stack.append(DungeonScreen(self.game, "sunstone_ruins", 1))
                return

        self.dialogue_index += 1

        if self.dialogue_index >= len(dialogue_list):
            self.game.current_stage = stage_data.get("next", "quit")
            if self.game.current_stage == "quit":
                self.game.state_stack = [TitleScreen(self.game)]
                return
            
            next_stage_data = self.game.story_data.get(self.game.current_stage, {})
            if next_stage_data.get("type") == "combat":
                enemy_id = next_stage_data.get("enemy_id", "slime")
                self.game.state_stack.pop()
                self.game.state_stack.append(CombatScreen(self.game, enemy_id))
            else:
                self._initialize_story()
        else:
            self.displayed_chars = 0
            self.typing_complete = False
            self.last_char_time = 0

    def draw(self, surface):
        surface.fill(BG_COLOR)
        dialogue_box_rect = pygame.Rect(50, SCREEN_HEIGHT - 250, SCREEN_WIDTH - 100, 200)
        pygame.draw.rect(surface, PANEL_BG_COLOR, dialogue_box_rect, border_radius=10)
        pygame.draw.rect(surface, PANEL_BORDER_COLOR, dialogue_box_rect, 3, border_radius=10)

        stage_data = self.game.story_data.get(self.game.current_stage, {})
        dialogue_list = stage_data.get("text", [{"speaker": "é”™è¯¯", "line": "æœªæ‰¾åˆ°å‰§æƒ…æ–‡æœ¬"}])
        safe_index = min(self.dialogue_index, len(dialogue_list) - 1)
        dialogue = dialogue_list[safe_index]
        speaker, full_line = dialogue["speaker"], dialogue["line"]
        if speaker != "æ—ç™½":
            speaker_text_surf = self.game.fonts['normal'].render(speaker, True, TEXT_COLOR)
            speaker_panel_rect = speaker_text_surf.get_rect(topleft=(dialogue_box_rect.left + 30, dialogue_box_rect.top - 35))
            speaker_panel_rect.inflate_ip(20, 10)
            pygame.draw.rect(surface, PANEL_BG_COLOR, speaker_panel_rect, border_radius=5)
            pygame.draw.rect(surface, PANEL_BORDER_COLOR, speaker_panel_rect, 2, border_radius=5)
            surface.blit(speaker_text_surf, (speaker_panel_rect.x + 10, speaker_panel_rect.y + 5))
        text_to_render = full_line[:self.displayed_chars]
        text_rect = dialogue_box_rect.inflate(-40, -40)
        draw_text(surface, text_to_render, self.game.fonts['normal'], TEXT_COLOR, text_rect)
        if self.typing_complete:
            prompt_pos = (dialogue_box_rect.right - 40, dialogue_box_rect.bottom - 40)
            pygame.draw.polygon(surface, TEXT_COLOR, [prompt_pos, (prompt_pos[0] - 20, prompt_pos[1]), (prompt_pos[0] - 10, prompt_pos[1] - 15)])
        
        # ç»˜åˆ¶æ‰€æœ‰æŒ‰é’® (ä¼šè‡ªåŠ¨åŒ…å«æ–°æŒ‰é’®ï¼Œæ— éœ€ä¿®æ”¹)
        for button in self.buttons.values():
            button.draw(surface)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\talents_screen.py
================================================================================

# æ–‡ä»¶: states/talents_screen.py (å®Œå…¨é‡å†™çš„ç°ä»£åŒ–ç‰ˆæœ¬)

import pygame
import math
import inspect
from .base import BaseState
from ui import draw_text, Button, get_display_name, TooltipManager
from settings import *

# å¤©èµ‹ç¨€æœ‰åº¦é¢œè‰²é…ç½®
TALENT_RARITY_COLORS = {
    "common": (156, 163, 175),
    "uncommon": (16, 185, 129), 
    "rare": (59, 130, 246),
    "epic": (139, 92, 246),
    "legendary": (245, 158, 11)
}

class TalentsScreen(BaseState):
    def __init__(self, game, player_override=None):
        super().__init__(game)
        self.player = player_override or self.game.player
        self.is_overlay = True
        self.dragging_talent = None
        self.dragging_from_info = None
        
        # åŠ¨ç”»ç³»ç»Ÿ
        self.hover_animation = {}
        self.glow_animation = 0
        self.pulse_animation = 0
        
        self._setup_layout()
        self.tooltip_manager = TooltipManager(self.game.fonts['small'])
        
    def _get_font(self, font_name, default_size=20):
        """å®‰å…¨è·å–å­—ä½“"""
        try:
            if hasattr(self.game, 'fonts') and font_name in self.game.fonts:
                return self.game.fonts[font_name]
        except:
            pass
        return pygame.font.Font(None, default_size)

    def _setup_layout(self):
        margin, header_height = 40, 80
        self.container_rect = pygame.Rect(margin, margin, SCREEN_WIDTH - 2*margin, SCREEN_HEIGHT - 2*margin)
        self.header_rect = pygame.Rect(self.container_rect.x, self.container_rect.y, 
                                     self.container_rect.width, header_height)
        
        content_y = self.header_rect.bottom + 15
        content_height = self.container_rect.height - header_height - 15
        
        # å·¦ä¾§ï¼šå·²è£…å¤‡å¤©èµ‹é¢æ¿
        panel_width = 380
        self.equipped_panel_rect = pygame.Rect(self.container_rect.x, content_y, 
                                             panel_width, content_height)
        
        # å³ä¾§ï¼šå¤©èµ‹åº“é¢æ¿  
        self.learned_panel_rect = pygame.Rect(self.equipped_panel_rect.right + 20, content_y,
                                            self.container_rect.right - self.equipped_panel_rect.right - 20, 
                                            content_height)
        
        # å…³é—­æŒ‰é’®
        self.close_button = Button(
            pygame.Rect(self.container_rect.right - 50, self.container_rect.top + 15, 40, 40), 
            "Ã—", self._get_font('large', 24)
        )

    def handle_event(self, event):
        if self.close_button.handle_event(event) or (event.type == pygame.KEYDOWN and event.key in [pygame.K_ESCAPE, pygame.K_t]):
            if self.dragging_talent:
                self._return_dragging_talent()
            self.game.state_stack.pop()
            return
            
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            self._handle_mouse_down(event.pos)
        if event.type == pygame.MOUSEBUTTONUP and event.button == 1:
            self._handle_mouse_up(event.pos)
        if event.type == pygame.MOUSEMOTION:
            self._handle_mouse_motion(event.pos)

    def _handle_mouse_down(self, pos):
        if self.dragging_talent: 
            return
        
        # ä»å·²è£…å¤‡æ§½æ‹¾èµ·
        for i, talent in enumerate(self.player.equipped_talents):
            if talent is not None:
                rect = self._get_talent_rect(i, 'equipped')
                if rect.collidepoint(pos):
                    self.dragging_talent = talent
                    self.dragging_from_info = {'type': 'equipped', 'index': i}
                    self.player.unequip_talent(talent)
                    return
        
        # ä»å¤©èµ‹åº“æ‹¾èµ·
        unequipped = [t for t in self.player.learned_talents if t not in self.all_equipped_talents]
        for i, talent in enumerate(unequipped):
            rect = self._get_talent_rect(i, 'learned')
            if rect.collidepoint(pos):
                self.dragging_talent = talent
                self.dragging_from_info = {'type': 'learned'}
                return

    def _handle_mouse_up(self, pos):
        if not self.dragging_talent: 
            return

        talent_to_place = self.dragging_talent
        source_info = self.dragging_from_info
        
        # é‡ç½®æ‹–æ‹½çŠ¶æ€
        self.dragging_talent = None
        self.dragging_from_info = None

        # æ£€æŸ¥æ˜¯å¦æ”¾ç½®åœ¨è£…å¤‡æ§½
        for i in range(self.player.max_talent_slots):
            rect = self._get_talent_rect(i, 'equipped')
            if rect.collidepoint(pos):
                target_talent = self.player.equipped_talents[i]
                
                if target_talent:
                    self.player.unequip_talent(target_talent)
                
                self.player.equip_talent(talent_to_place, specific_index=i)
                
                if target_talent and source_info['type'] == 'equipped':
                    self.player.equip_talent(target_talent, specific_index=source_info['index'])
                
                self.player.recalculate_stats()
                return

        # æ£€æŸ¥æ˜¯å¦æ”¾ç½®åœ¨å¤©èµ‹åº“
        if self.learned_panel_rect.collidepoint(pos):
            self.player.recalculate_stats()
            return

        # æ— æ•ˆæ“ä½œï¼Œè¿”å›åŸå¤„
        self._return_dragging_talent(talent_to_place, source_info)
        self.player.recalculate_stats()

    def _handle_mouse_motion(self, pos):
        """å¤„ç†é¼ æ ‡æ‚¬åœåŠ¨ç”»"""
        # é‡ç½®æ‰€æœ‰æ‚¬åœçŠ¶æ€
        for key in list(self.hover_animation.keys()):
            if key not in ['mouse_pos']:
                self.hover_animation[key] = max(0, self.hover_animation[key] - 0.1)
        
        # æ£€æŸ¥è£…å¤‡æ§½æ‚¬åœ
        for i in range(self.player.max_talent_slots):
            rect = self._get_talent_rect(i, 'equipped')
            if rect.collidepoint(pos):
                self.hover_animation[f'equipped_{i}'] = min(1.0, self.hover_animation.get(f'equipped_{i}', 0) + 0.15)
        
        # æ£€æŸ¥å¤©èµ‹åº“æ‚¬åœ
        unequipped = [t for t in self.player.learned_talents if t not in self.all_equipped_talents]
        for i, talent in enumerate(unequipped):
            rect = self._get_talent_rect(i, 'learned')
            if rect.collidepoint(pos):
                self.hover_animation[f'learned_{i}'] = min(1.0, self.hover_animation.get(f'learned_{i}', 0) + 0.15)

    def _return_dragging_talent(self, talent_to_return, source_info):
        """å°†å¤©èµ‹è¿”å›åŸå¤„"""
        if source_info and source_info['type'] == 'equipped':
            self.player.equip_talent(talent_to_return, specific_index=source_info['index'])

    def update(self, dt=0):
        """æ›´æ–°åŠ¨ç”»"""
        current_time = pygame.time.get_ticks()
        if not hasattr(self, '_last_time'): 
            self._last_time = current_time
            
        dt_ms = current_time - self._last_time
        self._last_time = current_time
        dt_sec = dt_ms / 1000.0
        
        self.glow_animation = (self.glow_animation + dt_sec * 2) % (2 * math.pi)
        self.pulse_animation = (self.pulse_animation + dt_sec * 1.5) % (2 * math.pi)
        
        # æ›´æ–°æ‚¬åœæ£€æµ‹
        if self.dragging_talent:
            self.tooltip_manager.update(None)
            return
        
        hovered_talent = None
        mouse_pos = pygame.mouse.get_pos()
        
        all_panels = [('equipped', self.all_equipped_talents), 
                      ('learned', [t for t in self.player.learned_talents if t not in self.all_equipped_talents])]

        for panel_type, talent_list in all_panels:
            for i, talent in enumerate(talent_list):
                if talent is None: 
                    continue
                rect = self._get_talent_rect(i, panel_type)
                if rect.collidepoint(mouse_pos):
                    hovered_talent = talent
                    break
            if hovered_talent: 
                break
        
        self.tooltip_manager.update(hovered_talent)

    def _get_talent_rect(self, index, panel_type):
        """è·å–å¤©èµ‹å¡ç‰‡çŸ©å½¢"""
        panel_rect = self.equipped_panel_rect if panel_type == 'equipped' else self.learned_panel_rect
        
        if panel_type == 'equipped':
            # è£…å¤‡æ§½ä½¿ç”¨ç‰¹æ®Šå¸ƒå±€
            padding, slot_size, spacing = 25, 80, 15
            cols = 3
            col, row = index % cols, index // cols
            x = panel_rect.left + padding + col * (slot_size + spacing)
            y = panel_rect.top + 120 + row * (slot_size + spacing)
            return pygame.Rect(x, y, slot_size, slot_size)
        else:
            # å¤©èµ‹åº“ä½¿ç”¨ç½‘æ ¼å¸ƒå±€
            padding, item_size, spacing = 20, 70, 12
            cols = max(1, (panel_rect.width - 2 * padding + spacing) // (item_size + spacing))
            col, row = index % cols, index // cols
            x = panel_rect.left + padding + col * (item_size + spacing)
            y = panel_rect.top + 120 + row * (item_size + spacing)
            return pygame.Rect(x, y, item_size, item_size)

    def draw(self, surface):
        # åŠé€æ˜é®ç½©
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        # ä¸»å®¹å™¨
        self._draw_modern_panel(surface, self.container_rect, (25, 30, 50, 240))
        
        # ç»˜åˆ¶å„éƒ¨åˆ†
        self._draw_header(surface)
        self._draw_equipped_panel(surface)
        self._draw_learned_panel(surface)
        self._draw_dragging_talent(surface)
        
        self.close_button.draw(surface)
        self.tooltip_manager.draw(surface)
        
        # æ›´æ–°åŠ¨ç”»
        if hasattr(self, 'update'): 
            self.update()

    def _draw_modern_panel(self, surface, rect, color, border_color=None):
        """ç»˜åˆ¶ç°ä»£åŒ–é¢æ¿"""
        pygame.draw.rect(surface, color, rect, border_radius=12)
        if border_color is None: 
            border_color = (70, 80, 100, 180)
        pygame.draw.rect(surface, border_color, rect, width=2, border_radius=12)
        
        # å†…å‘å…‰æ•ˆæœ
        glow_rect = rect.inflate(-4, -4)
        pygame.draw.rect(surface, (255, 255, 255, 15), glow_rect, width=1, border_radius=10)

    def _draw_header(self, surface):
        """ç»˜åˆ¶æ ‡é¢˜åŒºåŸŸ"""
        header_bg = self.header_rect.inflate(-10, -10)
        self._draw_modern_panel(surface, header_bg, (35, 40, 65, 200))
        
        title_font = self._get_font('large', 32)
        title_text = title_font.render("å¤©èµ‹ç®¡ç†ç³»ç»Ÿ", True, (255, 215, 0))
        title_rect = title_text.get_rect(x=header_bg.x + 25, centery=header_bg.centery)
        surface.blit(title_text, title_rect)
        
        # å¤©èµ‹ç‚¹æ•°æ˜¾ç¤º
        if hasattr(self.player, 'talent_points'):
            points_text = f"å¤©èµ‹ç‚¹: {self.player.talent_points}"
            points_font = self._get_font('normal', 20)
            points_surface = points_font.render(points_text, True, (100, 255, 100))
            points_rect = points_surface.get_rect(right=header_bg.right - 25, centery=header_bg.centery)
            surface.blit(points_surface, points_rect)

    def _draw_equipped_panel(self, surface):
        """ç»˜åˆ¶å·²è£…å¤‡å¤©èµ‹é¢æ¿"""
        panel_bg = self.equipped_panel_rect.inflate(-8, -8)
        self._draw_modern_panel(surface, panel_bg, (30, 35, 55, 200))
        
        # æ ‡é¢˜
        title = f"å·²è£…å¤‡å¤©èµ‹ ({len(self.all_equipped_talents)}/{self.player.max_talent_slots})"
        title_rect = pygame.Rect(panel_bg.x + 20, panel_bg.y + 20, panel_bg.width - 40, 50)
        title_font = self._get_font('normal', 22)
        title_surface = title_font.render(title, True, (255, 215, 0))
        surface.blit(title_surface, title_rect)
        
        # åˆ†å‰²çº¿
        line_y = title_rect.bottom + 15
        pygame.draw.line(surface, (70, 80, 100), 
                        (panel_bg.x + 20, line_y), (panel_bg.right - 20, line_y), 2)
        
        # è£…å¤‡æ§½
        for i in range(self.player.max_talent_slots):
            rect = self._get_talent_rect(i, 'equipped')
            hover_alpha = self.hover_animation.get(f'equipped_{i}', 0)
            
            # æ§½ä½èƒŒæ™¯
            slot_color = (40, 50, 70, 120 + int(hover_alpha * 60))
            border_color = (70, 80, 100, 180 + int(hover_alpha * 75))
            
            # æ·»åŠ æ‚¬åœåŠ¨ç”»åç§»
            if hover_alpha > 0:
                offset = int(math.sin(self.pulse_animation) * hover_alpha * 3)
                rect = rect.move(0, offset)
            
            pygame.draw.rect(surface, slot_color, rect, border_radius=10)
            pygame.draw.rect(surface, border_color, rect, width=2, border_radius=10)
            
            # è£…å¤‡çš„å¤©èµ‹
            if i < len(self.player.equipped_talents):
                talent = self.player.equipped_talents[i]
                if talent and talent != self.dragging_talent:
                    self._draw_talent_card(surface, rect, talent, hover_alpha > 0.5)
                elif not talent:
                    # ç©ºæ§½æç¤º
                    plus_font = self._get_font('large', 36)
                    plus_text = plus_font.render("+", True, (100, 100, 100, 150))
                    plus_rect = plus_text.get_rect(center=rect.center)
                    surface.blit(plus_text, plus_rect)

    def _draw_learned_panel(self, surface):
        """ç»˜åˆ¶å¤©èµ‹åº“é¢æ¿"""
        panel_bg = self.learned_panel_rect.inflate(-8, -8)
        self._draw_modern_panel(surface, panel_bg, (30, 35, 55, 200))
        
        # æ ‡é¢˜
        unequipped_count = len([t for t in self.player.learned_talents if t not in self.all_equipped_talents])
        title = f"å¤©èµ‹åº“ ({unequipped_count} ä¸ªå¯ç”¨)"
        title_rect = pygame.Rect(panel_bg.x + 20, panel_bg.y + 20, panel_bg.width - 40, 50)
        title_font = self._get_font('normal', 22)
        title_surface = title_font.render(title, True, (255, 215, 0))
        surface.blit(title_surface, title_rect)
        
        # åˆ†å‰²çº¿
        line_y = title_rect.bottom + 15
        pygame.draw.line(surface, (70, 80, 100), 
                        (panel_bg.x + 20, line_y), (panel_bg.right - 20, line_y), 2)
        
        # å¤©èµ‹å¡ç‰‡
        unequipped = [t for t in self.player.learned_talents if t not in self.all_equipped_talents]
        
        for i, talent in enumerate(unequipped):
            if talent != self.dragging_talent:
                rect = self._get_talent_rect(i, 'learned')
                hover_alpha = self.hover_animation.get(f'learned_{i}', 0)
                
                # æ·»åŠ æ‚¬åœåŠ¨ç”»æ•ˆæœ
                if hover_alpha > 0:
                    offset = int(math.sin(self.pulse_animation) * hover_alpha * 2)
                    rect = rect.move(0, offset)
                
                self._draw_talent_card(surface, rect, talent, hover_alpha > 0.3)

    def _draw_talent_card(self, surface, rect, talent, is_highlighted=False):
        """ç»˜åˆ¶å¤©èµ‹å¡ç‰‡"""
        # è·å–ç¨€æœ‰åº¦
        rarity = getattr(talent, 'rarity', 'common')
        rarity_color = TALENT_RARITY_COLORS.get(rarity, TALENT_RARITY_COLORS['common'])
        
        # èƒŒæ™¯é¢œè‰²
        if is_highlighted:
            bg_color = (*rarity_color, 80)
            border_color = rarity_color
        else:
            bg_color = (*rarity_color, 40)
            border_color = (*rarity_color, 120)
        
        pygame.draw.rect(surface, bg_color, rect, border_radius=8)
        pygame.draw.rect(surface, border_color, rect, width=2, border_radius=8)
        
        # ç¨€æœ‰åº¦æŒ‡ç¤ºæ¡
        indicator_rect = pygame.Rect(rect.x, rect.y, rect.width, 4)
        pygame.draw.rect(surface, rarity_color, indicator_rect, 
                        border_top_left_radius=8, border_top_right_radius=8)
        
        # å¤©èµ‹åç§°
        name = get_display_name(talent)
        font = self._get_font('small', 14)
        
        # å¦‚æœåç§°å¤ªé•¿ï¼Œæˆªæ–­å¹¶æ·»åŠ çœç•¥å·
        if font.size(name)[0] > rect.width - 8:
            while font.size(name + "...")[0] > rect.width - 8 and len(name) > 1:
                name = name[:-1]
            name += "..."
        
        text_surface = font.render(name, True, (255, 255, 255))
        text_rect = text_surface.get_rect(center=(rect.centerx, rect.centery))
        surface.blit(text_surface, text_rect)
        
        # å‘å…‰æ•ˆæœï¼ˆå¦‚æœé«˜äº®ï¼‰
        if is_highlighted:
            glow_alpha = int((math.sin(self.glow_animation) + 1) * 30 + 20)
            glow_surface = pygame.Surface(rect.size, pygame.SRCALPHA)
            pygame.draw.rect(glow_surface, (*rarity_color, glow_alpha), 
                           (0, 0, rect.width, rect.height), border_radius=8)
            surface.blit(glow_surface, rect.topleft)

    def _draw_dragging_talent(self, surface):
        """ç»˜åˆ¶æ‹–æ‹½ä¸­çš„å¤©èµ‹"""
        if self.dragging_talent:
            mouse_pos = pygame.mouse.get_pos()
            name = get_display_name(self.dragging_talent)
            
            # åˆ›å»ºæ‹–æ‹½å¡ç‰‡
            card_size = (120, 40)
            card_rect = pygame.Rect(0, 0, *card_size)
            card_rect.center = mouse_pos
            
            # åŠé€æ˜èƒŒæ™¯
            drag_surface = pygame.Surface(card_size, pygame.SRCALPHA)
            rarity = getattr(self.dragging_talent, 'rarity', 'common')
            rarity_color = TALENT_RARITY_COLORS.get(rarity, TALENT_RARITY_COLORS['common'])
            
            pygame.draw.rect(drag_surface, (*rarity_color, 150), 
                           (0, 0, *card_size), border_radius=8)
            pygame.draw.rect(drag_surface, rarity_color, 
                           (0, 0, *card_size), width=2, border_radius=8)
            
            # æ–‡å­—
            font = self._get_font('normal', 16)
            text = font.render(name, True, (255, 255, 255))
            text_rect = text.get_rect(center=(card_size[0]//2, card_size[1]//2))
            drag_surface.blit(text, text_rect)
            
            surface.blit(drag_surface, card_rect.topleft)

    @property
    def all_equipped_talents(self):
        """è·å–æ‰€æœ‰å·²è£…å¤‡çš„éç©ºå¤©èµ‹"""
        return [t for t in self.player.equipped_talents if t is not None]


================================================================================
### æ–‡ä»¶è·¯å¾„: states\title.py
================================================================================

# æ–‡ä»¶: states/title.py (å®Œæ•´æ›¿æ¢)

import pygame
from .base import BaseState
from .loading import LoadScreen
from .story import StoryScreen
from .sandbox_screen import SandboxScreen # <-- 1. å¯¼å…¥æ–°åœºæ™¯
from ui import Button
from settings import *

class TitleScreen(BaseState):
    def __init__(self, game):
        super().__init__(game)
        # --- 2. é‡æ–°å¸ƒå±€ï¼ŒåŠ å…¥æ–°æŒ‰é’® ---
        self.buttons = {
            "new_game": Button((SCREEN_WIDTH / 2 - 150, 300, 300, 60), "æ–°æ¸¸æˆ", self.game.fonts['normal']),
            "continue_game": Button((SCREEN_WIDTH / 2 - 150, 380, 300, 60), "ç»§ç»­æ¸¸æˆ", self.game.fonts['normal']),
            "load_game": Button((SCREEN_WIDTH / 2 - 150, 460, 300, 60), "åŠ è½½æ¸¸æˆ", self.game.fonts['normal']),
            "sandbox": Button((SCREEN_WIDTH / 2 - 150, 540, 300, 60), "æ²™ç›’æ¨¡å¼(æµ‹è¯•)", self.game.fonts['normal']),
        }

    def handle_event(self, event):
        # --- 3. æ·»åŠ å¯¹æ–°æŒ‰é’®çš„äº‹ä»¶å¤„ç† ---
        if self.buttons['new_game'].handle_event(event):
            self.game.start_new_game()
            self.game.state_stack.append(StoryScreen(self.game))

        elif self.buttons['continue_game'].handle_event(event):
            if self.game.load_from_slot(0):
                self.game.state_stack.append(StoryScreen(self.game))
            else:
                self.game.start_new_game()
                self.game.state_stack.append(StoryScreen(self.game))

        elif self.buttons['load_game'].handle_event(event):
            self.game.state_stack.append(LoadScreen(self.game))

        elif self.buttons['sandbox'].handle_event(event):
            self.game.state_stack.append(SandboxScreen(self.game))

        if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
            self.game.running = False

    def draw(self, surface):
        surface.fill(BG_COLOR)
        title_surf = self.game.fonts['large'].render("æˆ‘çš„æˆ˜æ–—æ¸¸æˆ", True, TEXT_COLOR)
        title_rect = title_surf.get_rect(center=(SCREEN_WIDTH / 2, 150))
        surface.blit(title_surf, title_rect)
        for button in self.buttons.values():
            button.draw(surface)



--- ä»£ç åˆé›†ç”Ÿæˆäº: 2025-09-02 17:44:08 ---
--- æ ¹ç›®å½•: C:\Users\User\Desktop\private\battle ---

================================================================================
### æ–‡ä»¶è·¯å¾„: Buffs.py
================================================================================

from damage import DamagePacket, DamageType
from abc import ABC
import collections
from collections import defaultdict
from rich.console import Console, Group
from rich.live import Live
from rich.table import Table
from rich.panel import Panel
from rich.text import Text
import time
import random
from rich.text import Text
from rich.progress import BarColumn  # å¯é€‰ï¼šä¹Ÿå¯ä»¥ç›´æ¥ç”¨ Text
import math
from collections import Counter
#import pygame
import sys

class Buff(ABC):
    """é€šç”¨ Buff/DeBuff åŸºç±»ï¼Œæ‰€æœ‰çŠ¶æ€ç»§æ‰¿æ­¤ç±»ã€‚"""
    display_name     = None      # ç•Œé¢æ˜¾ç¤ºå
    max_stacks       = 1         # æœ€å¤§å å±‚æ•°ï¼›1 è¡¨ç¤ºä¸å¯å åŠ 
    dispellable      = False     # æ˜¯å¦å¯è¢«é©±æ•£
    duration         = None      # æŒç»­ç§’æ•°ï¼›None æˆ– 0 è¡¨ç¤ºæ— é™
    hidden           = False     # æ˜¯å¦åœ¨ç•Œé¢éšè—
    is_debuff        = False     # æ˜¯å¦ä¸ºè´Ÿé¢çŠ¶æ€
    priority         = 0         # æ‰§è¡Œé¡ºåºï¼Œè¶Šå¤§è¶Šå…ˆæ‰§è¡Œ
    disable_attack   = False     # æ˜¯å¦ç¦æ­¢æ”»å‡»ï¼ˆå¦‚çœ©æ™•ã€ä¸ç­äºŒé˜¶æ®µï¼‰

    def __init__(self, stacks: int = 1, duration_override: float = None):
        self.stacks = min(stacks, self.max_stacks)
        self.remaining = duration_override if duration_override is not None else self.duration
        self._accum = 0.0

    def on_apply(self, wearer):
        """Buff è¢«æ·»åŠ åˆ°è§’è‰²æ—¶è§¦å‘"""
        pass

    def on_remove(self, wearer):
        """Buff è¢«ç§»é™¤æ—¶è§¦å‘"""
        pass

    def on_tick(self, wearer, dt):
        """
        æ¯å¸§æˆ–å®šæ—¶è§¦å‘ï¼Œç”¨äºæŒç»­æ€§æ•ˆæœã€‚
        è¿”å›å­—ç¬¦ä¸²åˆ™è¡¨ç¤ºæœ‰é£˜å­—ã€‚
        """
        return None

    def before_take_damage(self, wearer, dmg):
        """å—åˆ°ä¼¤å®³å‰è§¦å‘ï¼Œå¯ä¿®æ”¹ dmg"""
        return dmg

    def on_attacked(self, wearer, attacker, dmg):
        """æ¯æ¬¡è¢«æ”»å‡»åè§¦å‘"""
        pass

    def on_fatal(self, wearer):
        """
        ä¸´ç•Œï¼ˆhp<=0ï¼‰æ—¶è§¦å‘ä¸€æ¬¡ï¼Œè‡ªæ•‘æˆ–å…¶ä»–
        è¿”å› True åˆ™ç§»é™¤è‡ªèº« Buff
        """
        return False


class SteelHeartBuff(Buff):
    """åˆšæ¯…ï¼šå—åˆ°è‡´å‘½ä¼¤æ—¶è‡ªæ•‘ä¸€æ¬¡ï¼Œå¯å åŠ """
    display_name = "åˆšæ¯…"
    dispellable  = False
    max_stacks   = 99  # âœ… å…è®¸å åŠ 

    def __init__(self, uses: int = 1):
        super().__init__(stacks=uses)

    def on_fatal(self, wearer):
        if self.stacks > 0:
            self.stacks -= 1
            wearer.hp = 1
            wearer.shield += int(wearer.max_hp * 0.3)
            return self.stacks == 0  # æœ€å1æ¬¡åç§»é™¤
        return False


class RegenerationBuff(Buff):
    """
    å†ç”Ÿï¼šæ¯å±‚æ¯ç§’å›å¤ 1 ç‚¹ HPï¼ŒæŒç»­å­˜åœ¨ï¼ˆæ— é™ï¼‰ã€‚
    """
    display_name = "å†ç”Ÿ"
    dispellable  = True
    max_stacks   = 99
    is_debuff    = False

    def __init__(self, stacks: int = 1):
        super().__init__(stacks=stacks)
        self._timer = 0.0  # æ–°å¢ï¼šç§’è®¡æ—¶å™¨

    def on_tick(self, wearer, dt):
        self._timer += dt  # ç´¯åŠ æ¯å¸§çš„æ—¶é—´
        
        # å½“è®¡æ—¶å™¨è¶…è¿‡æˆ–ç­‰äº1ç§’æ—¶ï¼Œæ‰§è¡Œå›è¡€
        while self._timer >= 1.0:
            amount = self.stacks  # æ¯ç§’å›å¤é‡ = å±‚æ•°
            wearer.heal(amount)
            self._timer -= 1.0  # è®¡æ—¶å™¨å‡å»1ç§’ï¼Œå‡†å¤‡ä¸‹ä¸€æ¬¡è®¡æ—¶
        return None


class PoisonDebuff(Buff):
    """
    æ¯’ï¼šæ¯å±‚æ¯ç§’å¯¹è§’è‰²é€ æˆ 1 ç‚¹æ¯’ç³»ä¼¤å®³ï¼›ä¼˜å…ˆæ¶ˆè€—æŠ¤ç›¾
    """
    display_name = "æ¯’"
    dispellable  = True
    max_stacks   = 99
    is_debuff    = True

    def __init__(self, stacks: int = 1):
        super().__init__(stacks=stacks)
        self._timer = 0.0

    def on_tick(self, wearer, dt):
        self._timer += dt
        while self._timer >= 1.0:
            dmg = self.stacks
            # <-- æ ¸å¿ƒä¿®æ”¹ï¼šåˆ›å»ºå¹¶å‘é€ä¸€ä¸ªä¼¤å®³ä¿¡æ¯åŒ… -->
            packet = DamagePacket(
                amount=dmg, 
                damage_type=DamageType.POISON, # ç±»å‹æ˜¯æ¯’
                is_dot=True,                   # æ ‡è®°ä¸ºæŒç»­ä¼¤å®³
                is_sourceless=True             # æ ‡è®°ä¸ºæ— æ¥æºä¼¤å®³
            )
            wearer.take_damage(packet)
            self._timer -= 1.0
        return None


class AttackDisabledBuff(Buff):
    """é€šç”¨ï¼šç¦æ­¢è§’è‰²æ™®æ”»"""
    display_name    = "æ— æ³•æ”»å‡»"
    dispellable     = False
    is_debuff       = True
    hidden          = True
    disable_attack  = True

    def __init__(self, duration: float):
        super().__init__(stacks=1)
        self.remaining = duration

    def on_tick(self, wearer, dt):
        if self.remaining is None:
            return None
        self.remaining -= dt
        if self.remaining <= 0:
            wearer.remove_buff(self)
        return None

class StunDebuff(Buff):
    """
    çœ©æ™•ï¼šç¦æ­¢æ™®æ”»ï¼Œä¸å¯å åŠ ï¼Œä¸å¯é©±æ•£
    """
    display_name    = "çœ©æ™•"
    max_stacks      = 1
    dispellable     = False
    is_debuff       = True
    disable_attack  = True
    duration        = 2.0

    def __init__(self, duration=2.0):
        super().__init__(duration_override=duration)

    def on_apply(self, wearer):
        for b in wearer.buffs:
            if b is not self and isinstance(b, StunDebuff):
                b.remaining = max(b.remaining, self.remaining)
                wearer.remove_buff(self)
                return

    def on_tick(self, wearer, dt):
        self.remaining -= dt
        if self.remaining <= 0:
            wearer.remove_buff(self)
        return None


# æ›¿æ¢ Buffs.py ä¸­çš„ ThornsBuff ç±»
class ThornsBuff(Buff):
    """è†æ£˜ï¼šè¢«æ”»å‡»æ—¶åå¼¹å½“å‰å±‚æ•°çš„çœŸå®ä¼¤å®³ç»™æ”»å‡»è€…"""
    display_name  = "è†æ£˜"
    dispellable   = True
    is_debuff     = False
    max_stacks    = 99

    def on_attacked(self, wearer, attacker, dmg):
        if attacker is not None and self.stacks > 0 and attacker.hp > 0:
            # åˆ›å»ºä¸€ä¸ªçœŸå®ä¼¤å®³ã€æ— æ¥æºçš„ä¼¤å®³åŒ…è¿›è¡Œåä¼¤
            thorns_packet = DamagePacket(
                amount=self.stacks,
                damage_type=DamageType.TRUE,
                source=wearer,
                is_sourceless=True
            )
            attacker.take_damage(thorns_packet)

class PhoenixCrownStage1Buff(Buff):
    """ä¸ç­Â·è§‰é†’ï¼ˆStage1ï¼‰ï¼šé˜²å¾¡â†’æ”»å‡»+æ”»é€Ÿ"""
    display_name  = "ä¸ç­Â·è§‰é†’"
    dispellable   = False
    is_debuff     = False

    def __init__(self):
        super().__init__(stacks=1)
        self._boosted = False

    def on_apply(self, wearer):
        bm = wearer.base_max_hp
        wearer.max_hp = bm * 2
        wearer.hp     = min(wearer.hp + bm, wearer.max_hp)

    def on_tick(self, wearer, dt):
        if not self._boosted:
            bd = wearer.base_defense
            ba = wearer.base_attack
            bs = wearer.base_attack_speed
            wearer.attack = ba + bd
            wearer.attack_speed = bs + bd * 0.05
            wearer.attack_interval = 6.0 / wearer.attack_speed
            wearer.defense = 0
            self._boosted = True
        if wearer.hp / wearer.max_hp <= 0.2:
            wearer.remove_buff(self)
            wearer.add_buff(PhoenixCrownStage2Buff())
        return None


class PhoenixCrownStage2Buff(Buff):
    """ä¸ç­Â·ç¬¬äºŒé˜¶æ®µï¼šç¦æ‰‹+å›è¡€åå‡»"""
    display_name    = "ä¸ç­"
    dispellable     = False
    is_debuff       = False
    disable_attack  = True

    def __init__(self):
        super().__init__(stacks=1)
        self._healed_total  = 0.0
        self._rec_atk       = None
        self._rec_def       = None
        self._rec_as        = None
        self._rec_dr        = None
        self._timer         = 0.0  # æ–°å¢ï¼šç§’è®¡æ—¶å™¨

    def on_apply(self, wearer):
        self._rec_atk  = wearer.attack
        self._rec_def  = wearer.defense
        self._rec_as   = wearer.attack_speed
        self._rec_dr   = wearer.damage_resistance
        wearer.damage_resistance = self._rec_dr + 0.5

    def on_tick(self, wearer, dt):
        self._timer += dt
        
        # æ¯ç§’è§¦å‘ä¸€æ¬¡å›è¡€
        while self._timer >= 1.0:
            if wearer.hp < wearer.max_hp: # åªæœ‰æ²¡æ»¡è¡€çš„æ—¶å€™æ‰å›
                heal_amount = wearer.max_hp * 0.1 # æ¯ç§’å›å¤æœ€å¤§ç”Ÿå‘½çš„10%
                actual_healed = min(heal_amount, wearer.max_hp - wearer.hp) # å®é™…å›å¤é‡
                wearer.hp += actual_healed
                self._healed_total += actual_healed
            self._timer -= 1.0

        if wearer.hp >= wearer.max_hp:
            total = int(self._healed_total)
            attacker = getattr(wearer, "_last_real_attacker", None)
            text = "" # åˆå§‹åŒ–è¿”å›æ–‡æœ¬

            if attacker and attacker.hp > 0:
                attacker.take_damage(total)
                attacker.last_hits.append((total, False))
                text = f"[ä¸ç­åå‡»] {wearer.name} â†’ {attacker.name} é€ æˆ {total} ç‚¹ä¼¤å®³"

            # æ¢å¤åŸå±æ€§
            wearer.attack            = self._rec_atk
            wearer.defense           = self._rec_def
            wearer.attack_speed      = self._rec_as
            wearer.attack_interval   = 6.0 / self._rec_as
            wearer.damage_resistance = self._rec_dr
            wearer.max_hp            = wearer.base_max_hp
            wearer.hp                = min(wearer.hp, wearer.max_hp)
            wearer.remove_buff(self)
            return text

        return None
    
class StormDebuff(Buff):
    """
    é£æš´å°è®° (å¯é©±æ•£)
    å½“æºå¸¦è€…å—åˆ°ä¸‹ä¸€æ¬¡ä»»æ„æ¥æºçš„ä¼¤å®³æ—¶ï¼Œ
    æ­¤å°è®°ä¼šå¼•çˆ†ï¼Œé€ æˆé¢å¤–ä¼¤å®³ï¼Œç„¶åæ¶ˆå¤±ã€‚
    """
    display_name = "é£æš´"
    dispellable  = True
    is_debuff    = True

    def before_take_damage(self, wearer, packet: DamagePacket): # <-- æ¥æ”¶ packet
        print("[é£æš´å¼•çˆ†!] é€ æˆé¢å¤–ä¼¤å®³")
        # ç›´æ¥åœ¨ä¼ å…¥çš„ä¼¤å®³åŒ…ä¸Šå¢åŠ ä¼¤å®³
        packet.amount += 50
        # ç§»é™¤è‡ªå·±
        wearer.remove_buff(self)


class BleedDebuff(Buff):
    """
    æµè¡€ (å¯å åŠ , å¯é©±æ•£)
    æ¯å±‚æ¯ç§’å¯¹ç›®æ ‡é€ æˆ 1 ç‚¹çœŸå®ä¼¤å®³ï¼ˆæ— è§†é˜²å¾¡ï¼‰ã€‚
    """
    display_name = "æµè¡€"
    dispellable  = True
    is_debuff    = True
    max_stacks   = 99

    def __init__(self, stacks: int = 1, duration: float = 5.0):
        super().__init__(stacks=stacks, duration_override=duration)
        self._timer = 0.0

    def on_tick(self, wearer, dt):
        self._timer += dt
        if self._timer >= 1.0:
            dmg = self.stacks
            # <-- æ ¸å¿ƒä¿®æ”¹ï¼šåˆ›å»ºå¹¶å‘é€ä¸€ä¸ªä¼¤å®³ä¿¡æ¯åŒ… -->
            packet = DamagePacket(
                amount=dmg,
                damage_type=DamageType.TRUE, # ç±»å‹æ˜¯çœŸå®ä¼¤å®³
                is_dot=True,
                is_sourceless=True
            )
            wearer.take_damage(packet)
            self._timer -= 1.0
        
        self.remaining -= dt
        if self.remaining <= 0:
            wearer.remove_buff(self)
        return None

class BlockBuff(Buff):
    """æ ¼æŒ¡ï¼šæ¯å±‚å¯ä»¥å®Œå…¨æŠµæŒ¡ä¸€æ¬¡ä»»æ„æ¥æºçš„ä¼¤å®³ã€‚"""
    display_name = "æ ¼æŒ¡"
    max_stacks   = 99

    def before_take_damage(self, wearer, packet: DamagePacket): # <-- å‚æ•°æ”¹ä¸º packet
        if self.stacks > 0 and packet.amount > 0:
            print(f"[æ ¼æŒ¡] æ•ˆæœè§¦å‘ï¼æŠµæŒ¡äº† {int(packet.amount)} ç‚¹ä¼¤å®³ã€‚")
            self.stacks -= 1
            if self.stacks <= 0:
                wearer.remove_buff(self)
            
            packet.amount = 0 # å°†ä¼¤å®³åŒ…çš„æ•°å€¼æ¸…é›¶


class DragonSoulBuff(Buff):
    """ã€é¾™é­‚ã€‘ï¼šä¸€ç§ç‰¹æ®Šçš„èƒ½é‡èµ„æºï¼Œå¯è¢«æ¶ˆè€—ã€‚"""
    display_name = "é¾™é­‚"
    max_stacks   = 10 # é¾™é­‚ä¸Šé™ä¸º10å±‚
    is_debuff    = False

class SunstoneBrandDebuff(Buff):
    """ã€æ—¥ä¹‹çƒ™å°ã€‘ï¼šä¸€ç§å¯è¢«å¼•çˆ†çš„å°è®°ã€‚"""
    display_name = "æ—¥ä¹‹çƒ™å°"
    is_debuff    = True
    max_stacks   = 99


================================================================================
### æ–‡ä»¶è·¯å¾„: Character.py
================================================================================

# Character.py (æœ€ç»ˆå®Œæ•´ç‰ˆ)
import pygame
import sys
import time
import collections
import math
import random
# from rich.console import Console  <- No longer needed
# console = Console()

import Buffs
import Talents
import Equips
from damage import DamagePacket, DamageType
from settings import RARITY_COLORS

RARITY_GOLD_VALUE = {"common": 10, "uncommon": 25, "rare": 60, "epic": 150, "legendary": 400, "mythic": 1000}

class Character:
    DEFAULT_SLOT_CAPACITY = {"weapon": 1, "offhand": 1, "helmet": 1, "armor": 1, "pants": 1, "accessory": 4}

    def __init__(self, name, hp, defense, magic_resist, attack, attack_speed,
                 equipment=None, talents=None, id=None): # <-- 1. åœ¨è¿™é‡Œå¢åŠ  id=None

        self.id = id or name # <-- 2. å¢åŠ è¿™ä¸€è¡Œï¼Œå¦‚æœæä¾›äº†idå°±ç”¨idï¼Œå¦åˆ™ç”¨åå­—
        self.name, self.level, self.gold = name, 1, 0
        self.exp, self.exp_to_next_level, self.backpack = 0, 100, []
        self.SLOT_CAPACITY = self.DEFAULT_SLOT_CAPACITY.copy()
        self.max_talent_slots = 3 
        self.learned_talents = talents or []
        self.equipped_talents = []
        self._innate_max_hp, self._innate_defense, self._innate_attack, self._innate_attack_speed = hp, defense, attack, attack_speed
        self.magic_resist = magic_resist
        self.slots = {
            slot: [None] * capacity for slot, capacity in self.SLOT_CAPACITY.items()
        }
        for eq in (equipment or []): self.equip(eq)
        self.base_max_hp, self.base_defense, self.base_attack, self.base_attack_speed = 0, 0, 0, 0
        self.recalculate_stats(); self.hp = self.max_hp
        initial_talents_to_equip = self.learned_talents[:]
        self.learned_talents = []
        for talent in initial_talents_to_equip: self.learn_talent(talent); self.equip_talent(talent)
        self.shield, self._cd, self.crit_chance, self.crit_multiplier = 0, 0.0, 0.0, 1.5
        self.last_damage, self.last_hits, self.buffs, self.damage_resistance = 0, collections.deque(maxlen=5), [], 0.0

    def add_gold(self, amount, source=""):
        if amount <= 0: return None
        self.gold += amount
        source_text = f" ({source})" if source else ""
        return f"è·å¾—äº† {amount} Gï¼{source_text} (å½“å‰: {self.gold} G)"

    def pickup_item(self, item_to_pickup):
        item_name = getattr(item_to_pickup, 'display_name', item_to_pickup.__class__.__name__)
        all_current_items = self.backpack + self.all_equipment
        is_duplicate = any(getattr(item, 'display_name', item.__class__.__name__) == item_name for item in all_current_items)
        if is_duplicate:
            rarity = getattr(item_to_pickup, 'rarity', 'common')
            gold_value = RARITY_GOLD_VALUE.get(rarity, 5)
            return self.add_gold(gold_value, source=f"è½¬åŒ–({item_name})")
        else:
            self.backpack.append(item_to_pickup)
            return f"ç‰©å“ã€Œ{item_name}ã€å·²æ”¾å…¥ä½ çš„èƒŒåŒ…ã€‚"
    
    # ... (å…¶ä»–æ‰€æœ‰æ–¹æ³•éƒ½ä¿æŒä¸å˜)
    def learn_talent(self, talent_to_learn):
        if not any(isinstance(t, talent_to_learn.__class__) for t in self.learned_talents):
            self.learned_talents.append(talent_to_learn)
            print(f"å­¦ä¼šäº†æ–°å¤©èµ‹: {talent_to_learn.display_name}")
            return True
        return False
    def equip_talent(self, talent_to_equip):
        if len(self.equipped_talents) >= self.max_talent_slots: print("å¤©èµ‹æ§½å·²æ»¡ï¼"); return False
        if talent_to_equip not in self.learned_talents: print("å°šæœªå­¦ä¼šè¯¥å¤©èµ‹ï¼"); return False
        if talent_to_equip in self.equipped_talents: print("è¯¥å¤©èµ‹å·²è¢«è£…å¤‡ã€‚"); return False
        self.equipped_talents.append(talent_to_equip); self.recalculate_stats(); print(f"å·²è£…å¤‡å¤©èµ‹: {talent_to_equip.display_name}"); return True
    def unequip_talent(self, talent_to_unequip):
        if talent_to_unequip not in self.equipped_talents: return
        self.equipped_talents.remove(talent_to_unequip); self.recalculate_stats(); print(f"å·²å¸ä¸‹å¤©èµ‹: {talent_to_unequip.display_name}")
    # æ–‡ä»¶: Character.py

    def on_enter_combat(self):
        self.buffs.clear(); self.hp = self.max_hp; self.shield = 0; self._cd = 0.0;

        # æ–°å¢é€»è¾‘ï¼šé‡ç½®è£…å¤‡çš„æˆ˜æ–—å†…çŠ¶æ€
        for eq in self.all_equipment:
            if isinstance(eq, Equips.AdventurersPouch):
                eq.atk_bonus = 0 # æˆ˜æ–—å‡†å¤‡æ—¶ï¼Œå°†é’±è¢‹çš„åŠ æˆæ¸…é›¶

        # é‡ç½®å®Œåå†é‡ç®—ä¸€æ¬¡å±æ€§ï¼Œç¡®ä¿ä¸€ä¸ªå¹²å‡€çš„çŠ¶æ€
        self.recalculate_stats() 
        print(f"{self.name} å·²è¿›å…¥æˆ˜æ–—å‡†å¤‡çŠ¶æ€ï¼")
    def update(self, dt) -> list[str]:
        texts = []
        for buff in list(self.buffs):
            if hasattr(buff, "on_tick"): res = buff.on_tick(self, dt);
            if isinstance(res, str) and res: texts.append(res)
        for eq in self.all_equipment:
            if hasattr(eq, "on_tick"): res = eq.on_tick(self, dt);
            if isinstance(res, str) and res: texts.append(res)
        return texts
    # åœ¨ Character.py æ–‡ä»¶ä¸­ï¼Œæ‰¾åˆ°å¹¶æ›¿æ¢ recalculate_stats æ–¹æ³•

    # Replace the entire recalculate_stats method with this new version
    def recalculate_stats(self):
        """é‡æ–°è®¡ç®—æ‰€æœ‰æ¥è‡ªè£…å¤‡å’Œå¤©èµ‹çš„å±æ€§åŠ æˆ"""
        # 1. ä¿å­˜å½“å‰è¡€é‡ç™¾åˆ†æ¯”
        hp_percent = self.hp / self.max_hp if hasattr(self, 'max_hp') and self.max_hp > 0 else 1

        # 2. é‡ç½®ä¸ºçº¯ç²¹çš„â€œå›ºæœ‰â€å±æ€§
        self.base_max_hp = self._innate_max_hp
        self.base_defense = self._innate_defense
        self.base_attack = self._innate_attack
        self.base_attack_speed = self._innate_attack_speed

        # 3. åŠ ä¸Šæ‰€æœ‰æ¥è‡ªâ€œè£…å¤‡â€çš„å±æ€§
        all_eq = self.all_equipment
        self.base_max_hp += sum(getattr(eq, "hp_bonus", 0) for eq in all_eq)
        self.base_defense += sum(getattr(eq, "def_bonus", 0) for eq in all_eq)
        self.base_attack += sum(getattr(eq, "atk_bonus", 0) for eq in all_eq)
        self.base_attack_speed += sum(getattr(eq, "as_bonus", 0) for eq in all_eq)

        # 4. å°†â€œå½“å‰å±æ€§â€å…ˆé‡ç½®ä¸ºâ€œåŸºç¡€å±æ€§â€
        self.max_hp = self.base_max_hp
        self.defense = self.base_defense
        self.attack = self.base_attack
        self.attack_speed = self.base_attack_speed
        self.crit_chance = 0.0 
        self.magic_resist = 3 
        self.damage_resistance = 0.0

        # --- æ ¸å¿ƒä¿®å¤åœ¨è¿™é‡Œ ---
        # 5. åœ¨åº”ç”¨å¤©èµ‹ä¹‹å‰ï¼Œå…ˆé‡ç½® SLOT_CAPACITY ä¸ºé»˜è®¤å€¼
        #    è¿™å¯ä»¥é˜²æ­¢å¤©èµ‹æ•ˆæœï¼ˆå¦‚äºŒåˆ€æµï¼‰åœ¨å¸ä¸‹åä¾ç„¶æ®‹ç•™
        self.SLOT_CAPACITY = self.DEFAULT_SLOT_CAPACITY.copy()

        # 6. åº”ç”¨æ‰€æœ‰æ¥è‡ªâ€œå·²è£…å¤‡å¤©èµ‹â€çš„ä¿®æ”¹ï¼ˆè¿™å¯èƒ½ä¼šæ”¹å˜ SLOT_CAPACITYï¼‰
        for talent in self.equipped_talents:
            if hasattr(talent, 'on_init'):
                talent.on_init(self)

        # 7. æ–°å¢ï¼šåŒæ­¥è£…å¤‡æ§½å®¹é‡
        #    åœ¨å¤©èµ‹ä¿®æ”¹å®Œ SLOT_CAPACITY è§„åˆ™åï¼Œæˆ‘ä»¬åœ¨è¿™é‡Œç¡®ä¿ self.slots çš„å®é™…å¤§å°ä¸è§„åˆ™åŒ¹é…
        for slot, required_capacity in self.SLOT_CAPACITY.items():
            current_slots = self.slots.get(slot, [])
            current_capacity = len(current_slots)

            if current_capacity < required_capacity:
                # å¦‚æœå®é™…æ§½ä½æ¯”éœ€è¦çš„å°‘ï¼Œå°±ç”¨ None è¡¥ä¸Š
                current_slots.extend([None] * (required_capacity - current_capacity))
            elif current_capacity > required_capacity:
                # å¦‚æœå®é™…æ§½ä½æ¯”éœ€è¦çš„å¤šï¼ˆä¾‹å¦‚å¸ä¸‹äº†äºŒåˆ€æµå¤©èµ‹ï¼‰
                # æˆ‘ä»¬éœ€è¦å¤„ç†å¤šä½™çš„è£…å¤‡ï¼Œè¿™é‡Œç®€å•åœ°å°†å®ƒä»¬æ”¾å›èƒŒåŒ…
                extra_items = current_slots[required_capacity:]
                for item in extra_items:
                    if item:
                        self.backpack.append(item)
                # ç„¶åæˆªæ–­åˆ—è¡¨
                self.slots[slot] = current_slots[:required_capacity]
        # --- ä¿®å¤ç»“æŸ ---

        # 8. æœ€åï¼Œåº”ç”¨å…¶ä»–è£…å¤‡æ•ˆæœï¼ˆæ¯”å¦‚æš´å‡»ç‡ï¼‰
        self.magic_resist += sum(getattr(eq, "magic_resist_bonus", 0) for eq in all_eq)
        self.crit_chance += sum(getattr(eq, "crit_bonus", 0) for eq in all_eq)

        # 9. æ¢å¤è¡€é‡ç™¾åˆ†æ¯”å¹¶æœ€ç»ˆè®¡ç®—
        self.hp = min(self.max_hp, self.max_hp * hp_percent)
        self.attack_interval = 6.0 / self.attack_speed
        print("è§’è‰²å±æ€§å·²æ›´æ–°ï¼")
    
    @property
    def all_equipment(self):
        eqs = []
        for eq_list in self.slots.values():
            # ç­›é€‰å‡ºä¸æ˜¯ None çš„çœŸå®è£…å¤‡
            eqs.extend([item for item in eq_list if item is not None])
        return eqs

# --- 3. å®Œæ•´æ›¿æ¢ equip æ–¹æ³• ---
    def equip(self, eq_to_equip, specific_index=None):
        """è£…å¤‡ä¸€ä»¶ç‰©å“ï¼Œå¯ä»¥æŒ‡å®šç²¾ç¡®çš„æ§½ä½ç´¢å¼•ã€‚"""
        slot = eq_to_equip.slot
        if slot not in self.SLOT_CAPACITY:
            raise ValueError(f"æœªçŸ¥æ’æ§½ï¼š{slot}")

        # å¦‚æœæŒ‡å®šäº†ç´¢å¼•
        if specific_index is not None:
            if 0 <= specific_index < self.SLOT_CAPACITY[slot]:
                # å¸ä¸‹ç›®æ ‡æ§½ä½åŸæœ‰çš„ç‰©å“
                unequipped_item = self.slots[slot][specific_index]
                # ç©¿ä¸Šæ–°ç‰©å“
                self.slots[slot][specific_index] = eq_to_equip
                self.recalculate_stats()
                return unequipped_item # è¿”å›è¢«æ›¿æ¢ä¸‹çš„ç‰©å“ (å¯èƒ½æ˜¯None)
            else:
                return eq_to_equip # ç´¢å¼•æ— æ•ˆï¼Œè£…å¤‡å¤±è´¥

        # å¦‚æœæœªæŒ‡å®šç´¢å¼•ï¼Œåˆ™è‡ªåŠ¨å¯»æ‰¾ç©ºä½
        else:
            try:
                # æ‰¾åˆ°ç¬¬ä¸€ä¸ªç©ºæ§½ä½ (å€¼ä¸ºNone)
                empty_index = self.slots[slot].index(None)
                self.slots[slot][empty_index] = eq_to_equip
                self.recalculate_stats()
                return None # æˆåŠŸè£…å¤‡åˆ°ç©ºæ§½ï¼Œæ²¡æœ‰ç‰©å“è¢«æ›¿æ¢
            except ValueError:
                # å¦‚æœæ‰¾ä¸åˆ°Noneï¼Œè¯´æ˜æ§½ä½å·²æ»¡
                # å¯¹äºå•æ§½ä½ï¼Œç›´æ¥æ›¿æ¢
                if self.SLOT_CAPACITY[slot] == 1:
                    unequipped_item = self.slots[slot][0]
                    self.slots[slot][0] = eq_to_equip
                    self.recalculate_stats()
                    return unequipped_item
                else: # å¤šæ§½ä½å·²æ»¡ä¸”æœªæŒ‡å®šç´¢å¼•ï¼Œåˆ™å¤±è´¥
                    print(f"è­¦å‘Š: {slot} æ’æ§½å·²æ»¡ä¸”æœªæŒ‡å®šæ›¿æ¢ä½ç½®")
                    return eq_to_equip

# --- 4. å®Œæ•´æ›¿æ¢ unequip æ–¹æ³• ---
    def unequip(self, eq_to_unequip):
        """ä»è§’è‰²èº«ä¸Šå¸ä¸‹æŒ‡å®šçš„è£…å¤‡ã€‚"""
        slot = eq_to_unequip.slot
        if eq_to_unequip in self.slots[slot]:
            # æ‰¾åˆ°ç‰©å“çš„ç´¢å¼•
            index = self.slots[slot].index(eq_to_unequip)
            # å°†è¯¥ä½ç½®è®¾ç½®å› None
            self.slots[slot][index] = None
            self.recalculate_stats()
            return eq_to_unequip # è¿”å›è¢«å¸ä¸‹çš„ç‰©å“
        return None
    def take_damage(self, packet: DamagePacket):
        final_packet = packet.copy()
        for eq in self.all_equipment:
            if hasattr(eq, "before_take_damage"): eq.before_take_damage(self, final_packet)
        for buff in list(self.buffs):
            if hasattr(buff, "before_take_damage"): buff.before_take_damage(self, final_packet)
        mitigated_amount = final_packet.amount
        if not final_packet.ignores_armor and final_packet.damage_type != DamageType.TRUE:
            if final_packet.damage_type == DamageType.PHYSICAL: mitigated_amount -= self.defense
            elif final_packet.damage_type == DamageType.MAGIC: mitigated_amount -= self.magic_resist
        mitigated_amount *= (1.0 - self.damage_resistance)
        mitigated_amount = max(0, mitigated_amount)
        if self.shield > 0: shield_absorbed = min(self.shield, mitigated_amount); self.shield -= shield_absorbed; mitigated_amount -= shield_absorbed
        if mitigated_amount > 0:
            self.hp = max(0, self.hp - mitigated_amount)
            timestamp = pygame.time.get_ticks() if "pygame" in sys.modules else int(time.time() * 1000)
            self.last_hits.append((int(mitigated_amount), timestamp))
        for eq in self.all_equipment:
            if hasattr(eq, "after_take_damage"): eq.after_take_damage(self, final_packet, mitigated_amount)
        for buff in list(self.buffs):
            if hasattr(buff, "on_attacked"): buff.on_attacked(self, final_packet.source, mitigated_amount)
        if self.hp <= 0:
            to_remove = []
            for buff in list(self.buffs):
                if hasattr(buff, "on_fatal") and buff.on_fatal(self): to_remove.append(buff)
            for buff in to_remove: self.remove_buff(buff)
    def try_attack(self, target, dt):
        if any(getattr(b, "disable_attack", False) for b in self.buffs): return None
        self._cd += dt
        if self._cd < self.attack_interval or self.hp <= 0: return None
        is_crit = (random.random() < self.crit_chance)
        damage = self.attack * self.crit_multiplier if is_crit else self.attack
        packet = DamagePacket(amount=damage, damage_type=DamageType.PHYSICAL, source=self, is_critical=is_crit)
        for eq in self.all_equipment:
            if hasattr(eq, "before_attack"): eq.before_attack(self, target, packet)
        pre_total = target.shield + target.hp; target.take_damage(packet); post_total = target.shield + target.hp
        actual_dmg = pre_total - post_total
        for eq in self.all_equipment:
            if hasattr(eq, "after_attack"): eq.after_attack(self, target, actual_dmg)
        if is_crit:
            for eq in self.all_equipment:
                if hasattr(eq, "on_critical"): eq.on_critical(self, target, actual_dmg)
        else:
            for eq in self.all_equipment:
                if hasattr(eq, "on_non_critical"): eq.on_non_critical(self, target, actual_dmg)
        extra_texts = []
        for t in self.equipped_talents:
            if hasattr(t, "on_attack"): out = t.on_attack(self, target, actual_dmg);
            if out: extra_texts.extend(out)
        self._cd -= self.attack_interval; text = f"{self.name} â†’ {target.name} é€ æˆ {int(actual_dmg)} ç‚¹ä¼¤å®³"
        if is_crit: text += " (æš´å‡»!)"
        return text, extra_texts
    def perform_extra_attack(self, target):
        print(f"[{self.name}] æ­£åœ¨æ‰§è¡Œé¢å¤–æ”»å‡»ï¼")
        is_crit = (random.random() < self.crit_chance); damage = self.attack * self.crit_multiplier if is_crit else self.attack
        packet = DamagePacket(amount=damage, damage_type=DamageType.PHYSICAL, source=self, is_critical=is_crit)
        for eq in self.all_equipment:
            if hasattr(eq, "before_attack"): eq.before_attack(self, target, packet)
        pre_total = target.shield + target.hp; target.take_damage(packet); post_total = target.shield + target.hp
        actual_dmg = pre_total - post_total
        for eq in self.all_equipment:
            if hasattr(eq, "after_attack"): eq.after_attack(self, target, actual_dmg)
        if is_crit:
            for eq in self.all_equipment:
                if hasattr(eq, "on_critical"): eq.on_critical(self, target, actual_dmg)
        else:
            for eq in self.all_equipment:
                if hasattr(eq, "on_non_critical"): eq.on_non_critical(self, target, actual_dmg)
        text = f"{self.name} (é¢å¤–æ”»å‡») â†’ {target.name} é€ æˆ {int(actual_dmg)} ç‚¹ä¼¤å®³"
        if is_crit: text += " (æš´å‡»!)"
        return text
    def heal(self, amount: float) -> float:
        healed = min(self.max_hp - self.hp, amount)
        if healed <= 0: return 0.0
        self.hp += healed
        for buff in list(self.buffs):
            if hasattr(buff, "on_healed"): buff.on_healed(self, healed)
        return healed
    def add_status(self, status: Buffs.Buff, *, source: "Character" = None):
        final_buff = None; added_stacks = status.stacks
        for b in self.buffs:
            if isinstance(b, status.__class__):
                if b.max_stacks == 1: b.remaining = b.duration
                else: b.stacks = min(b.stacks + status.stacks, b.max_stacks)
                final_buff = b; break
        if final_buff is None: final_buff = status; self.buffs.append(status); status.on_apply(self)
        if source is not None and source is not self and getattr(final_buff, "is_debuff", False):
            for t in self.equipped_talents:
                if hasattr(t, "on_inflict_debuff"): t.on_inflict_debuff(source, self, final_buff, added_stacks)
        if getattr(final_buff, "dispellable", False) and getattr(final_buff, "is_debuff", False):
            for t in self.equipped_talents:
                if hasattr(t, "on_debuff_applied"): t.on_debuff_applied(self, final_buff)
    add_buff, add_debuff = add_status, add_status
    def remove_buff(self, buff): self.buffs.remove(buff); buff.on_remove(self)
    def add_exp(self, amount):
        if self.hp <= 0: return []
        self.exp += amount; messages = [f"è·å¾—äº† {amount} ç‚¹ç»éªŒï¼ (å½“å‰: {self.exp}/{self.exp_to_next_level})"]
        if self.exp >= self.exp_to_next_level: messages.extend(self.level_up())
        return messages
    def level_up(self):
        level_up_messages = []
        while self.exp >= self.exp_to_next_level:
            self.level += 1; self.exp -= self.exp_to_next_level; self.exp_to_next_level = int(self.exp_to_next_level * 1.5)
            self._innate_max_hp += 10; self._innate_attack += 2; self._innate_defense += 1
            self.recalculate_stats()
            level_up_messages.append(f"ğŸ‰ ç­‰çº§æå‡ï¼ç°åœ¨æ˜¯ {self.level} çº§ï¼"); level_up_messages.append("   ç”Ÿå‘½+10ï¼Œæ”»å‡»+2ï¼Œé˜²å¾¡+1")
        return level_up_messages


================================================================================
### æ–‡ä»¶è·¯å¾„: combine_code.py
================================================================================

import os
import datetime

# --- é…ç½® ---
# è¦æœç´¢çš„æ ¹æ–‡ä»¶å¤¹ ('.' ä»£è¡¨å½“å‰æ–‡ä»¶å¤¹)
ROOT_DIR = '.'
# è¦åŒ…å«çš„æ–‡ä»¶æ‰©å±•å
FILE_EXTENSIONS = ('.py', '.json')
# è¾“å‡ºæ–‡ä»¶å
OUTPUT_FILE = 'combined_code.txt'
# --- ç»“æŸé…ç½® ---

def combine_files():
    """
    éå†æŒ‡å®šç›®å½•åŠå…¶å­ç›®å½•ï¼Œå°†ç‰¹å®šæ‰©å±•åçš„æ–‡ä»¶å†…å®¹åˆå¹¶åˆ°ä¸€ä¸ªæ–‡ä»¶ä¸­ã€‚
    """
    print(f"å¼€å§‹æ‰«ææ–‡ä»¶å¤¹: {os.path.abspath(ROOT_DIR)}")
    print(f"å°†è¦åˆå¹¶çš„æ–‡ä»¶ç±»å‹: {FILE_EXTENSIONS}")
    
    # ä½¿ç”¨ with è¯­å¥ç¡®ä¿æ–‡ä»¶è¢«æ­£ç¡®å…³é—­
    with open(OUTPUT_FILE, 'w', encoding='utf-8') as outfile:
        # å†™å…¥æ–‡ä»¶å¤´éƒ¨ä¿¡æ¯
        outfile.write(f"--- ä»£ç åˆé›†ç”Ÿæˆäº: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')} ---\n")
        outfile.write(f"--- æ ¹ç›®å½•: {os.path.abspath(ROOT_DIR)} ---\n\n")
        
        # os.walk() ä¼šé€’å½’åœ°éå†ç›®å½•
        for dirpath, _, filenames in os.walk(ROOT_DIR):
            for filename in filenames:
                # æ£€æŸ¥æ–‡ä»¶æ‰©å±•åæ˜¯å¦ç¬¦åˆè¦æ±‚
                if filename.endswith(FILE_EXTENSIONS):
                    # æ„å»ºå®Œæ•´çš„æ–‡ä»¶è·¯å¾„
                    file_path = os.path.join(dirpath, filename)
                    # è·å–ç›¸å¯¹è·¯å¾„ï¼Œè¿™æ ·æ›´æ¸…æ™°
                    relative_path = os.path.relpath(file_path, ROOT_DIR)
                    
                    print(f"æ­£åœ¨æ·»åŠ æ–‡ä»¶: {relative_path}")
                    
                    # å†™å…¥æ–‡ä»¶åˆ†éš”ç¬¦å’Œè·¯å¾„ä¿¡æ¯
                    outfile.write("=" * 80 + "\n")
                    outfile.write(f"### æ–‡ä»¶è·¯å¾„: {relative_path}\n")
                    outfile.write("=" * 80 + "\n\n")
                    
                    try:
                        # è¯»å–æºæ–‡ä»¶å†…å®¹å¹¶å†™å…¥è¾“å‡ºæ–‡ä»¶
                        with open(file_path, 'r', encoding='utf-8') as infile:
                            outfile.write(infile.read())
                        outfile.write("\n\n\n") # åœ¨æ–‡ä»¶æœ«å°¾æ·»åŠ ä¸€äº›ç©ºè¡Œä»¥ä½œåŒºåˆ†
                    except Exception as e:
                        # å¦‚æœæ–‡ä»¶è¯»å–å¤±è´¥ï¼ˆä¾‹å¦‚å› ä¸ºç¼–ç é—®é¢˜ï¼‰ï¼Œåˆ™è®°å½•é”™è¯¯ä¿¡æ¯
                        outfile.write(f"*** æ— æ³•è¯»å–æ–‡ä»¶: {relative_path} | é”™è¯¯: {e} ***\n\n\n")

    print(f"\næˆåŠŸï¼æ‰€æœ‰ä»£ç å·²æ•´åˆåˆ°æ–‡ä»¶: {OUTPUT_FILE}")

if __name__ == '__main__':
    combine_files()


================================================================================
### æ–‡ä»¶è·¯å¾„: damage.py
================================================================================

# damage.py
from enum import Enum, auto

class DamageType(Enum):
    PHYSICAL = auto()      # æ™®é€šç‰©ç†ä¼¤å®³
    MAGIC = auto()         # é­”æ³•ä¼¤å®³
    TRUE = auto()          # çœŸå®ä¼¤å®³
    POISON = auto()        # æ¯’ç³»ä¼¤å®³
    DRAGON_SOURCE = auto() # é¾™æºä¼¤å®³

class DamagePacket:
    """ä¸€ä¸ªç”¨æ¥å°è£…æ‰€æœ‰ä¼¤å®³ä¿¡æ¯çš„æ•°æ®ç»“æ„"""
    def __init__(self, amount, damage_type, source=None,
                 is_critical=False, is_dot=False, 
                 is_sourceless=False, ignores_armor=False):
        
        self.amount = amount               # åŸºç¡€ä¼¤å®³æ•°å€¼
        self.damage_type = damage_type     # ä¼¤å®³ç±»å‹ (ç‰©ç†, é­”æ³•, çœŸå®...)
        self.source = source               # ä¼¤å®³æ¥æº (å“ªä¸ªè§’è‰²)
        
        # --- å„ç§æ ‡å¿— (Flags) ---
        self.is_critical = is_critical         # æ˜¯å¦æš´å‡»
        self.is_dot = is_dot                   # æ˜¯å¦ä¸ºæŒç»­ä¼¤å®³(DOT)
        self.is_sourceless = is_sourceless     # æ˜¯å¦ä¸ºæ— æ¥æºä¼¤å®³ (å¦‚ç¯å¢ƒã€åä¼¤)
        self.ignores_armor = ignores_armor     # æ˜¯å¦ç©¿ç”² (æ— è§†é˜²å¾¡)

    def copy(self):
        """åˆ›å»ºä¸€ä¸ªå‰¯æœ¬ï¼Œæ–¹ä¾¿åœ¨è®¡ç®—è¿‡ç¨‹ä¸­ä¿®æ”¹è€Œä¸å½±å“åŸå§‹åŒ…"""
        return DamagePacket(
            self.amount, self.damage_type, self.source,
            self.is_critical, self.is_dot, self.is_sourceless, self.ignores_armor
        )


================================================================================
### æ–‡ä»¶è·¯å¾„: dungeon_generator.py
================================================================================

# æ–‡ä»¶: dungeon_generator.py (å®Œæ•´æ›¿æ¢)

import random
from settings import SCREEN_WIDTH, SCREEN_HEIGHT

class Room:
    def __init__(self, x, y, room_type="combat"):
        self.x, self.y, self.type = x, y, room_type
        self.doors = {"N": False, "S": False, "E": False, "W": False}
        self.is_cleared = False
        self.monsters = []
        # ä½ è¿˜å¯ä»¥æ·»åŠ  event_id, treasure_contents ç­‰å­—æ®µ

class Floor:
    def __init__(self, width=21, height=21):
        self.width, self.height = width, height
        self.rooms, self.start_room, self.boss_room = {}, None, None

    def generate_floor(self, num_rooms=8, floor_data=None):
        """
        ä½¿ç”¨ä¼ å…¥çš„ floor_data åŠ¨æ€ç”Ÿæˆæ¥¼å±‚å†…å®¹
        """
        self.rooms.clear()
        grid = [[None for _ in range(self.width)] for _ in range(self.height)]
        
        # 1. åˆ›å»ºæˆ¿é—´å¸ƒå±€ (è¿™éƒ¨åˆ†é€»è¾‘ä¸å˜)
        sx, sy = self.width // 2, self.height // 2
        start_room = Room(sx, sy, "start")
        start_room.is_cleared = True
        grid[sy][sx] = start_room
        self.rooms[(sx, sy)] = start_room
        
        frontier = [(sx, sy)]
        
        while len(self.rooms) < num_rooms and frontier:
            px, py = random.choice(frontier)
            possible_neighbors = []
            directions = [(0, -1, "N", "S"), (0, 1, "S", "N"), (1, 0, "E", "W"), (-1, 0, "W", "E")]
            for dx, dy, door, opposite_door in directions:
                nx, ny = px + dx, py + dy
                if 0 <= nx < self.width and 0 <= ny < self.height and not grid[ny][nx]:
                    possible_neighbors.append((nx, ny, door, opposite_door))
            
            if possible_neighbors:
                nx, ny, door, opposite_door = random.choice(possible_neighbors)
                new_room = Room(nx, ny)
                grid[ny][nx] = new_room
                self.rooms[(nx, ny)] = new_room
                frontier.append((nx, ny))
                grid[py][px].doors[door] = True
                new_room.doors[opposite_door] = True
            else:
                frontier.remove((px, py))

        # --- 2. æ ¸å¿ƒä¿®æ”¹ï¼šæ ¹æ® floor_data å¡«å……æˆ¿é—´å†…å®¹ ---
        if not floor_data:
            print("é”™è¯¯: æœªæä¾›æ¥¼å±‚æ•°æ®ï¼Œæ— æ³•å¡«å……å†…å®¹ï¼")
            return

        # å®šä½Bossæˆ¿é—´ (é€»è¾‘ä¸å˜)
        self.start_room = self.rooms[(sx, sy)]
        farthest_dist = -1
        boss_coord = (sx, sy)
        for coord in self.rooms.keys():
            dist = abs(coord[0] - sx) + abs(coord[1] - sy)
            if dist > farthest_dist and self.rooms[coord] is not self.start_room:
                farthest_dist = dist
                boss_coord = coord
        self.boss_room = self.rooms[boss_coord]
        self.boss_room.type = "boss"
        
        # ç¡®å®šç‰¹æ®Šæˆ¿é—´ç±»å‹å’Œæ•°é‡ (é€»è¾‘ä¸å˜)
        room_type_pool = ["combat"] * 4 + ["event"] * 2 + ["treasure"]*2 + ["shop", "rest", "elite"]
        special_room_candidates = [r for r in self.rooms.values() if r.type == "combat"]
        for room_type in ["event", "treasure", "shop", "rest", "elite"]:
            if special_room_candidates:
                candidate = random.choice(special_room_candidates)
                candidate.type = room_type
                special_room_candidates.remove(candidate)

        # åŠ¨æ€å¡«å……æ€ªç‰©
        m_uid = 0
        for room in self.rooms.values():
            if room.type in ["combat", "elite", "boss"]:
                num = 1
                e_id = "slime" # é»˜è®¤å€¼

                if room.type == "boss":
                    num = 1
                    e_id = floor_data.get("boss_id", "ruin_golem")
                elif room.type == "elite":
                    num = random.randint(2, 3)
                    if floor_data.get("elite_pool"):
                        e_id = random.choice(floor_data["elite_pool"])
                else: # æ™®é€šæˆ˜æ–—
                    num = random.randint(1, 3)
                    if floor_data.get("monster_pool"):
                        e_id = random.choice(floor_data["monster_pool"])
                
                for _ in range(num):
                    px, py = random.randint(100, SCREEN_WIDTH - 100), random.randint(100, SCREEN_HEIGHT - 100)
                    room.monsters.append({'id': e_id, 'pos': (px, py), 'uid': f'm_{m_uid}'})
                    m_uid += 1


================================================================================
### æ–‡ä»¶è·¯å¾„: enemies.json
================================================================================

{
    "slime": {
        "name": "å²è±å§†",
        "stats": {
            "hp": 20,
            "defense": 2,
            "magic_resist": 0,
            "attack": 5,
            "attack_speed": 1.0
        },
        "exp_reward": 5,
        "possible_talents": [{"talent_class_name": "PoisonousTalent", "chance": 0.5}]
    },
    "goblin": {
        "name": "å“¥å¸ƒæ—",
        "stats": {
            "hp": 40,
            "defense": 4,
            "magic_resist": 2,
            "attack": 8,
            "attack_speed": 1.2
        },
        "exp_reward": 8,
        "possible_talents": [{"talent_class_name": "DualWieldTalent", "chance": 0.5}]
        
    },
    "goblin_archer": {
        "name": "å“¥å¸ƒæ—å¼“ç®­æ‰‹", "exp_reward": 30,
        "stats": {"hp": 60, "defense": 2, "magic_resist": 1, "attack": 10, "attack_speed": 1.8},
        "possible_talents": [{"talent_class_name": "FirstStrike", "chance": 0.15}]
    },
    "goblin_captain": {
        "name": "å“¥å¸ƒæ—é˜Ÿé•¿", "exp_reward": 80,
        "stats": {"hp": 150, "defense": 8, "magic_resist": 5, "attack": 18, "attack_speed": 1.2},
        "possible_talents": [{"talent_class_name": "Brawler", "chance": 0.5}]
    },
    "armored_skeleton": {
        "name": "é‡ç”²éª·é«…", "exp_reward": 40,
        "stats": {"hp": 100, "defense": 20, "magic_resist": 5, "attack": 15, "attack_speed": 0.8}
    },
    "giant_bat": {
        "name": "å·¨å‹è™è ", "exp_reward": 35,
        "stats": {"hp": 70, "defense": 3, "magic_resist": 3, "attack": 10, "attack_speed": 2.5}
    },
    "wild_boar": {
        "name": "ç‹‚é‡é‡çŒª", "exp_reward": 50,
        "stats": {"hp": 200, "defense": 5, "magic_resist": 2, "attack": 20, "attack_speed": 1.0}
    },
    "forest_spirit": {
        "name": "æ£®æ—ä¹‹çµ", "exp_reward": 60,
        "stats": {"hp": 120, "defense": 5, "magic_resist": 15, "attack": 15, "attack_speed": 1.1},
        "possible_talents": [{"talent_class_name": "MagicShield", "chance": 1.0}]
    },
    "rock_golem": {
        "name": "å²©çŸ³å‚€å„¡", "exp_reward": 70,
        "stats": {"hp": 300, "defense": 15, "magic_resist": 10, "attack": 22, "attack_speed": 0.7},
        "possible_talents": [{"talent_class_name": "Giant", "chance": 1.0}]
    },
    "ruin_golem": {
        "name": "é—è¿¹å®ˆæŠ¤è€…", "exp_reward": 200,
        "stats": {"hp": 500, "defense": 25, "magic_resist": 15, "attack": 30, "attack_speed": 0.9},
        "possible_talents": [{"talent_class_name": "LastStand", "chance": 1.0}]
    },
    "mimic": {
        "name": "å®ç®±æ€ª", "exp_reward": 100,
        "stats": {"hp": 150, "defense": 10, "magic_resist": 10, "attack": 25, "attack_speed": 1.5}

    },
    "fire_elemental": {
        "name": "ç«ç„°å…ƒç´ ", "exp_reward": 120,
        "stats": {"hp": 180, "defense": 8, "magic_resist": 20, "attack": 28, "attack_speed": 1.3},
        "possible_talents": [{"talent_class_name": "FlameAura", "chance": 1.0}]
    },
    "ice_elemental": {
        "name": "å†°éœœå…ƒç´ ", "exp_reward": 120,
        "stats": {"hp": 180, "defense": 8, "magic_resist": 20, "attack": 28, "attack_speed": 1.3},
        "possible_talents": [{"talent_class_name": "FrostAura", "chance": 1.0}]
    },
    "orc_warrior": {
        "name": "å…½äººæˆ˜å£«", "exp_reward": 150,
        "stats": {"hp": 250, "defense": 12, "magic_resist": 5, "attack": 35, "attack_speed": 1.0},
        "possible_talents": [{"talent_class_name": "Berserker", "chance": 0.5}]
    },
    "orc_shaman": {
        "name": "å…½äººè¨æ»¡", "exp_reward": 150,
        "stats": {"hp": 200, "defense": 8, "magic_resist": 15, "attack": 30, "attack_speed": 1.2},
        "possible_talents": [{"talent_class_name": "HealingWave", "chance": 0.5}]
    },
    "dark_knight": {
        "name": "é»‘æš—éª‘å£«", "exp_reward": 300,
        "stats": {"hp": 400, "defense": 20, "magic_resist": 10, "attack": 50, "attack_speed": 1.0},
        "possible_talents": [{"talent_class_name": "Executioner", "chance": 1.0}]
    },
    "necromancer": {
        "name": "æ­»çµæ³•å¸ˆ", "exp_reward": 250,
        "stats": {"hp": 300, "defense": 10, "magic_resist": 25, "attack": 40, "attack_speed": 1.1},
        "possible_talents": [{"talent_class_name": "SummonSkeletons", "chance": 1.0}]
    },
    "poisonDragon": {
        "name": "æ¯’é¾™",
        "stats": {
            "hp": 800,
            "defense": 14,
            "magic_resist": 2,
            "attack": 8,
            "attack_speed": 1.2
        },
        "talents": [
            "PoisonousTalent",
            "BambooLeafTalent"
        ],
        "exp_reward": 800
    }
}


================================================================================
### æ–‡ä»¶è·¯å¾„: Equips.py
================================================================================

import Buffs
import Talents
from damage import DamagePacket, DamageType
from abc import ABC
import collections
from collections import defaultdict
from rich.console import Console, Group
from rich.live import Live
from rich.table import Table
from rich.panel import Panel
from rich.text import Text
import time
import random
from rich.text import Text
from rich.progress import BarColumn
import math
from collections import Counter
import sys

class Equipment:
    slot = None
    def on_battle_start(self, wearer): pass
    def before_attack(self, wearer, target, dmg): return dmg
    def after_attack(self, wearer, target, dmg): pass
    def before_take_damage(self, wearer, dmg): return dmg
    def on_critical(self, wearer, target, dmg): pass
    def on_non_critical(self, wearer, target, dmg): pass

class WoodenShield(Equipment):
    """æœ¨ç›¾ï¼šå‰¯æ‰‹æ’æ§½ï¼›+2 é˜²å¾¡ï¼›æˆ˜æ–—å¼€å§‹æ—¶è·å¾— 10 æŠ¤ç›¾"""
    slot = "offhand"
    display_name    = "æœ¨ç›¾"

    def __init__(self):
        self.type = "armor"
        self.def_bonus    = 2
        self.shield_bonus = 10

    def on_battle_start(self, wearer):
        # é˜²å¾¡æ˜¯æ°¸ä¹…å±æ€§ï¼Œç”±Character.__init__å¤„ç†
        wearer.shield  += self.shield_bonus

class WoodenSword(Equipment):
    """æœ¨å‰‘ï¼šæ­¦å™¨æ’æ§½ï¼›+3 æ”»å‡»ï¼›æ¯æ™®æ”» 3 æ¬¡ï¼Œç¬¬ 4 æ¬¡æ™®æ”»é€ æˆåŒå€ä¼¤å®³"""
    slot = "weapon"
    display_name    = "æœ¨å‰‘"

    def __init__(self):
        self.type = "weapon"
        self.rarity = "common"
        self.atk_bonus = 3
        self._count    = 0
    
    # on_battle_start å·²è¢«ç§»é™¤ï¼Œå› ä¸ºæ”»å‡»æ˜¯æ°¸ä¹…å±æ€§

    def before_attack(self, wearer, target, packet: DamagePacket):
        # æ•ˆæœç°åœ¨ä¿®æ”¹çš„æ˜¯ä¼¤å®³åŒ…çš„æ•°å€¼
        if self._count >= 3:
            packet.amount *= 2
            self._count = 0

    def after_attack(self, wearer, target, actual_dmg):
        # è¿™é‡Œçš„dmgæ˜¯é€ æˆä¼¤å®³åçš„æœ€ç»ˆæ•°å€¼ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨
        if actual_dmg <= wearer.base_attack:
            self._count += 1

class WoodenSword_Star(Equipment):
    """æœ¨å‰‘â­ï¼šæ­¦å™¨æ’æ§½ï¼›+6 æ”»å‡»ï¼›ç°åœ¨æ¯æ”»å‡» 2 æ¬¡ï¼Œç¬¬ 3 æ¬¡æ™®æ”»é€ æˆåŒå€ä¼¤å®³ã€‚"""
    slot = "weapon"
    display_name = "æœ¨å‰‘â­"
    
    def __init__(self):
        self.type = "weapon"
        self.rarity = "uncommon" # å‡çº§åï¼Œå“è´¨ä¹Ÿæå‡äº†
        self.atk_bonus = 6       # åŸºç¡€æ”»å‡»æ›´é«˜
        self._count = 0

    def before_attack(self, wearer, target, packet: DamagePacket):
        # æ•ˆæœå¢å¼ºï¼šä»3æ¬¡è§¦å‘æ”¹ä¸º2æ¬¡è§¦å‘
        if self._count >= 2:
            packet.amount *= 2
            self._count = 0

    def after_attack(self, wearer, target, actual_dmg):
        # è¿™é‡Œçš„dmgæ˜¯é€ æˆä¼¤å®³åçš„æœ€ç»ˆæ•°å€¼ï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨
        self._count += 1

class WoodenArmor(Equipment):
    """æœ¨é“ ç”²ï¼šæŠ¤ç”²æ’æ§½ï¼›+2 é˜²å¾¡ï¼›30% æ¦‚ç‡é¢å¤–å‡å… 30% ç‚¹ç‰©ç†ä¼¤å®³"""
    slot = "armor"
    display_name    = "æœ¨é“ ç”²"

    def __init__(self):
        self.type = "armor"
        self.rarity = "common"
        self.def_bonus = 2

    # on_battle_start å·²è¢«ç§»é™¤ï¼Œå› ä¸ºé˜²å¾¡æ˜¯æ°¸ä¹…å±æ€§

    def before_take_damage(self, wearer, packet: DamagePacket):
        # æ•ˆæœç°åœ¨åªå¯¹ç‰©ç†ä¼¤å®³ç”Ÿæ•ˆ
        if packet.damage_type == DamageType.PHYSICAL and random.random() < 0.3:
            packet.amount = max(0, packet.amount * 0.7)

class WoodenArmor_Star(Equipment):
    """æœ¨é“ ç”²â­ï¼šæŠ¤ç”²æ’æ§½ï¼›+5 é˜²å¾¡ï¼›50% æ¦‚ç‡é¢å¤–å‡å… 50% ç‚¹ç‰©ç†ä¼¤å®³"""
    slot = "armor"
    display_name = "æœ¨é“ ç”²â­"

    def __init__(self):
        self.type = "armor"
        self.rarity = "uncommon"
        self.def_bonus = 5 # åŸºç¡€é˜²å¾¡æ›´é«˜

    def before_take_damage(self, wearer, packet: DamagePacket):
        # æ•ˆæœç°åœ¨åªå¯¹ç‰©ç†ä¼¤å®³ç”Ÿæ•ˆ
        if packet.damage_type == DamageType.PHYSICAL and random.random() < 0.5:
            packet.amount = max(0, packet.amount * 0.5)

class IronSword(Equipment):
    """é“å‰‘ï¼šæ­¦å™¨æ’æ§½ï¼›+5 æ”»å‡»ï¼›åŸºç¡€ +5% æš´å‡»ç‡ï¼›æœªæš´å‡»æ—¶ï¼Œä¸‹æ¬¡æ™®æ”»æš´å‡»ç‡ +5%ï¼Œæœ€å¤š 8 å±‚ï¼›æš´å‡»åæ¸…é™¤"""
    slot = "weapon"
    display_name = "é“å‰‘"
    def __init__(self):
        self.rarity = "common"
        self.type = "weapon"
        self.atk_bonus = 5
        self.base_crit_bonus = 0.05
        self.max_stacks = 8
        self._stacks = 0
    def on_battle_start(self, wearer):
        # æ”»å‡»å’Œæš´å‡»éƒ½æ˜¯æ°¸ä¹…å±æ€§
        # ä½†æš´å‡»ç‡éœ€è¦åœ¨æˆ˜æ–—ä¸­åŠ¨æ€å˜åŒ–ï¼Œæ‰€ä»¥æˆ‘ä»¬éœ€è¦åœ¨æˆ˜å‰è®¾ç½®åˆå§‹å€¼
        wearer.crit_chance += self.base_crit_bonus
    def on_critical(self, wearer, target, dmg):
        wearer.crit_chance -= self._stacks * self.base_crit_bonus
        self._stacks = 0
    def on_non_critical(self, wearer, target, dmg):
        if self._stacks < self.max_stacks:
            self._stacks += 1
            wearer.crit_chance += self.base_crit_bonus

class IronRing(Equipment):
    """é“æˆ’æŒ‡ï¼šé¥°å“æ§½ï¼›+5% æš´å‡»ï¼›+10% çˆ†ä¼¤ï¼›èµ é€ä¸¤å±‚â€œåˆšæ¯…â€Buff"""
    slot = "accessory"
    display_name = "é“æˆ’æŒ‡"
    def __init__(self):
        self.rarity = "common"
        self.type = "misc" # æ·»åŠ ç±»å‹
        self.crit_bonus = 0.05
        self.crit_dmg_bonus = 0.10
    def on_battle_start(self, wearer):
        # æš´å‡»å’Œçˆ†ä¼¤æ˜¯æ°¸ä¹…å±æ€§
        # åªä¿ç•™æˆ˜æ–—å¼€å§‹æ—¶çš„æ•ˆæœ
        wearer.add_status(Buffs.SteelHeartBuff(uses=2))

class IronHammer(Equipment):
    """é“é”¤ï¼šæ­¦å™¨æ§½ï¼›+8 æ”»å‡»ï¼›+5% æš´å‡»ï¼›20% æ¦‚ç‡çœ©æ™•æ•Œäºº 2 ç§’"""
    slot = "weapon"
    display_name = "é“é”¤"
    def __init__(self):
        self.rarity = "uncommon"
        self.type = "weapon"
        self.atk_bonus = 8
        self.crit_chance_bonus = 0.05
        self.stun_chance = 0.20
        self.stun_duration = 2.0
    def on_battle_start(self, wearer):
        # æ”»å‡»å’Œæš´å‡»æ˜¯æ°¸ä¹…å±æ€§
        pass
    def after_attack(self, wearer, target, dmg):
        if random.random() < self.stun_chance:
            target.add_status(Buffs.StunDebuff(self.stun_duration), source=wearer)

class NaturalNecklace(Equipment):
    """è‡ªç„¶é¡¹é“¾ï¼šé¥°å“æ§½ï¼›æœ€å¤§ HP +20ï¼›æä¾› 2 å±‚â€œå†ç”Ÿâ€Buff"""
    slot = "accessory"
    display_name = "è‡ªç„¶é¡¹é“¾"
    def __init__(self):
        self.rarity = "uncommon"
        self.type = "misc" # æ·»åŠ ç±»å‹
        self.hp_bonus = 20
    def on_battle_start(self, wearer):
        # HPæ˜¯æ°¸ä¹…å±æ€§
        # åªä¿ç•™æˆ˜æ–—å¼€å§‹æ—¶çš„æ•ˆæœ
        wearer.add_status(Buffs.RegenerationBuff(stacks=2))

class ThornsRing(Equipment):
    """è†æ£˜ç¯ï¼šé¥°å“æ§½ï¼›+0.2 æ”»é€Ÿï¼›+10% çˆ†ä¼¤ï¼›æˆ˜æ–—å¼€å§‹æ—¶æä¾› 3 å±‚ è†æ£˜"""
    slot = "accessory"
    display_name = "è†æ£˜ç¯"
    def __init__(self):
        self.rarity = "uncommon"
        self.type = "misc" # æ·»åŠ ç±»å‹
        self.atk_speed_bonus = 0.2
        self.crit_damage_bonus = 0.10
        self.thorns_stacks = 3
    def on_battle_start(self, wearer):
        # æ”»é€Ÿå’Œçˆ†ä¼¤æ˜¯æ°¸ä¹…å±æ€§
        # åªä¿ç•™æˆ˜æ–—å¼€å§‹æ—¶çš„æ•ˆæœ
        wearer.add_status(Buffs.ThornsBuff(stacks=self.thorns_stacks))

class PhoenixCrown(Equipment):
    """ç´«é‡‘å† ï¼šå¤´ç›”æ§½ï¼›æ— åŸºç¡€å±æ€§ï¼›é™„åŠ â€œä¸ç­â€æ•ˆæœ"""
    slot = "helmet"
    display_name = "ç´«é‡‘å† "
    def __init__(self):
        self.rarity = "legendary"
        self.type = "armor" # æ·»åŠ ç±»å‹
    def on_battle_start(self, wearer):
        # è¿™ä¸ªè®¾è®¡æ˜¯å®Œç¾çš„ï¼Œåªæ·»åŠ Buff
        wearer.add_buff(Buffs.PhoenixCrownStage1Buff())

class SlimeSword(Equipment):
    """å²è±å§†ä¹‹å‰‘ï¼šæ­¦å™¨ï¼›+6 æ”»å‡»ï¼›æ”»å‡»æ—¶æœ‰15%æ¦‚ç‡ä½¿æ•Œäººä¸­æ¯’1å±‚"""
    slot = "weapon"
    display_name = "å²è±å§†ä¹‹å‰‘"
    def __init__(self):
        self.rarity = "common"
        self.type = "weapon"
        self.atk_bonus = 6
        self.poison_chance = 0.15
    def on_battle_start(self, wearer):
        # æ”»å‡»æ˜¯æ°¸ä¹…å±æ€§
        pass
    def after_attack(self, wearer, target, dmg):
        if random.random() < self.poison_chance:
            target.add_debuff(Buffs.PoisonDebuff(stacks=1), source=wearer)


class VampiresFang(Equipment):
    """å¸è¡€é¬¼ä¹‹ç‰™ï¼šé¥°å“æ§½ï¼›æ”»å‡»é€ æˆ10%ç”Ÿå‘½å·å–ï¼Œç”Ÿå‘½ä½äº50%æ—¶æ•ˆæœç¿»å€ã€‚"""
    slot = "accessory"
    display_name = "å¸è¡€é¬¼ä¹‹ç‰™"
    def __init__(self):
        self.rarity, self.type = "rare", "misc"
        self.lifesteal_ratio = 0.10

    # after_attack ç°åœ¨æ¥æ”¶çš„æ˜¯æœ€ç»ˆä¼¤å®³æ•°å€¼
    def after_attack(self, wearer, target, actual_dmg):
        ratio = self.lifesteal_ratio
        if wearer.hp / wearer.max_hp < 0.5:
            ratio *= 2
        
        healed_amount = actual_dmg * ratio
        if healed_amount > 0:
            wearer.heal(healed_amount)

class HourglassOfTime(Equipment):
    """æ—¶å…‰æ²™æ¼ï¼šå‰¯æ‰‹æ§½ï¼›æš´å‡»æ—¶æœ‰40%å‡ ç‡ç«‹å³é‡ç½®æ”»å‡»å†·å´ã€‚"""
    slot = "offhand"
    display_name = "æ—¶å…‰æ²™æ¼"
    def __init__(self):
        self.rarity, self.type = "uncommon", "armor" # å‰¯æ‰‹ç®—é˜²å…·
        self.proc_chance = 0.4

    def on_critical(self, wearer, target, dmg):
        if random.random() < self.proc_chance:
            print("[æ—¶å…‰æ²™æ¼] æ•ˆæœè§¦å‘ï¼")
            # ç›´æ¥å°†æ”»å‡»å†·å´å……æ»¡
            wearer._cd = wearer.attack_interval

class Stormcaller(Equipment):
    """é£æš´å¬å”¤è€…ï¼šæ­¦å™¨æ§½ï¼›+15æ”»å‡»ï¼›æ¯æ”»å‡»4æ¬¡ï¼Œä¸ºæ•Œäººé™„åŠ ä¸€å±‚ã€é£æš´ã€‘å°è®°ã€‚"""
    slot = "weapon"
    display_name = "é£æš´å¬å”¤è€…"
    def __init__(self):
        self.rarity, self.type = "legendary", "weapon"
        self.atk_bonus = 15
        self._attack_count = 0

    def after_attack(self, wearer, target, dmg):
        self._attack_count += 1
        if self._attack_count >= 4:
            self._attack_count = 0
            print("[é£æš´å¬å”¤è€…] é™„åŠ äº†é£æš´å°è®°ï¼")
            target.add_debuff(Buffs.StormDebuff(), source=wearer)
# --- ç™½è‰² (Common) å“è´¨æ–°è£…å¤‡ ---

class LeatherGloves(Equipment):
    """çš®æ‰‹å¥—ï¼šå‰¯æ‰‹æ§½ï¼›+0.3 æ”»å‡»é€Ÿåº¦ã€‚"""
    slot = "offhand"
    display_name = "çš®æ‰‹å¥—"
    def __init__(self):
        self.rarity, self.type = "common", "armor"
        self.atk_speed_bonus = 0.3

class RustyHelmet(Equipment):
    """ç”Ÿé”ˆçš„å¤´ç›”ï¼šå¤´ç›”æ§½ï¼›+30 æœ€å¤§ç”Ÿå‘½å€¼ã€‚"""
    slot = "helmet"
    display_name = "ç”Ÿé”ˆçš„å¤´ç›”"
    def __init__(self):
        self.rarity, self.type = "common", "armor"
        self.hp_bonus = 30

# --- ç»¿è‰² (Uncommon) å“è´¨æ–°è£…å¤‡ ---

class BarbedAxe(Equipment):
    """å€’é’©æ–§ï¼šæ­¦å™¨æ§½ï¼›+5æ”»å‡»ï¼›æ”»å‡»æ—¶æœ‰30%å‡ ç‡ä½¿æ•Œäººã€æµè¡€ã€‘5ç§’ã€‚"""
    slot = "weapon"
    display_name = "å€’é’©æ–§"
    def __init__(self):
        self.rarity, self.type = "uncommon", "weapon"
        self.atk_bonus = 5
        self.bleed_chance = 0.3
    def after_attack(self, wearer, target, dmg):
        if random.random() < self.bleed_chance:
            target.add_debuff(Buffs.BleedDebuff(stacks=1), source=wearer)

# åœ¨ Equips.py æ–‡ä»¶ä¸­ï¼Œæ‰¾åˆ°å¹¶æ›¿æ¢ TowerShield ç±»

class TowerShield(Equipment):
    """å¡”ç›¾ï¼šå‰¯æ‰‹æ§½ï¼›+3é˜²å¾¡ï¼›æˆ˜æ–—å¼€å§‹æ—¶ï¼Œè·å¾—3å±‚ã€æ ¼æŒ¡ã€‘ã€‚"""
    slot = "offhand"
    display_name = "å¡”ç›¾"
    def __init__(self):
        self.rarity, self.type = "uncommon", "armor"
        self.def_bonus = 3
        self.block_stacks = 3

    def on_battle_start(self, wearer):
        wearer.add_buff(Buffs.BlockBuff(stacks=self.block_stacks))
    

# --- è“è‰² (Rare) å“è´¨æ–°è£…å¤‡ ---


class AdventurersPouch(Equipment):
    """å†’é™©å®¶çš„é’±è¢‹ï¼šé¥°å“æ§½ï¼›æ¯æ‹¥æœ‰20é‡‘å¸ï¼Œå°±ä¸ºä½ æä¾›+1æ”»å‡»åŠ›ã€‚ï¼ˆæˆ˜æ–—å¼€å§‹æ—¶ç»“ç®—ï¼‰"""
    slot = "accessory"
    display_name = "å†’é™©å®¶çš„é’±è¢‹"
    def __init__(self):
        self.rarity, self.type = "rare", "misc"
        self.atk_bonus = 0 # åˆå§‹æ”»å‡»åŠ›åŠ æˆä¸º0

    def on_battle_start(self, wearer):
        # åœ¨æˆ˜æ–—å¼€å§‹æ—¶ï¼Œåªè®¡ç®—åº”è¯¥åŠ å¤šå°‘æ”»å‡»åŠ›ï¼Œå¹¶å­˜åˆ°è‡ªå·±çš„å±æ€§é‡Œ
        gold = getattr(wearer, 'gold', 0)
        self.atk_bonus = gold // 20
        if self.atk_bonus > 0:
            print(f"[å†’é™©å®¶çš„é’±è¢‹] ä½ è·å¾—äº† {self.atk_bonus} ç‚¹é¢å¤–æ”»å‡»åŠ›ï¼")
            # é‡æ–°è®¡ç®—ä¸€æ¬¡æ€»å±æ€§ï¼Œè®©è¿™ä¸ªæ–°çš„atk_bonusç”Ÿæ•ˆ
            wearer.recalculate_stats()

class ShadowCloak(Equipment):
    """æš—å½±æ–—ç¯·ï¼šæŠ¤ç”²æ§½ï¼›+5é˜²å¾¡ï¼›å—åˆ°æš´å‡»ä¼¤å®³æ—¶ï¼Œæœ‰30%æ¦‚ç‡å…ç–«è¯¥æ¬¡ä¼¤å®³ã€‚"""
    slot = "armor"
    display_name = "æš—å½±æ–—ç¯·"
    def __init__(self):
        self.rarity, self.type = "rare", "armor"
        self.def_bonus = 5
        self.crit_immunity_chance = 0.3
    def before_take_damage(self, wearer, packet: DamagePacket):
        if packet.damage_type == DamageType.PHYSICAL and packet.is_critical:
            if random.random() < self.crit_immunity_chance:
                print("[æš—å½±æ–—ç¯·] å…ç–«äº†æš´å‡»ä¼¤å®³ï¼")
                packet.amount = 0

# åœ¨ Equips.py æ–‡ä»¶æœ«å°¾æ·»åŠ 

# --- â€œçƒ™å°â€ä½“ç³»ç¤ºä¾‹ ---

class SunScorchedBlade(Equipment):
    """æ—¥ç¼ä¹‹åˆƒ [æ­¦å™¨-ç¨€æœ‰]ï¼šæ”»å‡»é€Ÿåº¦+0.5ï¼›å‘½ä¸­æ—¶é™„åŠ ä¸€å±‚ã€æ—¥ä¹‹çƒ™å°ã€‘ã€‚"""
    slot, display_name = "weapon", "æ—¥ç¼ä¹‹åˆƒ"
    def __init__(self):
        self.rarity, self.type = "rare", "weapon"
        self.atk_speed_bonus = 0.5
    def after_attack(self, wearer, target, actual_dmg):
        target.add_debuff(Buffs.SunstoneBrandDebuff(stacks=1), source=wearer)

class Avalanche(Equipment):
    """å±±å´© [æ­¦å™¨-å²è¯—]ï¼šæ”»å‡»åŠ›+20ï¼›æš´å‡»æ—¶å¼•çˆ†ç›®æ ‡æ‰€æœ‰ã€æ—¥ä¹‹çƒ™å°ã€‘ï¼Œæ¯å±‚é€ æˆ20é¢å¤–çœŸå®ä¼¤å®³ã€‚"""
    slot, display_name = "weapon", "å±±å´©"
    def __init__(self):
        self.rarity, self.type = "epic", "weapon"
        self.atk_bonus = 20
    def on_critical(self, wearer, target, actual_dmg):
        # å¯»æ‰¾ç›®æ ‡èº«ä¸Šçš„çƒ™å°
        brand_debuff = next((b for b in target.buffs if isinstance(b, Buffs.SunstoneBrandDebuff)), None)
        if brand_debuff:
            stacks = brand_debuff.stacks
            print(f"[å±±å´©] å¼•çˆ†äº† {stacks} å±‚çƒ™å°ï¼")
            # é€ æˆé¢å¤–ä¼¤å®³
            extra_dmg = stacks * 20
            packet = DamagePacket(amount=extra_dmg, damage_type=DamageType.TRUE, source=wearer)
            target.take_damage(packet)
            # ç§»é™¤çƒ™å°
            target.remove_buff(brand_debuff)

# --- â€œé¾™é­‚â€ä½“ç³»ç¤ºä¾‹ ---

class DragonBloodChalice(Equipment):
    """é¾™è¡€é…’æ¯ [é¥°å“-å²è¯—]ï¼šæ¯ç§’å¤±å»5ç‚¹ç”Ÿå‘½ï¼Œä½†è·å¾—1å±‚ã€é¾™é­‚ã€‘ã€‚"""
    slot, display_name = "accessory", "é¾™è¡€é…’æ¯"
    def __init__(self):
        self.rarity, self.type = "epic", "misc"
        self._timer = 0.0
    def on_battle_start(self, wearer):
        self._timer = 0.0 # é‡ç½®è®¡æ—¶å™¨
    def on_tick(self, wearer, dt): # éœ€è¦åœ¨ Character.update ä¸­è°ƒç”¨ on_tick
        self._timer += dt
        if self._timer >= 1.0:
            self._timer -= 1.0
            # æ‰£è¡€
            packet = DamagePacket(amount=5, damage_type=DamageType.TRUE, is_sourceless=True)
            wearer.take_damage(packet)
            # è·å¾—é¾™é­‚
            wearer.add_buff(Buffs.DragonSoulBuff(stacks=1))

class DragonscaleWard(Equipment):
    """é¾™é³ç›¾ [å‰¯æ‰‹-ç¨€æœ‰]ï¼šæˆ˜æ–—å¼€å§‹æ—¶ï¼Œæ¶ˆè€—æ‰€æœ‰ã€é¾™é­‚ã€‘ï¼Œæ¯å±‚æä¾›15ç‚¹æŠ¤ç›¾ã€‚"""
    slot, display_name = "offhand", "é¾™é³ç›¾"
    def __init__(self):
        self.rarity, self.type = "rare", "armor"
    def on_battle_start(self, wearer):
        soul_buff = next((b for b in wearer.buffs if isinstance(b, Buffs.DragonSoulBuff)), None)
        if soul_buff:
            stacks = soul_buff.stacks
            shield_gain = stacks * 15
            print(f"[é¾™é³ç›¾] æ¶ˆè€—äº† {stacks} å±‚é¾™é­‚ï¼Œè·å¾—äº† {shield_gain} ç‚¹æŠ¤ç›¾ï¼")
            wearer.shield += shield_gain
            wearer.remove_buff(soul_buff)

UPGRADE_MAP = {
    WoodenSword: WoodenSword_Star,
    WoodenArmor: WoodenArmor_Star,
    # åœ¨è¿™é‡Œç»§ç»­ä¸ºä½ å…¶ä»–çš„è£…å¤‡æ·»åŠ å‡çº§é…æ–¹...
    # ä¾‹å¦‚:
    # IronSword: IronSword_Star, 
}


================================================================================
### æ–‡ä»¶è·¯å¾„: events.json
================================================================================

{
    "fountain_of_power": {
        "title": "åŠ›é‡æºæ³‰",
        "description": "ä½ å‘ç°ä¸€ä¸ªæ•£å‘ç€å¾®å…‰çš„æºæ³‰ã€‚æ³‰æ°´ä¼¼ä¹è•´å«ç€å¥‡ç‰¹çš„åŠ›é‡ï¼Œä½ å¯ä»¥ä»ä¸­æ„Ÿå—åˆ°ç”Ÿå‘½ä¸æ¯ç­çš„æ°”æ¯ã€‚",
        "choices": [
            {
                "text": "å–ä¸€å£ (æ¢å¤å…¨éƒ¨ç”Ÿå‘½)",
                "outcomes": [
                    { "type": "HEAL", "amount": "full", "result_text": "æ³‰æ°´è®©ä½ ç²¾ç¥ç„•å‘ï¼Œæ‰€æœ‰ä¼¤ç—›éƒ½æ¶ˆå¤±äº†ï¼" }
                ]
            },
            {
                "text": "å°†æ­¦å™¨æµ¸å…¥ (é£é™©ä¸æœºé‡)",
                "outcomes": [
                    { "type": "WEAPON_UPGRADE", "chance": 0.6, "result_text": "ä½ çš„æ­¦å™¨å¸æ”¶äº†æºæ³‰çš„åŠ›é‡ï¼Œå˜å¾—æ›´åŠ é”‹åˆ©äº†ï¼(æ”»å‡»åŠ›+5)" },
                    { "type": "WEAPON_CURSE", "chance": 0.4, "result_text": "æ­¦å™¨æ— æ³•æ‰¿å—è¿™è‚¡åŠ›é‡ï¼Œåè€Œå˜å¾—è¿Ÿé’äº†...(æ”»å‡»åŠ›-3)" }
                ]
            }
        ]
    },
    "wandering_spirit": {
        "title": "è¿·é€”çš„å¤ä»£çµé­‚",
        "description": "ä¸€ä¸ªåŠé€æ˜çš„çµé­‚åœ¨ä½ é¢å‰å¾˜å¾Šï¼Œå®ƒä¼¼ä¹åœ¨å¯»æ±‚å¸®åŠ©ï¼Œåˆåƒæ˜¯åœ¨å®ˆæŠ¤ç€ä»€ä¹ˆã€‚",
        "choices": [
            {
                "text": "å¸®åŠ©å®ƒå®‰æ¯ (è·å¾—å¤©èµ‹)",
                "outcomes": [
                    { "type": "GAIN_TALENT", "talent_class_name": "HeartOfHealingTalent", "result_text": "çµé­‚æ„Ÿæ¿€åœ°æ¶ˆæ•£äº†ï¼Œä½ ä»ä¸­é¢†æ‚Ÿäº†ã€Œæ²»æ„ˆä¹‹å¿ƒã€ï¼" }
                ]
            },
            {
                "text": "æ”»å‡»å®ƒ (è§¦å‘æˆ˜æ–—)",
                "outcomes": [
                    { "type": "TRIGGER_COMBAT", "enemy_id": "goblin_captain", "result_text": "çµé­‚å‘å‡ºäº†å°–å•¸ï¼ŒåŒ–ä½œä¸€ä¸ªå¼ºå¤§çš„æ•Œäººå‘ä½ è¢­æ¥ï¼" }
                ]
            }
        ]
    }
}


================================================================================
### æ–‡ä»¶è·¯å¾„: game.py
================================================================================

# game.py (å·²æ›´æ–°)
import pygame
import pickle
import os
import time
import json
import sys
from settings import *
# <-- å¯¼å…¥ ui æ¨¡å—ï¼Œè€Œä¸ä»…ä»…æ˜¯ init_fonts
import ui
from Character import Character
import Equips
import Talents

class Game:
    def __init__(self):
        pygame.init()
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("æˆ‘çš„æ¸¸æˆ")
        self.clock = pygame.time.Clock()
        self.running = True
        self.fonts = ui.init_fonts()
        self.state_stack = []

        # <-- æ ¸å¿ƒæ”¹åŠ¨ï¼šåœ¨æ¸¸æˆå¯åŠ¨æ—¶åŠ è½½æ‰€æœ‰Buffå›¾æ ‡èµ„æº -->
        #ui.load_buff_icons()

        self.player = None
        self.current_stage = "1"
        self.loaded_dialogue_index = 0

        self.story_data = self._load_json("story.json")
        self.enemy_data = self._load_json("enemies.json")
        self.loot_data = self._load_json("loot_tables.json")
        self.event_data = self._load_json("events.json")

        self.dungeon_data = {}
        dungeon_folder = 'dungeons'
        for filename in os.listdir(dungeon_folder):
            if filename.endswith('.json'):
                dungeon_id = filename.split('.')[0]
                self.dungeon_data[dungeon_id] = self._load_json(os.path.join(dungeon_folder, filename))

    def run(self):
        from states.title import TitleScreen
        self.state_stack.append(TitleScreen(self))

        while self.running and self.state_stack:
            self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(60)
        
        pygame.quit()
        sys.exit()

    def handle_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            if self.state_stack:
                self.state_stack[-1].handle_event(event)

    def update(self):
        if self.state_stack:
            self.state_stack[-1].update()

    def draw(self):
        # --- å…¨æ–°çš„åˆ†å±‚ç»˜åˆ¶é€»è¾‘ ---
        if not self.state_stack:
            pygame.display.flip()
            return

        # 1. æ‰¾åˆ°æœ€åº•éƒ¨çš„éå¼¹çª—ç•Œé¢
        base_state_index = -1
        for i in range(len(self.state_stack) - 1, -1, -1):
            if not getattr(self.state_stack[i], 'is_overlay', False):
                base_state_index = i
                break
        
        # 2. ç»˜åˆ¶æ‰€æœ‰åº•å±‚ç•Œé¢ (é€šå¸¸åªæœ‰ä¸€ä¸ª)
        if base_state_index != -1:
            for i in range(base_state_index + 1):
                 self.state_stack[i].draw(self.screen)

        # 3. é€ä¸ªç»˜åˆ¶æ‰€æœ‰å¼¹çª—ç•Œé¢
        for i in range(base_state_index + 1, len(self.state_stack)):
            self.state_stack[i].draw(self.screen)
        
        pygame.display.flip()

    def _load_json(self, filename):
        try:
            with open(filename, 'r', encoding='utf-8') as f: return json.load(f)
        except Exception as e:
            print(f"ERROR: Could not load {filename}: {e}")
            return None

    def get_save_filename(self, slot_number):
        return f"save_slot_{slot_number}.dat"

    def peek_save_slot(self, slot_number):
        filename = self.get_save_filename(slot_number)
        if not os.path.exists(filename): return None
        try:
            with open(filename, "rb") as f: return pickle.load(f)
        except Exception: return None

    def save_to_slot(self, slot_number):
        filename = self.get_save_filename(slot_number)
        try:
            dialogue_index = 0
            from states.story import StoryScreen
            for state in reversed(self.state_stack):
                if isinstance(state, StoryScreen):
                    dialogue_index = state.dialogue_index; break
            data_to_save = {
                "player": self.player, "current_stage": self.current_stage,
                "dialogue_index": dialogue_index, "timestamp": time.time()
            }
            with open(filename, "wb") as f: pickle.dump(data_to_save, f)
            print(f"Game saved to slot {slot_number}")
            return f"æˆåŠŸä¿å­˜åˆ°æ§½ä½ {slot_number}ï¼"
        except Exception as e:
            print(f"Save failed: {e}"); return "å­˜æ¡£å¤±è´¥ï¼"

    def load_from_slot(self, slot_number):
        data = self.peek_save_slot(slot_number)
        if data:
            self.player = data["player"]
            self.current_stage = data["current_stage"]
            self.loaded_dialogue_index = data.get("dialogue_index", 0)
            return True
        return False
   
    def start_new_game(self):
        player_eq = [Equips.WoodenSword(), Equips.WoodenArmor(), Equips.NaturalNecklace(), Equips.IronRing()]#
        player_talents = [
            Talents.HeartOfHealingTalent(), # æ²»æ„ˆä¹‹å¿ƒ
            Talents.DualWieldTalent(),       # äºŒåˆ€æµ
        ]
        self.player = Character(
            "ç©å®¶", 
            hp=300, 
            defense=5, 
            magic_resist=3, 
            attack=20, 
            attack_speed=1.2, 
            equipment=player_eq,
            talents=player_talents  # <-- å°†å¤©èµ‹åˆ—è¡¨ä¼ ç»™è§’è‰²
        )
        self.current_stage = "1"
        self.loaded_dialogue_index = 0


================================================================================
### æ–‡ä»¶è·¯å¾„: loot_tables.json
================================================================================

{
    "slime": [
        {
            "item_class_name": "SlimeSword",
            "chance": 0.99
        }
    ],
    "goblin": [
        {
            "item_class_name": "IronSword",
            "chance": 0.2
        },
        {
            "item_class_name": "WoodenShield",
            "chance": 0.2
        }
    ],
    "goblin_captain": [
        { "item_class_name": "IronHammer", "chance": 0.25 },
        { "item_class_name": "IronRing", "chance": 0.15 }
    ]
}


================================================================================
### æ–‡ä»¶è·¯å¾„: main.py
================================================================================

# main.py
from game import Game
import Equips
print(f"DEBUG: æ­£åœ¨ä»è¿™ä¸ªè·¯å¾„åŠ è½½ Equips.py -> {Equips.__file__}")


if __name__ == "__main__":
    # ç¡®ä¿æ‰€æœ‰é€»è¾‘æ–‡ä»¶ï¼ˆBuffs, Talents, Equips, Characterï¼‰éƒ½å¯è¢«å¯¼å…¥
    # ç¡®ä¿æ‰€æœ‰æ•°æ®æ–‡ä»¶ (.json) éƒ½åœ¨åœº
    g = Game()
    g.run()


================================================================================
### æ–‡ä»¶è·¯å¾„: monster_sprite.py
================================================================================

# monster_sprite.py (å·²æ›´æ–°)
import pygame
from settings import *

class Monster(pygame.sprite.Sprite):
    def __init__(self, monster_data): # <-- æ”¹ä¸ºæ¥æ”¶æ•´ä¸ª data å­—å…¸
        super().__init__()
        self.enemy_id = monster_data['id']
        self.uid = monster_data['uid'] # <-- æ–°å¢ï¼šè®°å½•è‡ªå·±çš„ uid
        
        self.image = pygame.Surface([30, 30])
        color = (255, 0, 0)
        if self.enemy_id == "slime": color = (100, 200, 100)
        elif self.enemy_id == "goblin": color = (200, 150, 50)
        elif self.enemy_id == "ruin_golem": # Bossç”¨å¤§ä¸€ç‚¹çš„æ–¹å—å’Œä¸åŒé¢œè‰²
            self.image = pygame.Surface([60, 60])
            color = (150, 50, 200)
        
        self.image.fill(color)
        self.rect = self.image.get_rect(center=monster_data['pos'])

    def update(self):
        pass


================================================================================
### æ–‡ä»¶è·¯å¾„: player_sprite.py
================================================================================

# player_sprite.py
import pygame
from settings import *

class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.image = pygame.Surface([40, 40])
        self.image.fill(TEXT_COLOR) # æš‚æ—¶ç”¨ä¸€ä¸ªç™½è‰²æ–¹å—ä»£è¡¨ç©å®¶
        self.rect = self.image.get_rect(center=(x, y))
        self.speed = 5

    def update(self):
        """æ ¹æ®æŒ‰é”®æ›´æ–°ç©å®¶ä½ç½®"""
        keys = pygame.key.get_pressed()
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.rect.x -= self.speed
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.rect.x += self.speed
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.rect.y -= self.speed
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.rect.y += self.speed

        # ç®€å•çš„è¾¹ç•Œé™åˆ¶ï¼Œé˜²æ­¢è·‘å‡ºå±å¹•
        if self.rect.left < 0: self.rect.left = 0
        if self.rect.right > SCREEN_WIDTH: self.rect.right = SCREEN_WIDTH
        if self.rect.top < 0: self.rect.top = 0
        if self.rect.bottom > SCREEN_HEIGHT: self.rect.bottom = SCREEN_HEIGHT


================================================================================
### æ–‡ä»¶è·¯å¾„: settings.py
================================================================================

# settings.py
import pygame
SCREEN_WIDTH = 1280
SCREEN_HEIGHT = 720
BG_COLOR = (10, 20, 30)
TEXT_COLOR = (230, 230, 230)
HOVER_COLOR = (200, 220, 255) # é¼ æ ‡æ‚¬åœé¢œè‰²
PANEL_BG_COLOR = (20, 35, 50)
PANEL_BORDER_COLOR = (100, 180, 255)
HP_BAR_GREEN = (0, 200, 0)
SHIELD_BAR_GREY = (150, 150, 150)
FONT_SIZE_NORMAL = 28
FONT_SIZE_SMALL = 22
FONT_SIZE_LARGE = 48
FONT_NAME_CN = 'Microsoft YaHei'
FONT_NAME_EN = 'Consolas'

# --- æ–°å¢é¢œè‰²å’Œå°ºå¯¸ ---
XP_BAR_COLOR = (150, 100, 255)      # ç»éªŒæ¡é¢œè‰²
LOG_TEXT_COLOR = (200, 200, 200)    # æˆ˜æ–—æ—¥å¿—æ–‡å­—é¢œè‰²
LOG_BG_COLOR = (30, 45, 60, 200)    # æˆ˜æ–—æ—¥å¿—èƒŒæ™¯è‰² (å¸¦é€æ˜åº¦)
BUTTON_CLICK_COLOR = (150, 200, 255) # æŒ‰é’®ç‚¹å‡»é¢œè‰²

# Buff/Debuff å›¾æ ‡å°ºå¯¸
BUFF_ICON_SIZE = (32, 32)

# --- å¸ƒå±€ä½ç½® ---
# (è¿™äº›æ˜¯å»ºè®®å€¼ï¼Œä½ å¯ä»¥éšæ—¶è°ƒæ•´)
PLAYER_PANEL_RECT = pygame.Rect(50, 450, 500, 250)
ENEMY_PANEL_RECT = pygame.Rect(SCREEN_WIDTH - 550, 50, 500, 250)
BATTLE_LOG_RECT = pygame.Rect(50, 50, SCREEN_WIDTH - 650, 350)


# --- ç‰©å“å“è´¨é¢œè‰² ---
RARITY_COLORS = {
    "common":    (255, 255, 255),  # ç™½è‰²
    "uncommon":  (30, 255, 30),    # ç»¿è‰²
    "rare":      (0, 150, 255),   # è“è‰²
    "epic":      (180, 50, 255),   # ç´«è‰²
    "legendary": (255, 150, 0),    # æ©™è‰²
    "mythic":    (255, 50, 50),    # çº¢è‰²
}


================================================================================
### æ–‡ä»¶è·¯å¾„: story.json
================================================================================

{
    "1": {
        "type": "story",
        "text": [
            { "speaker": "æ—ç™½", "line": "ä½ çå¼€çœ¼ç›ï¼Œå‘ç°è‡ªå·±èº«å¤„ä¸€ç‰‡å®é™çš„æ£®æ—ä¹‹ä¸­ã€‚" },
            { "speaker": "æ—ç™½", "line": "é˜³å…‰é€è¿‡æ ‘å¶çš„ç¼éš™æ´’ä¸‹ï¼Œç©ºæ°”ä¸­å¼¥æ¼«ç€é’è‰çš„æ°”æ¯ã€‚" },
            { "speaker": "æ—ç™½", "line": "çªç„¶ï¼Œä¸€é˜µâ€œå’•å½å’•å½â€çš„å£°éŸ³ä¼ æ¥ï¼Œä¸€åªæœå†»çŠ¶çš„ç”Ÿç‰©å‡ºç°åœ¨ä½ é¢å‰ï¼" }
        ],
        "next": "2"
    },
    "2": {
        "type": "combat",
        "enemy_id": "slime",
        "next_win": "3",
        "next_lose": "game_over"
    },
    "3": {
        "type": "story",
        "text": [
            { "speaker": "æ—ç™½", "line": "ä½ è½»æ¾åœ°æˆ˜èƒœäº†å²è±å§†ã€‚" },
            { "speaker": "ä½ ", "line": "çœ‹æ¥è¿™é‡Œçš„ç”Ÿç‰©å¹¶æ²¡æœ‰æƒ³è±¡ä¸­é‚£ä¹ˆå¼ºå¤§ã€‚" },
            { "speaker": "ä½ ", "line": "æˆ‘å†³å®šç»§ç»­æ·±å…¥æ£®æ—ï¼Œæ¢ç´¢è¿™ä¸ªæœªçŸ¥çš„ä¸–ç•Œ..." },
            { "speaker": "æ—ç™½", "line": "(æœªå®Œå¾…ç»­)" }
        ],
        "next": "4"
    },
    "4": {
        "type": "story",
        "text": [
            { "speaker": "çŒäºº", "line": "ä½ çš„ç¬¬ä¸€ä¸ªä»»åŠ¡ï¼Œå°±æ˜¯ç‹¬è‡ªè¿›å…¥é‚£åº§ã€æ—¥ä¹‹çŸ³é—è¿¹ã€..." },
            { "speaker": "çŒäºº", "line": "æŠµè¾¾æœ€æ·±å¤„çš„åœ£å ‚ï¼Œå¹¶å¸¦å›è¯•ç‚¼å®Œæˆçš„è¯æ˜ã€‚å‡†å¤‡å¥½äº†å—ï¼Ÿ" },
            { 
                "speaker": "ç©å®¶", 
                "line": "æˆ‘å‡†å¤‡å¥½äº†ã€‚",
                "action": "start_trial"
            }
        ],
        "next": "4" 
    },
    "trial_combat": {
        "type": "combat",
        "enemy_id": "slime", 
        "next_win": "map_return", 
        "next_lose": "title"
    },
    "5": {
        "type": "story",
        "text": [
            { "speaker": "æ—ç™½", "line": "â€¦â€¦" },
            { "speaker": "æ—ç™½", "line": "â€¦â€¦â€¦â€¦â€¦â€¦" },
            { "speaker": "ä½ ", "line": "â€¦â€¦å””â€¦â€¦å¥½å›°â€¦â€¦â€¦â€¦" },
            { "speaker": "æ—ç™½", "line": "æˆ‘çš„æ„è­˜å°±åƒè¢«é»åœ¨å¤©èŠ±æ¿ä¸Šçš„å£é¦™ç³–ï¼Œæ™æ‰è‘—æƒ³å¾€ä¸‹æ‰ï¼Œå»æ€éº¼ä¹Ÿæ“ºè„«ä¸äº†é‚£è‚¡é»è†©çš„ç¡æ„ã€‚" },
            { "speaker": "æ—ç™½", "line": "è€³é‚Šæ˜¯ã€Œå˜å±ã€å˜å±ã€çš„æœ¨é ­å‘»åŸè²ï¼Œé‚£è€èˆŠçš„æœ¨æ¿å¥½åƒéš¨æ™‚éƒ½æœƒæ•£æ¶ä¸€æ¨£ï¼Œé‚„æœ‰è¦å¾‹å¾—è®“äººæƒ³æ‰“çŒç¡çš„æµ·æµªæ‹æ‰“èˆ¹èº«çš„ã€Œå™—é€šã€å™—é€šã€æ‚¶éŸ¿ã€‚" },
            { "speaker": "æ—ç™½", "line": "é¼»è…”è£¡å……æ–¥è‘—ä¸€è‚¡é¹¹æ¾€çš„æµ·é¢¨ï¼Œæ··åˆè‘—è€æœ¨é ­å’Œä¸€é»é»èªªä¸æ¸…é“ä¸æ˜çš„é­šè…¥å‘³ï¼Œå—¯ï¼Œé€™å°±æ˜¯ã€Œæµ·ä¸Šç”·å…’ã€çš„æµªæ¼«å§ï¼Œå¤§æ¦‚ã€‚" },
            { "speaker": "æ—ç™½", "line": "çœ¼çš®å°±åƒçŒäº†é‰›ä¸€æ¨£æ²‰é‡ï¼Œæ¯”æˆ‘æœŸæœ«è€ƒè©¦å‰ç†¬å¤œçœ‹æ¼«ç•«çš„çœ¼ç›é‚„é‡ã€‚" },
            { "speaker": "ä½ ", "line": "ã€Œå†ç¡äº”åˆ†é˜ï¼Œå°±äº”åˆ†é˜â€¦â€¦ã€æˆ‘å¿ƒè£¡å˜€å’•è‘—ï¼Œç¿»äº†å€‹èº«ã€‚" },
            { "speaker": "ä½ ", "line": "â€¦â€¦" },
            { "speaker": "ä½ ", "line": "ç­‰ç­‰ï¼ç¾åœ¨æ˜¯ä»€éº¼æ™‚å€™äº†ï¼Ÿï¼" }
        ],
        "next": "quit"
    }
}


================================================================================
### æ–‡ä»¶è·¯å¾„: Talents.py
================================================================================

import Buffs
from abc import ABC
import collections
from collections import defaultdict
from rich.console import Console, Group
from rich.live import Live
from rich.table import Table
from rich.panel import Panel
from rich.text import Text
import time
import random
from rich.text import Text
from rich.progress import BarColumn  # å¯é€‰ï¼šä¹Ÿå¯ä»¥ç›´æ¥ç”¨ Text
import math
from collections import Counter
#import pygame
import sys
from rich.console import Console

from damage import DamagePacket, DamageType

class Talent:
    """å¤©èµ‹åŸºç±»ï¼Œä¹‹åå¯æ‰©å±•æ›´å¤šé’©å­"""
    display_name = None
    def on_init(self, wearer):
        """è§’è‰²åˆ›å»º/æˆ˜å‰åˆå§‹åŒ–æ—¶è§¦å‘ï¼Œç”¨äºä¿®æ”¹æ§½ä½ä¹‹ç±»çš„å±æ€§"""
        pass
    def on_attack(self, wearer, target, dmg):
        """æ”»å‡»åè§¦å‘"""
        pass
    def on_debuff_applied(self, wearer, buff):
        """å½“ä¸€ä¸ª Debuff è¢«åŠ åˆ° wearer ä¸Šæ—¶è§¦å‘"""
        pass
        
class PoisonousTalent(Talent):
    display_name = "æ¯’ç‰©"
    def __init__(self, chance: float = 0.5):
        self.chance = chance

    def on_attack(self, wearer, target, dmg):
        if random.random() < self.chance:
            target.add_debuff(Buffs.PoisonDebuff(stacks=1), source=wearer)

class DualWieldTalent(Talent):
    """äºŒåˆ€æµï¼šæ­¦å™¨æ§½æå‡åˆ° 2"""
    display_name = "äºŒåˆ€æµ"
    def on_init(self, wearer):
        cur = wearer.SLOT_CAPACITY.get("weapon", 1)
        if cur < 2:
            wearer.SLOT_CAPACITY["weapon"] = 2

class TripleWieldTalent(Talent):
    """ä¸‰åˆ€æµï¼šæ­¦å™¨æ§½æå‡åˆ° 3"""
    display_name = "ä¸‰åˆ€æµ"
    def on_init(self, wearer):
        cur = wearer.SLOT_CAPACITY.get("weapon", 1)
        if cur < 3:
            wearer.SLOT_CAPACITY["weapon"] = 3

class ThousandWorldTalent(Talent):
    """ä¸‰åƒä¸–ç•Œï¼šæ™®æ”»æ—¶æœ‰ chance æ¦‚ç‡ç«‹å³é¢å¤–è¿ç»­æ™®æ”» 2 æ¬¡"""
    display_name = "ä¸‰åƒä¸–ç•Œ"

    def __init__(self, chance: float = 0.33):
        self.chance = chance

    def on_attack(self, wearer, target, dmg):
        """
        åœ¨ä¸»æ”»åè°ƒç”¨ï¼Œå¦‚æœå‘½ä¸­ä¸”è§¦å‘äº†ä¸‰åƒä¸–ç•Œï¼Œ
        å°±è¿”å›é¢å¤–æ”»å‡»çš„æ–‡æœ¬åˆ—è¡¨ï¼›å¦åˆ™è¿”å›ç©ºåˆ—è¡¨ã€‚
        """
        extra_texts = []
        if random.random() < self.chance:
            # é¢å¤–å‡ºæ‰‹ä¸¤æ¬¡
            for _ in range(2):
                text = wearer.perform_extra_attack(target)
                extra_texts.append(text)
        return extra_texts

class HeartOfHealingTalent(Talent):
    """æ²»æ„ˆä¹‹å¿ƒï¼šè¢«æ–½åŠ å¯é©±æ•£çš„ Debuff æ—¶ï¼Œ30% æ¦‚ç‡é©±æ•£æ­¤å±‚ï¼Œå¹¶è·å¾— 1 å±‚ å†ç”Ÿ"""
    display_name = "æ²»æ„ˆä¹‹å¿ƒ"

    def __init__(self, chance: float = 0.3):
        self.chance = chance

    def on_debuff_applied(self, wearer, buff):
        if random.random() < self.chance:
            # é©±æ•£ä¸€å±‚
            if hasattr(buff, "stacks"):
                buff.stacks -= 1
                if buff.stacks <= 0:
                    wearer.remove_buff(buff)
            else:
                wearer.remove_buff(buff)
            # è·å¾— 1 å±‚â€œå†ç”Ÿâ€
            wearer.add_buff(Buffs.RegenerationBuff(stacks=1))

class BambooLeafTalent(Talent):
    display_name = "ç«¹å¶é’"

    def __init__(self, chance: float = 1.0):
        self.chance = chance
        self._bamboo_atk_bonus = 0  # ä¸Šä¸€æ¬¡æ€»åŠ æˆ
        self._bamboo_spd_bonus = 0

    def on_inflict_debuff(self, wearer, target, buff, added_stacks):
        # åªæœ‰æ˜¯ PoisonDebuff ä¸”æ¦‚ç‡å‘½ä¸­æ‰è§¦å‘
        if not isinstance(buff, Buffs.PoisonDebuff) or random.random() >= self.chance:
            return

        # â‘  ç»™è‡ªå·±åŠ è¿™æ¬¡ç›¸åŒçš„å±‚æ•°
        own = next((b for b in wearer.buffs if isinstance(b, Buffs.PoisonDebuff)), None)
        if own:
            own.stacks = min(own.stacks + added_stacks, own.max_stacks)
        else:
            wearer.add_buff(Buffs.PoisonDebuff(stacks=added_stacks))

        # â‘¡ ç»Ÿè®¡å½“å‰æ¯’æ€»å±‚æ•°
        total_stacks = next((b.stacks for b in wearer.buffs if isinstance(b, Buffs.PoisonDebuff)), 0)

        # â‘¢ æ’¤é”€æ—§åŠ æˆ
        wearer.attack -= self._bamboo_atk_bonus
        current_as = 6.0 / wearer.attack_interval
        base_as = current_as - self._bamboo_spd_bonus

        # â‘£ é‡æ–°è®¡ç®—åŠ æˆï¼ˆåŸºäºæ€»æ¯’å±‚æ•°ï¼‰
        atk_bonus = total_stacks * 1
        spd_bonus = total_stacks * 0.1

        wearer.attack += atk_bonus
        wearer.attack_interval = 6.0 / (base_as + spd_bonus)

        # â‘¤ è®°å½•æ–°çš„åŠ æˆå€¼
        self._bamboo_atk_bonus = atk_bonus
        self._bamboo_spd_bonus = spd_bonus

class GlassCannon(Talent):
    """ã€å¤©èµ‹ã€‘ç»ç’ƒå¤§ç‚®ï¼šé€ æˆçš„ä¼¤å®³æå‡50%ï¼Œå—åˆ°çš„ä¼¤å®³ä¹Ÿæå‡30%ã€‚"""
    display_name = "ç»ç’ƒå¤§ç‚®"
    def on_init(self, wearer):
        wearer.attack *= 1.5
        wearer.damage_resistance -= 0.3

class Giant(Talent):
    """ã€å¤©èµ‹ã€‘å·¨äººï¼šæœ€å¤§ç”Ÿå‘½å€¼æå‡50%ï¼Œä½†æ”»å‡»é€Ÿåº¦é™ä½20%ã€‚"""
    display_name = "å·¨äºº"
    def on_init(self, wearer):
        wearer.max_hp *= 1.5
        wearer.hp = wearer.max_hp
        wearer.attack_speed *= 0.8
        wearer.attack_interval = 6.0 / wearer.attack_speed

class Executioner(Talent):
    """ã€å¤©èµ‹ã€‘å¤„å†³è€…ï¼šå¯¹ç”Ÿå‘½å€¼ä½äº30%çš„æ•Œäººé€ æˆ100%é¢å¤–ä¼¤å®³ã€‚"""
    display_name = "å¤„å†³è€…"
    def on_attack(self, wearer, target, dmg):
        if target.hp / target.max_hp < 0.3:
            # é€ æˆä¸€æ¬¡é¢å¤–çš„çœŸå®ä¼¤å®³
            packet = DamagePacket(amount=dmg * 1.0, damage_type=DamageType.TRUE, source=wearer)
            target.take_damage(packet)

class Scavenger(Talent):
    """ã€å¤©èµ‹ã€‘æ¸…é“å¤«ï¼šå‡»è´¥æ•Œäººæ—¶è·å¾—çš„é‡‘å¸æå‡50%ã€‚"""
    display_name = "æ¸…é“å¤«"
    # (æ­¤å¤©èµ‹çš„é€»è¾‘éœ€è¦åœ¨ç»™äºˆé‡‘å¸çš„åœ°æ–¹æ£€æŸ¥)

class MagicShield(Talent):
    """ã€å¤©èµ‹ã€‘æ³•åŠ›æŠ¤ç›¾ï¼šè·å¾—+20é­”æ³•æŠ—æ€§ã€‚"""
    display_name = "æ³•åŠ›æŠ¤ç›¾"
    def on_init(self, wearer):
        wearer.magic_resist += 20

class FirstStrike(Talent):
    """ã€å¤©èµ‹ã€‘å…ˆå‘åˆ¶äººï¼šè¿›å…¥æˆ˜æ–—åçš„ç¬¬ä¸€æ¬¡æ”»å‡»å¿…å®šæš´å‡»ã€‚"""
    display_name = "å…ˆå‘åˆ¶äºº"
    def on_init(self, wearer):
        self._used = False
    def on_attack(self, wearer, target, dmg):
        if not self._used:
            # è¿™ä¸ªå¤©èµ‹æœ€å¥½åœ¨ before_attack é’©å­ä¸­å®ç°
            pass 
    
class LastStand(Talent):
    """ã€å¤©èµ‹ã€‘èƒŒæ°´ä¸€æˆ˜ï¼šç”Ÿå‘½å€¼ä½äº25%æ—¶ï¼Œè·å¾—50%ä¼¤å®³å‡å…ã€‚"""
    display_name = "èƒŒæ°´ä¸€æˆ˜"
    def on_init(self, wearer):
        wearer.damage_resistance_last_stand = 0.5 # è‡ªå®šä¹‰ä¸€ä¸ªå±æ€§
    # (æ­¤å¤©èµ‹çš„é€»è¾‘éœ€è¦åœ¨ take_damage ä¸­æ£€æŸ¥)

class AdrenalineRush(Talent):
    """ã€å¤©èµ‹ã€‘è‚¾ä¸Šè…ºç´ ï¼šæ¯æ¬¡æ€æ­»æ•Œäººï¼Œæ”»å‡»é€Ÿåº¦æå‡10%ï¼ŒæŒç»­åˆ°æˆ˜æ–—ç»“æŸã€‚"""
    display_name = "è‚¾ä¸Šè…ºç´ "
    # (æ­¤å¤©èµ‹é€»è¾‘å¤æ‚ï¼Œéœ€è¦æˆ˜æ–—ç³»ç»Ÿæ”¯æŒ on_kill é’©å­)

# æ–‡ä»¶: Talents.py

class Brawler(Talent):
    """ã€å¤©èµ‹ã€‘æ ¼æ–—å®¶ï¼šä½ æ— æ³•è£…å¤‡å‰¯æ‰‹ç‰©å“ï¼Œä½†ä½ çš„åŸºç¡€æ”»å‡»åŠ›æå‡30%ã€‚"""
    display_name = "æ ¼æ–—å®¶"
    def on_init(self, wearer):
        # åªæ˜¯ä¿®æ”¹è§„åˆ™å’ŒåŸºç¡€å€¼ï¼Œä¸å†è°ƒç”¨recalculate_stats
        wearer.SLOT_CAPACITY["offhand"] = 0
        wearer.base_attack *= 1.3 
        # ç§»é™¤ä¸‹é¢è¿™ä¸¤è¡Œ
        # wearer.attack = wearer.base_attack
        # wearer.recalculate_stats()

class QuickLearner(Talent):
    """ã€å¤©èµ‹ã€‘é€Ÿå­¦è€…ï¼šè·å¾—çš„ç»éªŒå€¼æå‡25%ã€‚"""
    display_name = "é€Ÿå­¦è€…"
    # (æ­¤å¤©èµ‹çš„é€»è¾‘éœ€è¦åœ¨ add_exp ä¸­æ£€æŸ¥)


================================================================================
### æ–‡ä»¶è·¯å¾„: treasure_sprite.py
================================================================================

# treasure_sprite.py
import pygame
from settings import *

class TreasureChest(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        
        # å°†æ¥ä½ å¯ä»¥æ¢æˆæ¼‚äº®çš„å®ç®±å›¾ç‰‡
        # ç°åœ¨æˆ‘ä»¬ç”¨ä¸€ä¸ªé‡‘è‰²çš„æ–¹å—ä»£æ›¿
        self.image = pygame.Surface([60, 50])
        self.image.fill((255, 215, 0)) # é‡‘è‰²
        self.rect = self.image.get_rect(center=(x, y))


================================================================================
### æ–‡ä»¶è·¯å¾„: ui.py
================================================================================

# ui.py (å·²æ›´æ–°)
import pygame
import textwrap
import inspect
import os
from collections import deque
from settings import *

def init_fonts():
    fonts = {}
    try:
        fonts['normal'] = pygame.font.SysFont(FONT_NAME_CN, FONT_SIZE_NORMAL)
        fonts['small'] = pygame.font.SysFont(FONT_NAME_CN, FONT_SIZE_SMALL)
        fonts['large'] = pygame.font.SysFont(FONT_NAME_CN, FONT_SIZE_LARGE)
        # <-- æ ¸å¿ƒä¿®å¤ï¼šåœ¨è¿™é‡Œåˆ›å»º 'minimap' å­—ä½“ -->
        fonts['minimap'] = pygame.font.SysFont(FONT_NAME_CN, 16) 
    except pygame.error:
        print("è­¦å‘Š: æœªæ‰¾åˆ°æŒ‡å®šä¸­æ–‡å­—ä½“ï¼Œå°†ä½¿ç”¨é»˜è®¤å­—ä½“ã€‚")
        fonts['normal'] = pygame.font.Font(None, FONT_SIZE_NORMAL + 4)
        fonts['small'] = pygame.font.Font(None, FONT_SIZE_SMALL + 4)
        fonts['large'] = pygame.font.Font(None, FONT_SIZE_LARGE + 4)
        # <-- æ ¸å¿ƒä¿®å¤ï¼šç¡®ä¿åœ¨é»˜è®¤å­—ä½“æƒ…å†µä¸‹ä¹Ÿåˆ›å»º 'minimap' å­—ä½“ -->
        fonts['minimap'] = pygame.font.Font(None, 18)
    return fonts

class Button:
    def __init__(self, rect, text, font):
        self.rect = pygame.Rect(rect)
        self.text = text
        self.font = font
        self.is_hovered = False
        self.is_clicked = False
    def handle_event(self, event):
        action_triggered = False
        if event.type == pygame.MOUSEMOTION:
            self.is_hovered = self.rect.collidepoint(event.pos)
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1 and self.is_hovered:
            self.is_clicked = True
            action_triggered = True
        if event.type == pygame.MOUSEBUTTONUP and event.button == 1:
            self.is_clicked = False
        return action_triggered
    def draw(self, surface):
        button_color = PANEL_BG_COLOR
        if self.is_clicked: button_color = BUTTON_CLICK_COLOR
        elif self.is_hovered: button_color = PANEL_BORDER_COLOR
        pygame.draw.rect(surface, button_color, self.rect, border_radius=10)
        pygame.draw.rect(surface, PANEL_BORDER_COLOR, self.rect, 2, border_radius=10)
        text_surf = self.font.render(self.text, True, TEXT_COLOR)
        text_rect = text_surf.get_rect(center=self.rect.center)
        surface.blit(text_surf, text_rect)
def draw_text(surface, text, font, color, rect, aa=True):
    y = rect.top; line_spacing = -2; font_height = font.size("Tg")[1]
    max_chars_per_line = rect.width // font.size("ä¸€")[0] if font.size("ä¸€")[0] > 0 else 1
    wrapped_text = textwrap.wrap(text, width=max_chars_per_line)
    for line in wrapped_text:
        line_surface = font.render(line, aa, color)
        surface.blit(line_surface, (rect.left, y)); y += font_height + line_spacing
def draw_panel(surface, rect, title, font):
    pygame.draw.rect(surface, PANEL_BG_COLOR, rect, border_radius=10)
    pygame.draw.rect(surface, PANEL_BORDER_COLOR, rect, 3, border_radius=10)
    title_surf = font.render(title, True, TEXT_COLOR)
    title_rect = title_surf.get_rect(center=(rect.centerx, rect.top + 50))
    surface.blit(title_surf, title_rect)
def draw_health_bar(surface, rect, char):
    pygame.draw.rect(surface, (50, 50, 50), rect, border_radius=5)
    hp_percent = char.hp / char.max_hp if char.max_hp > 0 else 0
    hp_width = (rect.width - 4) * hp_percent
    hp_rect = pygame.Rect(rect.left + 2, rect.top + 2, hp_width, rect.height - 4)
    pygame.draw.rect(surface, HP_BAR_GREEN, hp_rect, border_radius=5)
    if char.shield > 0:
        shield_percent = min(char.shield / char.max_hp, 1.0) if char.max_hp > 0 else 0
        shield_width = (rect.width - 4) * shield_percent
        shield_rect = pygame.Rect(rect.right - 2 - shield_width, rect.top + 2, shield_width, rect.height - 4)
        pygame.draw.rect(surface, SHIELD_BAR_GREY, shield_rect, border_radius=5)
    pygame.draw.rect(surface, PANEL_BORDER_COLOR, rect, 2, border_radius=5)
    fonts = init_fonts()
    hp_text = f"{char.name} HP: {int(char.hp)}/{int(char.max_hp)} | ç›¾: {int(char.shield)}"
    text_surf = fonts['normal'].render(hp_text, True, TEXT_COLOR)
    text_rect = text_surf.get_rect(center=rect.center)
    surface.blit(text_surf, text_rect)
def get_display_name(obj):
    return getattr(obj, 'display_name', obj.__class__.__name__)

# åœ¨ ui.py æ–‡ä»¶ä¸­ï¼Œæ‰¾åˆ°å¹¶ä¿®æ”¹è¿™ä¸ªå‡½æ•°

def init_fonts():
    fonts = {}
    try:
        fonts['normal'] = pygame.font.SysFont(FONT_NAME_CN, FONT_SIZE_NORMAL)
        fonts['small'] = pygame.font.SysFont(FONT_NAME_CN, FONT_SIZE_SMALL)
        fonts['large'] = pygame.font.SysFont(FONT_NAME_CN, FONT_SIZE_LARGE)
        # <-- æ–°å¢ï¼šä¸ºå°åœ°å›¾åˆ›å»ºä¸€ä¸ªæ›´å°çš„å­—ä½“ -->
        fonts['minimap'] = pygame.font.SysFont(FONT_NAME_CN, 16) 
    except pygame.error:
        print("è­¦å‘Š: æœªæ‰¾åˆ°æŒ‡å®šä¸­æ–‡å­—ä½“ï¼Œå°†ä½¿ç”¨é»˜è®¤å­—ä½“ã€‚")
        fonts['normal'] = pygame.font.Font(None, FONT_SIZE_NORMAL + 4)
        fonts['small'] = pygame.font.Font(None, FONT_SIZE_SMALL + 4)
        fonts['large'] = pygame.font.Font(None, FONT_SIZE_LARGE + 4)
        # <-- æ–°å¢ï¼šé»˜è®¤å­—ä½“ç‰ˆæœ¬ -->
        fonts['minimap'] = pygame.font.Font(None, 18)
    return fonts

buff_icons = {}
def load_buff_icons():
    # <-- æ ¸å¿ƒæ”¹åŠ¨ 1: ç¡®ä¿è¿™é‡ŒåŒ…å«äº†ä½ é¡¹ç›®ä¸­æ‰€æœ‰çš„Buffç±»å -->
    icon_names = {
        'SteelHeartBuff': 'steel_heart.png',    # åˆšæ¯…
        'RegenerationBuff': 'regeneration.png', # å†ç”Ÿ
        'PoisonDebuff': 'poison.png',           # æ¯’
        'AttackDisabledBuff': 'stun.png',       # æ— æ³•æ”»å‡» (ç”¨çœ©æ™•å›¾æ ‡)
        'StunDebuff': 'stun.png',               # çœ©æ™•
        'ThornsBuff': 'thorns.png',             # è†æ£˜
        'PhoenixCrownStage1Buff': 'phoenix.png', # ä¸ç­1
        'PhoenixCrownStage2Buff': 'phoenix.png', # ä¸ç­2
    }
    for buff_class_name, icon_filename in icon_names.items():
        try:
            path = os.path.join('assets', 'icons', icon_filename)
            image = pygame.image.load(path).convert_alpha()
            buff_icons[buff_class_name] = pygame.transform.scale(image, BUFF_ICON_SIZE)
        except pygame.error:
            print(f"è­¦å‘Š: æ— æ³•åŠ è½½å›¾æ ‡ {path}")
    try: # åŠ è½½é»˜è®¤å›¾æ ‡
        path = os.path.join('assets', 'icons', 'default.png')
        image = pygame.image.load(path).convert_alpha()
        buff_icons['default'] = pygame.transform.scale(image, BUFF_ICON_SIZE)
    except pygame.error:
        print("è­¦å‘Š: æ— æ³•åŠ è½½é»˜è®¤å›¾æ ‡ default.png")

def draw_buff_icons(surface, char, x, y):
    # è¿™ä¸ªå‡½æ•°ç°åœ¨åªè´Ÿè´£ç»˜åˆ¶ï¼Œå¹¶è¿”å›å®ƒç»˜åˆ¶çš„ (Rect, Buffå¯¹è±¡) åˆ—è¡¨
    drawn_elements = []
    for i, buff in enumerate(char.buffs):
        if buff.hidden: continue
        icon = buff_icons.get(buff.__class__.__name__, buff_icons.get('default'))
        if icon:
            icon_rect = pygame.Rect(x + i * (BUFF_ICON_SIZE[0] + 5), y, BUFF_ICON_SIZE[0], BUFF_ICON_SIZE[1])
            surface.blit(icon, icon_rect)
            drawn_elements.append((icon_rect, buff)) # è®°å½•ä½ç½®å’Œå¯¹è±¡

            if buff.max_stacks > 1 and buff.stacks > 1:
                fonts = init_fonts()
                stack_surf = fonts['small'].render(str(buff.stacks), True, TEXT_COLOR)
                stack_rect = stack_surf.get_rect(bottomright=(icon_rect.right, icon_rect.bottom))
                pygame.draw.rect(surface, (0,0,0), stack_rect.inflate(4,4))
                surface.blit(stack_surf, stack_rect)
    return drawn_elements


# åœ¨ ui.py æ–‡ä»¶ä¸­ï¼Œæ‰¾åˆ°å¹¶æ›¿æ¢è¿™ä¸ªå‡½æ•°

# åœ¨ ui.py æ–‡ä»¶ä¸­ï¼Œæ‰¾åˆ°å¹¶æ›¿æ¢è¿™ä¸ªå‡½æ•°

def draw_character_panel(surface, char, rect, fonts):
    """ç»˜åˆ¶ä¸€ä¸ªå®Œæ•´çš„è§’è‰²ä¿¡æ¯é¢æ¿, å¹¶è¿”å›å¯äº¤äº’UIå…ƒç´ çš„ä½ç½®å’Œå¯¹è±¡"""
    ui_elements = {'talents': [], 'buffs': []}

    pygame.draw.rect(surface, PANEL_BG_COLOR, rect, border_radius=15)
    pygame.draw.rect(surface, PANEL_BORDER_COLOR, rect, 3, border_radius=15)
    
    name_surf = fonts['large'].render(char.name, True, TEXT_COLOR)
    level_surf = fonts['normal'].render(f"Lv. {char.level}", True, TEXT_COLOR)
    surface.blit(name_surf, (rect.left + 20, rect.top + 15))
    surface.blit(level_surf, (rect.left + name_surf.get_width() + 30, rect.top + 28))

    # ... (è¡€æ¡ã€ç»éªŒæ¡ã€æ•°å€¼çš„ç»˜åˆ¶é€»è¾‘ä¿æŒä¸å˜) ...
    hp_bar_rect = pygame.Rect(rect.left + 20, rect.top + 80, rect.width - 40, 30)
    hp_percent = char.hp / char.max_hp if char.max_hp > 0 else 0
    hp_width = (hp_bar_rect.width - 4) * hp_percent
    pygame.draw.rect(surface, (50,50,50), hp_bar_rect, border_radius=5)
    pygame.draw.rect(surface, HP_BAR_GREEN, (hp_bar_rect.left + 2, hp_bar_rect.top + 2, hp_width, hp_bar_rect.height - 4), border_radius=5)
    if char.shield > 0:
        shield_percent = min(char.shield / char.max_hp, 1.0)
        shield_width = (hp_bar_rect.width - 4) * shield_percent
        shield_rect_pos = hp_bar_rect.left + 2 + hp_width
        pygame.draw.rect(surface, SHIELD_BAR_GREY, (shield_rect_pos, hp_bar_rect.top + 2, shield_width, hp_bar_rect.height - 4), border_radius=5)
    hp_text = f"{int(char.hp)}/{int(char.max_hp)}" + (f" (+{int(char.shield)})" if char.shield > 0 else "")
    hp_text_surf = fonts['small'].render(hp_text, True, TEXT_COLOR)
    surface.blit(hp_text_surf, hp_text_surf.get_rect(center=hp_bar_rect.center))
    if hasattr(char, 'exp'):
        exp_bar_rect = pygame.Rect(rect.left + 20, rect.top + 120, rect.width - 40, 10)
        pygame.draw.rect(surface, (50,50,50), exp_bar_rect, border_radius=3)
        exp_percent = char.exp / char.exp_to_next_level if char.exp_to_next_level > 0 else 0
        exp_width = exp_bar_rect.width * exp_percent
        pygame.draw.rect(surface, XP_BAR_COLOR, (exp_bar_rect.left, exp_bar_rect.top, exp_width, exp_bar_rect.height), border_radius=3)
    stats_text = f"æ”»å‡»: {int(char.attack)} | é˜²å¾¡: {int(char.defense)} | æ”»é€Ÿ: {char.attack_speed:.2f}"
    stats_surf = fonts['small'].render(stats_text, True, TEXT_COLOR)
    surface.blit(stats_surf, (rect.left + 20, rect.top + 140))

    # --- æ ¸å¿ƒä¿®å¤ï¼šä½¿ç”¨ char.equipped_talents æ¥è·å–å¤©èµ‹ ---
    current_x = rect.left + 20
    if char.equipped_talents: # <-- ä¿®æ”¹ç‚¹ 1
        talent_label_surf = fonts['small'].render("å¤©èµ‹: ", True, (255, 215, 0))
        surface.blit(talent_label_surf, (current_x, rect.top + 170))
        current_x += talent_label_surf.get_width()

        for i, talent in enumerate(char.equipped_talents): # <-- ä¿®æ”¹ç‚¹ 2
            if not talent.display_name: continue
            name_surf = fonts['small'].render(talent.display_name, True, (255, 215, 0))
            name_rect = name_surf.get_rect(left=current_x, top=rect.top + 170)
            surface.blit(name_surf, name_rect)
            ui_elements['talents'].append((name_rect, talent))
            current_x += name_rect.width
            if i < len(char.equipped_talents) - 1: # <-- ä¿®æ”¹ç‚¹ 3
                separator_surf = fonts['small'].render(" | ", True, (255, 215, 0))
                surface.blit(separator_surf, (current_x, rect.top + 170))
                current_x += separator_surf.get_width()

    # --- Buff ç»˜åˆ¶é€»è¾‘ä¿æŒä¸å˜ ---
    current_x = rect.left + 20
    if char.buffs:
        # ... (è¿™éƒ¨åˆ†ä»£ç æ— éœ€ä¿®æ”¹) ...
        status_label_surf = fonts['small'].render("çŠ¶æ€: ", True, TEXT_COLOR)
        surface.blit(status_label_surf, (current_x, rect.top + 200))
        current_x += status_label_surf.get_width()
        visible_buffs = [b for b in char.buffs if not b.hidden]
        for i, buff in enumerate(visible_buffs):
            buff_text = buff.display_name
            if buff.max_stacks > 1 and buff.stacks > 1: buff_text += f"({buff.stacks})"
            color = (255, 80, 80) if buff.is_debuff else (80, 255, 80)
            text_surf = fonts['small'].render(buff_text, True, color)
            text_rect = text_surf.get_rect(left=current_x, top=rect.top + 200)
            surface.blit(text_surf, text_rect)
            ui_elements['buffs'].append((text_rect, buff))
            current_x += text_rect.width
            if i < len(visible_buffs) - 1:
                separator_surf = fonts['small'].render(" | ", True, TEXT_COLOR)
                surface.blit(separator_surf, (current_x, rect.top + 200))
                current_x += separator_surf.get_width()
    
    return ui_elements

# ... (BattleLog å’Œ TooltipManager ä¿æŒä¸å˜) ...
class BattleLog:
    def __init__(self, rect, font, max_lines=8):
        self.rect, self.font, self.max_lines = rect, font, max_lines
        self.messages = deque(maxlen=max_lines)
        self.surface = pygame.Surface(self.rect.size, pygame.SRCALPHA)
    def add_message(self, message): self.messages.append(message)
    def draw(self, surface):
        self.surface.fill(LOG_BG_COLOR)
        for i, msg in enumerate(reversed(self.messages)):
            alpha = 255 - (i * 25)
            color = (LOG_TEXT_COLOR[0], LOG_TEXT_COLOR[1], LOG_TEXT_COLOR[2], alpha)
            msg_surf = self.font.render(msg, True, color)
            self.surface.blit(msg_surf, (10, self.rect.height - (len(self.messages) - i) * (self.font.get_height() + 2)))
        surface.blit(self.surface, self.rect.topleft)
class TooltipManager:
    def __init__(self, font, delay=500):
        self.font, self.delay = font, delay
        self.active_item, self.hover_start_time, self.tooltip_surface = None, 0, None
    def _get_description(self, item):
        if not item: return None
        doc = inspect.getdoc(item)
        if not doc: return get_display_name(item)
        display_name = getattr(item, 'display_name', item.__class__.__name__)
        return f"[ {display_name} ]\n" + "-"*20 + f"\n{doc}"
    def update(self, hovered_item):
        now = pygame.time.get_ticks()
        if hovered_item:
            if self.active_item != hovered_item:
                self.active_item, self.hover_start_time, self.tooltip_surface = hovered_item, now, None
            elif now - self.hover_start_time > self.delay and not self.tooltip_surface:
                self._create_tooltip_surface(self._get_description(self.active_item))
        else:
            self.active_item, self.tooltip_surface = None, None
    def _create_tooltip_surface(self, text):
        if not text: return
        lines, wrapped_lines, max_width = text.splitlines(), [], 0
        for line in lines:
            wrapped = textwrap.wrap(line, width=40, replace_whitespace=False)
            if not wrapped: wrapped_lines.append("")
            for wrapped_line in wrapped:
                wrapped_lines.append(wrapped_line)
                line_width = self.font.size(wrapped_line)[0]
                if line_width > max_width: max_width = line_width
        padding, line_height = 15, self.font.get_height()
        total_width, total_height = max_width + padding * 2, len(wrapped_lines) * line_height + padding * 2
        self.tooltip_surface = pygame.Surface((total_width, total_height), pygame.SRCALPHA)
        self.tooltip_surface.fill((20, 35, 50, 230))
        pygame.draw.rect(self.tooltip_surface, PANEL_BORDER_COLOR, self.tooltip_surface.get_rect(), 2, border_radius=8)
        current_y = padding
        for line in wrapped_lines:
            text_surf = self.font.render(line, True, TEXT_COLOR)
            self.tooltip_surface.blit(text_surf, (padding, current_y)); current_y += line_height
    def draw(self, surface):
        if self.tooltip_surface:
            mouse_pos = pygame.mouse.get_pos()
            tooltip_rect = self.tooltip_surface.get_rect(topleft=(mouse_pos[0] + 15, mouse_pos[1] + 15))
            if tooltip_rect.right > SCREEN_WIDTH: tooltip_rect.right = mouse_pos[0] - 15
            if tooltip_rect.bottom > SCREEN_HEIGHT: tooltip_rect.bottom = mouse_pos[1] - 15
            surface.blit(self.tooltip_surface, tooltip_rect)


================================================================================
### æ–‡ä»¶è·¯å¾„: dungeons\sunstone_ruins.json
================================================================================


{
    "id": "sunstone_ruins",
    "name": "æ—¥ä¹‹çŸ³é—è¿¹",
    "description": "ä¸€åº§è¢«é˜³å…‰é—å¿˜çš„å¤è€é—è¿¹ï¼Œå……æ»¡äº†åŸºç¡€çš„å…ƒç´ ç”Ÿç‰©å’Œå“¥å¸ƒæ—ã€‚",

    
    "floor_pools": [
        {
            "floors": [1, 2, 3],
            "monster_pool": ["slime", "goblin", "giant_bat"], 
            "elite_pool": ["goblin_captain", "armored_skeleton"], 
            "boss_id": "ruin_golem",
            "event_pool": ["fountain_of_power", "wandering_spirit"],
            "shop_items": {
                "item_count": 3,
                "rarity_weights": { "common": 70, "uncommon": 30, "rare": 5 }
            },
            "treasure_loot": {
                "item_count": 2,
                "rarity_weights": { "common": 60, "uncommon": 35, "rare": 10, "epic": 1 }
            }
        },
        {
            "floors": [4, 5],
            "monster_pool": ["wild_boar", "forest_spirit", "rock_golem"],
            "elite_pool": ["fire_elemental", "ice_elemental"],
            "boss_id": "dark_knight",
            "event_pool": ["wandering_spirit"],
            "shop_items": {
                "item_count": 4,
                "rarity_weights": { "common": 20, "uncommon": 50, "rare": 25, "epic": 5 }
            },
            "treasure_loot": {
                "item_count": 2,
                "rarity_weights": { "common": 10, "uncommon": 40, "rare": 40, "epic": 10 }
            }
        }
    ]
}


================================================================================
### æ–‡ä»¶è·¯å¾„: states\backpack.py
================================================================================

# states/backpack.py (Complete File)
import pygame
import math
from .base import BaseState
from ui import draw_text, draw_panel, get_display_name, TooltipManager, Button
from settings import *

SLOT_CONFIG = {
    "weapon": {"name": "æ­¦å™¨", "icon": "æ­¦", "color": (255, 100, 100)},
    "offhand": {"name": "å‰¯æ‰‹", "icon": "å‰¯", "color": (100, 255, 100)},
    "helmet": {"name": "å¤´ç›”", "icon": "å¤´", "color": (255, 255, 100)},
    "armor": {"name": "èƒ¸ç”²", "icon": "ç”²", "color": (100, 100, 255)},
    "pants": {"name": "è…¿ç”²", "icon": "è…¿", "color": (255, 100, 255)},
    "accessory": {"name": "é¥°å“", "icon": "é¥°", "color": (100, 255, 255)},
}

RARITY_COLORS = {
    "common": (156, 163, 175), "uncommon": (16, 185, 129), "rare": (59, 130, 246),
    "epic": (139, 92, 246), "legendary": (245, 158, 11),
}

class BackpackScreen(BaseState):
    def __init__(self, game):
        super().__init__(game)
        self.is_overlay = True
        self.dragging_item, self.dragging_from, self.dragging_from_info = None, None, {}
        self.selected_category, self.search_text, self.search_active = "all", "", False
        self.hover_slot = None
        self.tooltip_manager = TooltipManager(self.game.fonts['small'])
        self._setup_layout()
        self._setup_animations()

    def _get_font(self, font_name, default_size=20):
        try:
            if hasattr(self.game, 'fonts') and font_name in self.game.fonts: return self.game.fonts[font_name]
        except: pass
        return pygame.font.Font(None, default_size)

    def _setup_layout(self):
        margin, header_height, sidebar_width, char_panel_width = 40, 80, 200, 280
        self.container_rect = pygame.Rect(margin, margin, SCREEN_WIDTH - 2*margin, SCREEN_HEIGHT - 2*margin)
        self.header_rect = pygame.Rect(self.container_rect.x, self.container_rect.y, self.container_rect.width, header_height)
        content_y, content_height = self.header_rect.bottom + 10, self.container_rect.height - header_height - 10
        self.sidebar_rect = pygame.Rect(self.container_rect.x, content_y, sidebar_width, content_height)
        self.character_panel_rect = pygame.Rect(self.container_rect.right - char_panel_width, content_y, char_panel_width, content_height)
        self.inventory_rect = pygame.Rect(self.sidebar_rect.right + 10, content_y, self.character_panel_rect.left - self.sidebar_rect.right - 20, content_height)
        self.search_rect = pygame.Rect(self.inventory_rect.x + 10, self.inventory_rect.y + 10, self.inventory_rect.width - 20, 35)
        self.grid_rect = pygame.Rect(self.inventory_rect.x + 10, self.search_rect.bottom + 15, self.inventory_rect.width - 20, self.inventory_rect.height - 60)
        self._generate_ui_elements()

    def _setup_animations(self): self.hover_animation, self.glow_animation = {}, 0

    def _generate_ui_elements(self):
        self.category_buttons = []
        categories = [("all", "å…¨éƒ¨"), ("weapon", "æ­¦å™¨"), ("armor", "é˜²å…·"), ("consumable", "æ¶ˆè€—"), ("material", "ææ–™"), ("misc", "å…¶ä»–")]
        btn_h, btn_s, start_y = 45, 8, self.sidebar_rect.y + 20
        for i, (cat_id, name) in enumerate(categories):
            rect = pygame.Rect(self.sidebar_rect.x + 15, start_y + i * (btn_h + btn_s), self.sidebar_rect.width - 30, btn_h)
            self.category_buttons.append({"id": cat_id, "name": name, "rect": rect, "hover": False})
        self.backpack_slots = []
        cols, rows, slot_size = 10, 6, min((self.grid_rect.width - 20) // 10 - 5, (self.grid_rect.height - 20) // 6 - 5)
        for row in range(rows):
            for col in range(cols):
                x, y = self.grid_rect.x + 10 + col * (slot_size + 5), self.grid_rect.y + 10 + row * (slot_size + 5)
                self.backpack_slots.append(pygame.Rect(x, y, slot_size, slot_size))
        self._generate_equipment_slots()
        close_btn_rect = pygame.Rect(self.container_rect.right - 45, self.container_rect.top + 10, 35, 35)
        self.close_button = Button(close_btn_rect, "X", self.game.fonts['normal'])

    def _generate_equipment_slots(self):
        self.equipment_slots = {}
        player = self.game.player
        model_rect = pygame.Rect(self.character_panel_rect.x + 15, self.character_panel_rect.y + 15, self.character_panel_rect.width - 30, 300)
        slot_size, spacing = 50, 10
        center_x = model_rect.centerx

        self.equipment_slots["helmet"] = [pygame.Rect(center_x - slot_size/2, model_rect.top + 10, slot_size, slot_size)]
        armor_rect = pygame.Rect(center_x - slot_size/2, model_rect.top + slot_size + spacing + 10, slot_size, slot_size)
        self.equipment_slots["armor"] = [armor_rect]
        self.equipment_slots["pants"] = [pygame.Rect(center_x - slot_size/2, armor_rect.bottom + spacing, slot_size, slot_size)]

        weapon_slots = []
        num_weapon_slots = player.SLOT_CAPACITY.get("weapon", 1)
        for i in range(num_weapon_slots):
            x = armor_rect.left - slot_size - spacing
            y = armor_rect.centery - slot_size/2 + i * (slot_size + spacing)
            weapon_slots.append(pygame.Rect(x, y, slot_size, slot_size))
        self.equipment_slots["weapon"] = weapon_slots

        if player.SLOT_CAPACITY.get("offhand", 0) > 0:
            self.equipment_slots["offhand"] = [pygame.Rect(armor_rect.right + spacing, armor_rect.centery - slot_size/2, slot_size, slot_size)]
        else:
            self.equipment_slots["offhand"] = []

        accessory_slots = []
        num_accessory_slots = player.SLOT_CAPACITY.get("accessory", 0)
        total_accessory_width = num_accessory_slots * slot_size + (num_accessory_slots - 1) * 5
        start_x = model_rect.centerx - total_accessory_width / 2
        accessory_y = model_rect.bottom - slot_size - 10
        for i in range(num_accessory_slots):
            x = start_x + i * (slot_size + 5)
            accessory_slots.append(pygame.Rect(x, accessory_y, slot_size, slot_size))
        self.equipment_slots["accessory"] = accessory_slots

    def handle_event(self, event):
        if self.close_button.handle_event(event): self.game.state_stack.pop(); return
        if event.type == pygame.KEYDOWN:
            if event.key in [pygame.K_b, pygame.K_ESCAPE]:
                if self.dragging_item: self._return_dragging_item()
                self.game.state_stack.pop(); return
            elif event.key == pygame.K_BACKSPACE and self.search_active: self.search_text = self.search_text[:-1]
            elif self.search_active and event.unicode.isprintable(): self.search_text += event.unicode
        elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            if not self.close_button.rect.collidepoint(event.pos): self._handle_mouse_down(event.pos)
        elif event.type == pygame.MOUSEBUTTONUP and event.button == 1: self._handle_mouse_up(event.pos)
        elif event.type == pygame.MOUSEMOTION: self._handle_mouse_motion(event.pos)

    def _handle_mouse_down(self, pos):
        if self.search_rect.collidepoint(pos): self.search_active = True; return
        else: self.search_active = False

        for button in self.category_buttons:
            if button["rect"].collidepoint(pos): self.selected_category = button["id"]; return

        if self.dragging_item: return

        # ä»è£…å¤‡æ§½æ‹¾èµ·
        for slot_type, slot_rects in self.equipment_slots.items():
            for i, rect in enumerate(slot_rects):
                if rect.collidepoint(pos) and self.game.player.slots[slot_type][i] is not None:
                    item_to_drag = self.game.player.slots[slot_type][i]
                    self.dragging_item = self.game.player.unequip(item_to_drag) # ä½¿ç”¨æ–°çš„unequip
                    self.dragging_from = 'equipment'
                    self.dragging_from_info = {'slot_type': slot_type, 'index': i}
                    return

        # ä»èƒŒåŒ…æ‹¾èµ·
        filtered_items = self._get_filtered_items()
        for i, rect in enumerate(self.backpack_slots):
            if rect.collidepoint(pos) and i < len(filtered_items):
                original_item = filtered_items[i]
                original_index_in_backpack = self.game.player.backpack.index(original_item)
                self.dragging_item = self.game.player.backpack.pop(original_index_in_backpack)
                self.dragging_from = 'backpack'
                self.dragging_from_info = {'index': original_index_in_backpack}
                return

    # --- 2. æ›¿æ¢ _handle_mouse_up æ–¹æ³• ---
    def _handle_mouse_up(self, pos):
        if not self.dragging_item: return

        player = self.game.player
        source_type = self.dragging_from
        source_info = self.dragging_from_info

        # æ£€æŸ¥æ˜¯å¦æ”¾ç½®åœ¨è£…å¤‡æ§½ä¸Š
        for slot_type, slot_rects in self.equipment_slots.items():
            for i, rect in enumerate(slot_rects):
                if rect.collidepoint(pos) and self.dragging_item.slot == slot_type:
                    # ä½¿ç”¨æ–°çš„equipæ–¹æ³•ï¼Œå¹¶ä¼ å…¥ç²¾ç¡®çš„ç´¢å¼• i
                    replaced_item = player.equip(self.dragging_item, specific_index=i)

                    # å¦‚æœæœ‰ç‰©å“è¢«æ›¿æ¢ä¸‹æ¥ï¼Œå¤„ç†å®ƒ
                    if replaced_item:
                        # å¦‚æœæ‹–æ‹½çš„ç‰©å“æ¥è‡ªèƒŒåŒ…ï¼Œåˆ™æŠŠæ›¿æ¢ä¸‹çš„ç‰©å“æ”¾å›èƒŒåŒ…
                        if source_type == 'backpack':
                            player.backpack.append(replaced_item)
                        # å¦‚æœæ‹–æ‹½çš„ç‰©å“æ¥è‡ªå¦ä¸€ä¸ªè£…å¤‡æ§½ï¼ˆå®ç°äº¤æ¢ï¼‰
                        elif source_type == 'equipment':
                            # å°è¯•æŠŠè¢«æ›¿æ¢çš„ç‰©å“ï¼Œè£…å¤‡å›åŸæ¥çš„æ‹–æ‹½èµ·å§‹æ§½
                            player.equip(replaced_item, specific_index=source_info['index'])

                    self.dragging_item = None
                    return

        # æ£€æŸ¥æ˜¯å¦æ”¾ç½®åœ¨èƒŒåŒ…ç½‘æ ¼ä¸Š
        if self.grid_rect.collidepoint(pos):
            player.backpack.append(self.dragging_item)
            self.dragging_item = None
            return

        # å¦‚æœæ”¾ç½®åœ¨æ— æ•ˆåŒºåŸŸï¼Œè¿”å›åŸå¤„
        self._return_dragging_item()
        self.dragging_item = None
        
    def _handle_mouse_motion(self, pos):
        for button in self.category_buttons: button["hover"] = button["rect"].collidepoint(pos)
        self.hover_slot = None
        for slot_type, slot_rects in self.equipment_slots.items():
            for i, rect in enumerate(slot_rects):
                if rect.collidepoint(pos): self.hover_slot = (slot_type, i); break

    def _get_filtered_items(self):
        items = self.game.player.backpack.copy()
        if self.selected_category != "all":
            items = [item for item in items if hasattr(item, 'type') and item.type == self.selected_category]
        if self.search_text:
            items = [item for item in items if self.search_text.lower() in get_display_name(item).lower()]
        return items

    def _return_dragging_item(self):
        if not self.dragging_item: return
        if self.dragging_from == 'backpack': 
            self.game.player.backpack.insert(self.dragging_from_info.get('index', 0), self.dragging_item)
        elif self.dragging_from == 'equipment': 
            self.game.player.equip(self.dragging_item)

    def _update_hovers(self):
        if self.dragging_item: self.tooltip_manager.update(None); return
        mouse_pos = pygame.mouse.get_pos()
        hovered_item = None
        all_elements = []
        for slot_type, slot_rects in self.equipment_slots.items():
            equipped_items = self.game.player.slots.get(slot_type, [])
            for i, rect in enumerate(slot_rects):
                if i < len(equipped_items): all_elements.append((rect, equipped_items[i]))
        filtered_items = self._get_filtered_items()
        for i, rect in enumerate(self.backpack_slots):
            if i < len(filtered_items): all_elements.append((rect, filtered_items[i]))
        for rect, obj in all_elements:
            if rect.collidepoint(mouse_pos): hovered_item = obj; break
        self.tooltip_manager.update(hovered_item)

    def update(self, dt=0):
        current_time = pygame.time.get_ticks()
        if not hasattr(self, '_last_time'): self._last_time = current_time
        dt_ms = current_time - self._last_time; self._last_time = current_time; dt_sec = dt_ms / 1000.0
        self.glow_animation = (self.glow_animation + dt_sec * 3) % (2 * math.pi)
        self.animation_offset = math.sin(self.glow_animation) * 2; self._update_hovers()

    def draw(self, surface):
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA); overlay.fill((0, 0, 0, 160)); surface.blit(overlay, (0, 0))
        self._draw_modern_panel(surface, self.container_rect, (25, 30, 50, 240))
        self._draw_header(surface); self._draw_sidebar(surface); self._draw_inventory_area(surface)
        self._draw_character_panel(surface); self._draw_dragging_item(surface)
        self.close_button.draw(surface); self.tooltip_manager.draw(surface)
        if hasattr(self, 'update'): self.update()

    def _draw_modern_panel(self, surface, rect, color, border_color=None):
        pygame.draw.rect(surface, color, rect, border_radius=12)
        if border_color is None: border_color = (70, 80, 100, 180)
        pygame.draw.rect(surface, border_color, rect, width=2, border_radius=12)
        glow_rect = rect.inflate(-4, -4); pygame.draw.rect(surface, (255, 255, 255, 10), glow_rect, width=1, border_radius=10)

    def _draw_header(self, surface):
        header_bg = self.header_rect.inflate(-10, -10); self._draw_modern_panel(surface, header_bg, (35, 40, 65, 200))
        title_font = self._get_font('large', 32); title_text = title_font.render("èƒŒåŒ…ç³»ç»Ÿ", True, (255, 215, 0))
        title_rect = title_text.get_rect(x=header_bg.x + 20, centery=header_bg.centery); surface.blit(title_text, title_rect)

    def _draw_sidebar(self, surface):
        sidebar_bg = self.sidebar_rect.inflate(-5, -5); self._draw_modern_panel(surface, sidebar_bg, (30, 35, 55, 200))
        for button in self.category_buttons:
            is_active, is_hover = button["id"] == self.selected_category, button["hover"]
            if is_active: bg_color, border_color, text_color = (255, 215, 0, 100), (255, 215, 0), (255, 255, 255)
            elif is_hover: bg_color, border_color, text_color = (70, 80, 100, 120), (100, 110, 130), (240, 240, 240)
            else: bg_color, border_color, text_color = (40, 50, 70, 80), (60, 70, 90), (180, 180, 180)
            button_rect = button["rect"]; 
            if is_hover: button_rect = button_rect.move(2 + self.animation_offset, 0)
            pygame.draw.rect(surface, bg_color, button_rect, border_radius=8); pygame.draw.rect(surface, border_color, button_rect, width=2, border_radius=8)
            font = self._get_font('small', 18); text = f"{button['name']}"; text_surface = font.render(text, True, text_color); text_rect = text_surface.get_rect(center=button_rect.center); surface.blit(text_surface, text_rect)

    def _draw_inventory_area(self, surface):
        inventory_bg = self.inventory_rect.inflate(-5, -5); self._draw_modern_panel(surface, inventory_bg, (30, 35, 55, 200))
        search_bg_color, border_color = ((50, 60, 80, 150), (255, 215, 0)) if self.search_active else ((40, 50, 70, 120), (70, 80, 100))
        pygame.draw.rect(surface, search_bg_color, self.search_rect, border_radius=6); pygame.draw.rect(surface, border_color, self.search_rect, width=2, border_radius=6)
        search_font = self._get_font('small', 18); display_text = self.search_text or "æœç´¢ç‰©å“..."; text_color = (255, 255, 255) if self.search_text else (150, 150, 150)
        search_surface = search_font.render(display_text, True, text_color); search_text_rect = search_surface.get_rect(x=self.search_rect.x + 10, centery=self.search_rect.centery); surface.blit(search_surface, search_text_rect)
        if self.search_active and int(self.glow_animation * 2) % 2: pygame.draw.line(surface, (255, 255, 255), (search_text_rect.right + 2, self.search_rect.y + 8), (search_text_rect.right + 2, self.search_rect.bottom - 8), 2)
        self._draw_backpack_grid(surface)

    def _draw_backpack_grid(self, surface):
        filtered_items = self._get_filtered_items()
        for i, slot_rect in enumerate(self.backpack_slots):
            rarity_color = RARITY_COLORS['common']; bg_color, border_color = (40, 50, 70, 60), (60, 70, 90, 120)
            if i < len(filtered_items): item = filtered_items[i]; rarity = getattr(item, 'rarity', 'common'); rarity_color = RARITY_COLORS.get(rarity, RARITY_COLORS['common']); bg_color, border_color = (*rarity_color, 30), (*rarity_color, 180)
            pygame.draw.rect(surface, bg_color, slot_rect, border_radius=6); pygame.draw.rect(surface, border_color, slot_rect, width=2, border_radius=6)
            if i < len(filtered_items):
                item = filtered_items[i]
                if item != self.dragging_item:
                    item_name = get_display_name(item); font = self._get_font('small', 12) 
                    item_surface = font.render(item_name, True, (255, 255, 255)); 
                    if item_surface.get_width() > slot_rect.width - 8: 
                        item_name = item_name[:5] + ".."
                        item_surface = font.render(item_name, True, (255, 255, 255))
                    item_rect = item_surface.get_rect(center=slot_rect.center); surface.blit(item_surface, item_rect)
                    pygame.draw.rect(surface, rarity_color, (slot_rect.x, slot_rect.y, slot_rect.width, 3), border_top_left_radius=2, border_top_right_radius=2)

    def _draw_character_panel(self, surface):
        panel_bg = self.character_panel_rect.inflate(-5, -5); self._draw_modern_panel(surface, panel_bg, (30, 35, 55, 200))
        model_area = pygame.Rect(panel_bg.x + 15, panel_bg.y + 15, panel_bg.width - 30, 300)
        pygame.draw.rect(surface, (20, 25, 40, 150), model_area, border_radius=10)
        self._draw_equipment_slots(surface); self._draw_character_stats(surface, panel_bg)

    def _draw_equipment_slots(self, surface):
        player = self.game.player # å…ˆè·å–ç©å®¶å¯¹è±¡
        for slot_type, slot_rects in self.equipment_slots.items():
            slot_config = SLOT_CONFIG.get(slot_type, {"name": slot_type, "icon": "?", "color": (100, 100, 100)})
            for i, slot_rect in enumerate(slot_rects):
                is_hover = self.hover_slot == (slot_type, i)
                bg_color, border_color = ((*slot_config["color"], 50), slot_config["color"]) if is_hover else ((40, 50, 70, 100), (70, 80, 100))
                
                pygame.draw.rect(surface, bg_color, slot_rect, border_radius=8)
                pygame.draw.rect(surface, border_color, slot_rect, width=2, border_radius=8)
                
                # --- æ ¸å¿ƒä¿®å¤åœ¨è¿™é‡Œ ---
                # ç›´æ¥ä» player.slots è·å–æŒ‡å®šä½ç½®çš„ç‰©å“ï¼Œå®ƒå¯èƒ½æ˜¯çœŸå®è£…å¤‡ï¼Œä¹Ÿå¯èƒ½æ˜¯ None
                item_in_slot = player.slots[slot_type][i]

                # åˆ¤æ–­æ§½ä½é‡Œæ˜¯å¦æœ‰ç‰©å“
                if item_in_slot is not None:
                    # å¦‚æœæœ‰ç‰©å“ï¼Œå¹¶ä¸”ä¸æ˜¯æ­£åœ¨æ‹–æ‹½çš„é‚£ä¸ªï¼Œå°±ç»˜åˆ¶ç‰©å“åç§°
                    if item_in_slot != self.dragging_item:
                        item_name = get_display_name(item_in_slot)
                        font = self._get_font('small', 13)
                        if font.size(item_name)[0] > slot_rect.width - 6: 
                            item_name = item_name[:3] + ".."
                        text = font.render(item_name, True, (255, 255, 255))
                        text_rect = text.get_rect(center=slot_rect.center)
                        surface.blit(text, text_rect)
                else:
                    # å¦‚æœæ²¡æœ‰ç‰©å“ (å€¼ä¸ºNone)ï¼Œå°±ç»˜åˆ¶æ’æ§½çš„é»˜è®¤åç§°
                    font = self._get_font('small', 14)
                    text_surf = font.render(slot_config["name"], True, (80, 90, 110))
                    text_rect = text_surf.get_rect(center=slot_rect.center)
                    surface.blit(text_surf, text_rect)
                    
    def _draw_character_stats(self, surface, panel_bg):
        stats_area = pygame.Rect(panel_bg.x + 15, panel_bg.bottom - 185, panel_bg.width - 30, 170)
        pygame.draw.rect(surface, (20, 25, 40, 150), stats_area, border_radius=10)
        player = self.game.player
        stats_data = [("æœ€å¤§ç”Ÿå‘½", f"{int(getattr(player, 'max_hp', 0))}"), ("æ”»å‡»", f"{int(getattr(player, 'attack', 0))}"), ("é˜²å¾¡", f"{int(getattr(player, 'defense', 0))}"), ("æ”»å‡»é€Ÿåº¦", f"{getattr(player, 'attack_speed', 0):.2f}"), ("æš´å‡»ç‡", f"{getattr(player, 'crit_chance', 0) * 100:.1f}%"), ("æš´å‡»ä¼¤å®³", f"{getattr(player, 'crit_multiplier', 0) * 100:.1f}%")]
        stats_font = self.game.fonts['small']; line_height = 26; y_offset = stats_area.y + 12
        for i, (name, value) in enumerate(stats_data):
            y_pos = y_offset + i * line_height
            name_surface = stats_font.render(f"{name}:", True, (180, 180, 180)); name_rect = name_surface.get_rect(x=stats_area.x + 15, centery=y_pos); surface.blit(name_surface, name_rect)
            value_surface = stats_font.render(str(value), True, (255, 215, 0)); value_rect = value_surface.get_rect(right=stats_area.right - 15, centery=y_pos); surface.blit(value_surface, value_rect)

    def _draw_dragging_item(self, surface):
        if self.dragging_item:
            mouse_pos = pygame.mouse.get_pos(); item_name = get_display_name(self.dragging_item)
            font = self._get_font('normal', 20); text_surface = font.render(item_name, True, (255, 255, 255)); text_rect = text_surface.get_rect(center=mouse_pos)
            bg_rect = text_rect.inflate(20, 12); pygame.draw.rect(surface, (40, 50, 80, 220), bg_rect, border_radius=8); pygame.draw.rect(surface, (255, 215, 0), bg_rect, width=2, border_radius=8); surface.blit(text_surface, text_rect)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\base.py
================================================================================

# states/base.py
class BaseState:
    def __init__(self, game):
        self.game = game

    def handle_event(self, event):
        """å¤„ç†è¯¥çŠ¶æ€ä¸‹çš„å•ä¸ªäº‹ä»¶"""
        pass

    def update(self):
        """æ›´æ–°è¯¥çŠ¶æ€ä¸‹çš„é€»è¾‘ï¼ˆéäº‹ä»¶é©±åŠ¨ï¼‰"""
        pass

    def draw(self, surface):
        """ç»˜åˆ¶è¯¥çŠ¶æ€çš„ç”»é¢"""
        pass


================================================================================
### æ–‡ä»¶è·¯å¾„: states\choice_screen.py
================================================================================

# states/choice_screen.py (å·²ä¿®æ­£)
import pygame
import inspect
from .base import BaseState
from ui import Button, draw_panel, draw_text
from settings import *

# states/choice_screen.py (ä¿®æ”¹è¿™ä¸ªå‡½æ•°)

class ChoiceScreen(BaseState):
    def __init__(self, game, item_choices, origin_room):
        super().__init__(game)
        self.is_overlay = True
        self.item_choices = item_choices
        self.origin_room = origin_room
        self.choice_buttons = []

        # --- å…³é”®ä¿®å¤ 3: åˆå§‹åŒ–â€œé—¨é”â€ ---
        # åˆå§‹çŠ¶æ€ä¸‹ï¼Œé—¨æ˜¯â€œæœªä¸Šé”â€çš„ï¼Œå…è®¸ç©å®¶åšå‡ºé€‰æ‹©ã€‚
        self.choice_made = False

        self._setup_ui()

    def _setup_ui(self):
        # ... (æ­¤æ–¹æ³•æ— éœ€ä¿®æ”¹) ...
        num_choices = len(self.item_choices)
        panel_width = 350 * num_choices + 100; panel_height = 500
        panel_rect = pygame.Rect(0, 0, panel_width, panel_height); panel_rect.center = (SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2)
        self.panel_rect = panel_rect
        card_width, card_height, spacing = 300, 400, 50
        start_x = panel_rect.centerx - (card_width * num_choices + spacing * (num_choices - 1)) / 2
        for i, item in enumerate(self.item_choices):
            card_x = start_x + i * (card_width + spacing)
            card_rect = pygame.Rect(panel_rect.y + 80, card_x,  card_width, card_height); card_rect.topleft = (card_x, panel_rect.y + 80)
            button = Button(card_rect, "", self.game.fonts['normal']); self.choice_buttons.append((button, item))

# states/choice_screen.py (æ›¿æ¢è¿™ä¸ªå‡½æ•°)

def handle_event(self, event):
    # å¦‚æœé—¨å·²ç»â€œé”ä¸Šâ€ï¼Œåˆ™ä¸å¤„ç†ä»»ä½•åç»­çš„ç‚¹å‡»äº‹ä»¶ï¼Œé˜²æ­¢é‡å¤è§¦å‘
    if self.choice_made:
        return

    for button, item in self.choice_buttons:
        # æ£€æŸ¥æŒ‰é’®æ˜¯å¦è¢«ç‚¹å‡»
        if button.handle_event(event):

            # --- å…³é”®ä¿®å¤ 1: ç«‹åˆ»â€œä¸Šé”â€ï¼ ---
            # ä¸€æ—¦ç©å®¶åšå‡ºé€‰æ‹©ï¼Œé©¬ä¸Šè®¾ç½®æ ‡å¿—ä½ï¼Œé˜²æ­¢ä»»ä½•åç»­çš„é‡å¤ç‚¹å‡»ã€‚
            self.choice_made = True 

            # æ‰§è¡Œæ‹¾å–ç‰©å“çš„é€»è¾‘
            feedback = self.game.player.pickup_item(item)
            if feedback:
                from .notification_screen import NotificationScreen
                self.game.state_stack.append(NotificationScreen(self.game, feedback))

            print(f"ç©å®¶é€‰æ‹©äº†: {getattr(item, 'display_name', item.__class__.__name__)}")

            # å°†æˆ¿é—´æ ‡è®°ä¸ºâ€œå·²æ¸…ç†â€
            self.origin_room.is_cleared = True

            # æ›´æ–°åº•å±‚çš„åœ°ç‰¢ç•Œé¢ï¼Œè®©é—¨æ˜¾ç¤ºå‡ºæ¥
            from .dungeon_screen import DungeonScreen
            # å®‰å…¨åœ°æ£€æŸ¥çŠ¶æ€æ ˆï¼Œç¡®ä¿å‰ä¸€ä¸ªç•Œé¢æ˜¯ DungeonScreen
            if len(self.game.state_stack) > 1:
                prev_state = self.game.state_stack[-2]
                if isinstance(prev_state, DungeonScreen):
                    prev_state.door_rects = prev_state._generate_doors()

            # --- å…³é”®ä¿®å¤ 2: â€œæ¼”å‘˜â€é€€åœºï¼ ---
            # åœ¨æ‰€æœ‰é€»è¾‘å¤„ç†å®Œæ¯•åï¼Œå°†è‡ªå·±ä»çŠ¶æ€æ ˆä¸­å¼¹å‡ºã€‚
            self.game.state_stack.pop() 

            # å› ä¸ºå·²ç»å¤„ç†å®Œå¹¶é€€å‡ºäº†ï¼Œç›´æ¥ return ç»“æŸè¯¥å‡½æ•°
            return
    # ... (draw æ–¹æ³•æ— éœ€ä¿®æ”¹) ...
    def draw(self, surface):
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA); overlay.fill((0, 0, 0, 180)); surface.blit(overlay, (0, 0))
        draw_panel(surface, self.panel_rect, "äºŒé€‰ä¸€", self.game.fonts['large'])
        for button, item in self.choice_buttons:
            bg_color = PANEL_BORDER_COLOR if button.is_hovered else PANEL_BG_COLOR
            pygame.draw.rect(surface, bg_color, button.rect, border_radius=10); pygame.draw.rect(surface, PANEL_BORDER_COLOR, button.rect, 2, border_radius=10)
            name = getattr(item, 'display_name', item.__class__.__name__); rarity = getattr(item, 'rarity', 'common'); color = RARITY_COLORS.get(rarity, RARITY_COLORS['common'])
            name_surf = self.game.fonts['normal'].render(f"[ {name} ]", True, color)
            name_rect = name_surf.get_rect(centerx=button.rect.centerx, top=button.rect.top + 20); surface.blit(name_surf, name_rect)
            line_y = name_rect.bottom + 10; pygame.draw.line(surface, PANEL_BORDER_COLOR, (button.rect.left + 20, line_y), (button.rect.right - 20, line_y))
            doc = inspect.getdoc(item) or "æ•ˆæœæœªçŸ¥ã€‚"; text_rect = button.rect.inflate(-40, -120); text_rect.top = line_y + 15
            draw_text(surface, doc, self.game.fonts['small'], TEXT_COLOR, text_rect)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\combat.py
================================================================================

# states/combat.py (å·²æ›´æ–°)
import pygame
import time
import random # å¯¼å…¥ random
from .base import BaseState
from ui import draw_character_panel, BattleLog, TooltipManager, Button, draw_panel
from settings import *
from Character import Character
import Talents

class CombatScreen(BaseState):
    def __init__(self, game, enemy_id, origin_identifier=None):
        super().__init__(game)
        self.enemy_id = enemy_id
        self.origin_id = origin_identifier
        
        self._initialize_combat()
        self.tooltip_manager = TooltipManager(self.game.fonts['small'])
        self.player_ui_elements, self.enemy_ui_elements = {}, {}
        self.is_paused = False
        pause_button_rect = pygame.Rect(SCREEN_WIDTH - 60, 10, 50, 50)
        self.pause_button = Button(pause_button_rect, "||", self.game.fonts['normal'])

    def _initialize_combat(self):
        enemy_preset = self.game.enemy_data[self.enemy_id]
        
        # --- æ ¸å¿ƒæ”¹åŠ¨ï¼šæ•Œäººçš„éšæœºå¤©èµ‹ç”Ÿæˆé€»è¾‘ ---
        rolled_talents = []
        possible_talents = enemy_preset.get("possible_talents", [])
        for talent_info in possible_talents:
            if random.random() < talent_info["chance"]:
                talent_class_name = talent_info["talent_class_name"]
                if hasattr(Talents, talent_class_name):
                    print(f"æ•Œäºº {enemy_preset['name']} è·å¾—äº†å¤©èµ‹: {talent_class_name}")
                    talent_class = getattr(Talents, talent_class_name)
                    rolled_talents.append(talent_class())
        
        # ä½¿ç”¨éšæœºç”Ÿæˆçš„å¤©èµ‹æ¥åˆ›å»ºæ•Œäººå®ä¾‹
        self.enemy = Character(
            id=self.enemy_id, # <-- å¢åŠ è¿™ä¸€è¡Œï¼ŒæŠŠä»jsonè¯»åˆ°çš„idä¼ ç»™Character
            name=enemy_preset["name"], 
            talents=rolled_talents, 
            **enemy_preset["stats"]
        )
        
        # --- åç»­é€»è¾‘ä¸å˜ ---
        self.game.player.on_enter_combat(); self.enemy.on_enter_combat()
        for eq in self.game.player.all_equipment: eq.on_battle_start(self.game.player)
        for eq in self.enemy.all_equipment: eq.on_battle_start(self.enemy)
        self.last_update_time = time.time()
        self.battle_log = BattleLog(BATTLE_LOG_RECT, self.game.fonts['small'])
        self.battle_log.add_message(f"æˆ˜æ–—å¼€å§‹ï¼é­é‡äº† {self.enemy.name}ï¼")

    # åœ¨ states/combat.py æ–‡ä»¶ä¸­ï¼Œæ‰¾åˆ°å¹¶æ›¿æ¢è¿™ä¸ªå‡½æ•°

    def _on_victory(self):
        """æˆ˜æ–—èƒœåˆ©åçš„å¤„ç†é€»è¾‘"""
        from .dungeon_screen import DungeonScreen
        from .loot import LootScreen
        from .title import TitleScreen

        next_story_stage_id = None
        # åˆ¤æ–­æˆ˜æ–—æ¥æº
        if len(self.game.state_stack) > 1 and isinstance(self.game.state_stack[-2], DungeonScreen):
            # --- åœ°ç‰¢æˆ˜æ–— ---
            dungeon_screen = self.game.state_stack[-2]
            if self.origin_id:
                dungeon_screen.on_monster_defeated(self.origin_id)
        else:
            # --- å‰§æƒ…æˆ˜æ–— ---
            print("ä¸»çº¿å‰§æƒ…æˆ˜æ–—èƒœåˆ©ï¼")
            current_stage_data = self.game.story_data.get(self.game.current_stage, {})
            next_story_stage_id = current_stage_data.get("next_win")

        # å¼¹å‡ºè‡ªå·± (CombatScreen)
        self.game.state_stack.pop()

        # --- æ ¸å¿ƒä¿®æ”¹åœ¨è¿™é‡Œ ---
        # ä¹‹å‰æˆ‘ä»¬ä¼ é€’çš„æ˜¯ self.enemy_id (ä¸€ä¸ªå­—ç¬¦ä¸²)
        # ç°åœ¨æˆ‘ä»¬ä¼ é€’æ•´ä¸ª self.enemy å¯¹è±¡ï¼Œå®ƒåŒ…å«äº†æ•Œäººçš„æ‰€æœ‰å®æ—¶ä¿¡æ¯ï¼
        self.game.state_stack.append(LootScreen(self.game, self.enemy, next_story_stage=next_story_stage_id))
        
    def update(self):
        if self.is_paused: return
        from .title import TitleScreen
        now = time.time(); dt = now - self.last_update_time; self.last_update_time = now
        for msg in self.game.player.update(dt): self.battle_log.add_message(msg)
        for msg in self.enemy.update(dt): self.battle_log.add_message(msg)
        player_res = self.game.player.try_attack(self.enemy, dt)
        if player_res: main, extra = player_res; self.battle_log.add_message(main); [self.battle_log.add_message(f"  â”” {e}") for e in extra]
        enemy_res = self.enemy.try_attack(self.game.player, dt)
        if enemy_res: main, extra = enemy_res; self.battle_log.add_message(main); [self.battle_log.add_message(f"  â”” {e}") for e in extra]
        self._update_hovers()
        if self.enemy.hp <= 0: self._on_victory()
        elif self.game.player.hp <= 0: self.game.state_stack = [TitleScreen(self.game)]
    def _update_hovers(self):
        mouse_pos = pygame.mouse.get_pos(); hovered_object = None
        all_elements = self.player_ui_elements.get('talents', []) + self.player_ui_elements.get('buffs', []) + \
                       self.enemy_ui_elements.get('talents', []) + self.enemy_ui_elements.get('buffs', [])
        for rect, obj in all_elements:
            if rect.collidepoint(mouse_pos): hovered_object = obj; break
        self.tooltip_manager.update(hovered_object)
    def draw(self, surface):
        surface.fill(BG_COLOR)
        self.player_ui_elements = draw_character_panel(surface, self.game.player, PLAYER_PANEL_RECT, self.game.fonts)
        self.enemy_ui_elements = draw_character_panel(surface, self.enemy, ENEMY_PANEL_RECT, self.game.fonts)
        self.battle_log.draw(surface); self.pause_button.draw(surface)
        if self.is_paused:
            overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA); overlay.fill((0, 0, 0, 180)); surface.blit(overlay, (0, 0))
            paused_rect = pygame.Rect(0, 0, 400, 200); paused_rect.center = (SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2)
            draw_panel(surface, paused_rect, "æ¸¸æˆå·²æš‚åœ", self.game.fonts['large'])
        self.tooltip_manager.draw(surface)
    def handle_event(self, event):
        if self.pause_button.handle_event(event) or (event.type == pygame.KEYDOWN and event.key == pygame.K_p):
            self.is_paused = not self.is_paused;
            if not self.is_paused: self.last_update_time = time.time()
            return
        if self.is_paused: return
        from .confirm_dialog import ConfirmDialog; from .title import TitleScreen
        if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
            def on_confirm_action(): self.game.state_stack = [TitleScreen(self.game)]
            confirm_dialog = ConfirmDialog(self.game, "æ‰€æœ‰æˆ˜æ–—è¿›åº¦éƒ½å°†ä¸¢å¤±ï¼Œç¡®å®šè¦è¿”å›ä¸»èœå•å—ï¼Ÿ", on_confirm_action)
            self.game.state_stack.append(confirm_dialog)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\combat_victory.py
================================================================================

# states/combat_victory.py
import pygame
from .base import BaseState
# <-- å¯¼å…¥æ–°çš„UIå·¥å…·
from ui import draw_character_panel, draw_panel, Button
from settings import *

class CombatVictoryScreen(BaseState):
    def __init__(self, game, final_enemy):
        super().__init__(game)
        self.final_enemy = final_enemy
        # <-- æ–°å¢ï¼šåˆ›å»ºä¸€ä¸ªç»§ç»­æŒ‰é’®
        self.continue_button = Button(
            (SCREEN_WIDTH / 2 - 150, SCREEN_HEIGHT - 100, 300, 60),
            "è¿›å…¥ç»“ç®—",
            self.game.fonts['normal']
        )

    def handle_event(self, event):
        from states.loot import LootScreen
        # <-- ä½¿ç”¨æŒ‰é’®çš„ handle_event æ–¹æ³•
        if self.continue_button.handle_event(event) or \
           (event.type == pygame.KEYDOWN and event.key in [pygame.K_RETURN, pygame.K_SPACE]):
            self.game.state_stack.pop()
            self.game.state_stack.append(LootScreen(self.game))

    def draw(self, surface):
        surface.fill(BG_COLOR)
        # <-- ä¿æŒé£æ ¼ç»Ÿä¸€ï¼Œç»§ç»­ä½¿ç”¨è§’è‰²é¢æ¿æ˜¾ç¤ºæœ€ç»ˆçŠ¶æ€
        draw_character_panel(surface, self.game.player, PLAYER_PANEL_RECT, self.game.fonts)
        draw_character_panel(surface, self.final_enemy, ENEMY_PANEL_RECT, self.game.fonts)

        # <-- ä½¿ç”¨ä¸€ä¸ªé¢æ¿æ¥æ˜¾ç¤ºèƒœåˆ©ä¿¡æ¯ï¼Œæ›´æœ‰ä»ªå¼æ„Ÿ
        victory_panel_rect = pygame.Rect(SCREEN_WIDTH * 0.25, SCREEN_HEIGHT / 2 - 100, SCREEN_WIDTH * 0.5, 200)
        draw_panel(surface, victory_panel_rect, "æˆ˜æ–—èƒœåˆ©ï¼", self.game.fonts['large'])
        
        # <-- ç»˜åˆ¶æŒ‰é’®
        self.continue_button.draw(surface)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\confirm_dialog.py
================================================================================

# states/confirm_dialog.py
import pygame
from .base import BaseState
from ui import Button, draw_text, draw_panel
from settings import *

class ConfirmDialog(BaseState):
    def __init__(self, game, text, on_confirm):
        super().__init__(game)
        self.is_overlay = True
        self.text = text
        self.on_confirm = on_confirm # æ¥å—ä¸€ä¸ªâ€œç¡®è®¤â€åè¦æ‰§è¡Œçš„å‡½æ•°

        # å®šä¹‰UIå…ƒç´ 
        panel_w, panel_h = 600, 300
        self.panel_rect = pygame.Rect((SCREEN_WIDTH - panel_w) / 2, (SCREEN_HEIGHT - panel_h) / 2, panel_w, panel_h)
        
        btn_w, btn_h = 150, 60
        self.yes_button = Button((self.panel_rect.centerx - btn_w - 20, self.panel_rect.bottom - 100, btn_w, btn_h), "ç¡®è®¤", self.game.fonts['normal'])
        self.no_button = Button((self.panel_rect.centerx + 20, self.panel_rect.bottom - 100, btn_w, btn_h), "å–æ¶ˆ", self.game.fonts['normal'])

    def handle_event(self, event):
        if self.yes_button.handle_event(event):
            self.on_confirm() # æ‰§è¡Œç¡®è®¤æ“ä½œ
        
        if self.no_button.handle_event(event):
            self.game.state_stack.pop() # ç‚¹å‡»â€œå–æ¶ˆâ€ï¼Œåªå¼¹å‡ºè‡ªå·±

        if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
            self.game.state_stack.pop() # æŒ‰ESCä¹Ÿè§†ä¸ºå–æ¶ˆ

    def draw(self, surface):
        
        
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))

        # 2. ç»˜åˆ¶å¯¹è¯æ¡†é¢æ¿
        draw_panel(surface, self.panel_rect, "è¯·ç¡®è®¤", self.game.fonts['large'])
        
        # 3. ç»˜åˆ¶æç¤ºæ–‡å­—
        text_rect = self.panel_rect.inflate(-80, -80)
        text_rect.h = 100 # é™åˆ¶æ–‡å­—åŒºåŸŸé«˜åº¦
        draw_text(surface, self.text, self.game.fonts['normal'], TEXT_COLOR, text_rect)

        # 4. ç»˜åˆ¶æŒ‰é’®
        self.yes_button.draw(surface)
        self.no_button.draw(surface)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\dungeon_screen.py
================================================================================

import pygame
import random
from .base import BaseState
from dungeon_generator import Floor
from player_sprite import Player
from monster_sprite import Monster
from treasure_sprite import TreasureChest
import Equips
from settings import *
from ui import Button

NODE_STYLE = {"start": {"color": (100, 255, 100)},"combat": {"color": (200, 200, 200)}, "event": {"color": (255, 255, 100)},"treasure": {"color": (255, 215, 0)},"elite": {"color": (255, 50, 50)},"boss": {"color": (160, 32, 240)},"rest": {"color": (100, 200, 255)},"shop": {"color": (100, 255, 200)},"forge": {"color": (150, 150, 150)}}

# File: states/dungeon_screen.py

class DungeonScreen(BaseState):
    def __init__(self, game, dungeon_id="sunstone_ruins", floor_number=1):
        super().__init__(game)

        self.dungeon_id = dungeon_id
        self.floor_number = floor_number
        self.dungeon_data = self.game.dungeon_data[dungeon_id]

        # Find the correct data pool for the current floor
        self.current_floor_data = None
        for pool in self.dungeon_data.get("floor_pools", []):
            if self.floor_number in pool["floors"]:
                self.current_floor_data = pool
                break

        self.floor = Floor()
        # Pass the floor data to the generator
        self.floor.generate_floor(num_rooms=8, floor_data=self.current_floor_data)

        self.player = Player(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2)
        self.player_group = pygame.sprite.GroupSingle(self.player)
        self.monster_group, self.chest_group = pygame.sprite.Group(), pygame.sprite.GroupSingle()
        self.door_rects, self.exit_portal_button = {}, None
        self.current_room = self.floor.start_room
        self._enter_room(self.current_room)

        # UI Buttons
        backpack_button_rect = pygame.Rect(SCREEN_WIDTH - 160, 10, 140, 50)
        self.backpack_button = Button(backpack_button_rect, "èƒŒåŒ… (B)", self.game.fonts['small'])

        talents_button_rect = pygame.Rect(backpack_button_rect.left - 150, 10, 140, 50)
        self.talents_button = Button(talents_button_rect, "å¤©èµ‹ (T)", self.game.fonts['small'])

    # æ–‡ä»¶: states/dungeon_screen.py (æ›¿æ¢è¿™ä¸ªå‡½æ•°)

    def _enter_room(self, room):
        self.current_room = room
        if not (self.current_room.type == 'boss' and self.current_room.is_cleared):
            self.exit_portal_button = None
        print(f"è¿›å…¥æˆ¿é—´ ({room.x}, {room.y}), ç±»å‹: {room.type}")

        # --- æ ¸å¿ƒæ”¹åŠ¨åœ¨è¿™é‡Œ ---
        room_type = self.current_room.type
        is_cleared = self.current_room.is_cleared

        # åªæœ‰æœªæ¸…ç†è¿‡çš„ç‰¹æ®Šæˆ¿é—´æ‰ä¼šè§¦å‘ä¸€æ¬¡æ€§äº‹ä»¶
        if not is_cleared:
            if room_type == "event":
                from .event_screen import EventScreen
                event_id = random.choice(list(self.game.event_data.keys()))
                self.game.state_stack.append(EventScreen(self.game, event_id, self.current_room))
            elif room_type == "shop":
                from .shop_screen import ShopScreen
                self.game.state_stack.append(ShopScreen(self.game, self.current_room))
            
            # --- æ–°å¢çš„åˆ†æ”¯ ---
            elif room_type == "rest":
                from .rest_screen import RestScreen # å¯¼å…¥æˆ‘ä»¬åˆšåˆ›å»ºçš„ä¼‘æ¯ç•Œé¢
                # å¼¹å‡ºä¼‘æ¯ç•Œé¢ï¼Œå¹¶æŠŠå½“å‰æˆ¿é—´ä¿¡æ¯ä¼ è¿‡å»
                self.game.state_stack.append(RestScreen(self.game, self.current_room))

        self._sync_sprites()
        self.door_rects = self._generate_doors()

    def _generate_doors(self):
        if not self.current_room.is_cleared: return {}
        doors = {}; door_size, margin = 60, 10
        if self.current_room.doors["N"]: doors["N"] = pygame.Rect(SCREEN_WIDTH/2 - door_size/2, 0, door_size, margin)
        if self.current_room.doors["S"]: doors["S"] = pygame.Rect(SCREEN_WIDTH/2 - door_size/2, SCREEN_HEIGHT - margin, door_size, margin)
        if self.current_room.doors["W"]: doors["W"] = pygame.Rect(0, SCREEN_HEIGHT/2 - door_size/2, margin, door_size)
        if self.current_room.doors["E"]: doors["E"] = pygame.Rect(SCREEN_WIDTH - margin, SCREEN_HEIGHT/2 - door_size/2, margin, door_size)
        return doors
        
    def _sync_sprites(self):
        self.monster_group.empty()
        self.chest_group.empty()

        if not self.current_room.is_cleared:
            if self.current_room.type in ["combat", "elite", "boss"]:
                for monster_data in self.current_room.monsters:
                    self.monster_group.add(Monster(monster_data))
            elif self.current_room.type == "treasure":
                self.chest_group.add(TreasureChest(SCREEN_WIDTH / 2, SCREEN_HEIGHT / 2))

    def _open_treasure_chest(self, chest_sprite):
        """æ‰“å¼€å®ç®±ï¼Œå¹¶æ ¹æ®å½“å‰æ¥¼å±‚é…ç½®(JSON)ç”Ÿæˆé€‰é¡¹"""
        print("æ‰“å¼€å®-ç®±ï¼")
        
        # --- æ ¸å¿ƒé€»è¾‘ï¼šä»å½“å‰æ¥¼å±‚æ•°æ®ä¸­ï¼Œè¯»å–å®ç®±çš„é…ç½® ---
        # self.current_floor_data æ˜¯åœ¨ __init__ ä¸­ä»JSONåŠ è½½çš„
        if not self.current_floor_data or "treasure_loot" not in self.current_floor_data:
            print("é”™è¯¯ï¼šåœ¨dungeon_data.jsonä¸­æœªæ‰¾åˆ°å½“å‰æ¥¼å±‚çš„ treasure_loot é…ç½®ï¼")
            # å³ä½¿å‡ºé”™ï¼Œä¹Ÿè¦æ¸…ç†ç°åœºï¼Œé˜²æ­¢ç©å®¶å¡ä½
            self.current_room.is_cleared = True
            self.door_rects = self._generate_doors()
            chest_sprite.kill()
            return

        loot_config = self.current_floor_data["treasure_loot"]
        rarity_weights = loot_config.get("rarity_weights", {"common": 100})
        item_count = loot_config.get("item_count", 2)
        
        # 1. åˆ›å»ºä¸€ä¸ªæ‰€æœ‰è£…å¤‡çš„â€œæ•°æ®åº“â€ï¼ŒæŒ‰å“è´¨åˆ†ç±»
        item_pool = {rarity: [] for rarity in rarity_weights.keys()}
        all_item_classes = [getattr(Equips, name) for name in dir(Equips) if 
                            isinstance(getattr(Equips, name), type) and 
                            issubclass(getattr(Equips, name), Equips.Equipment) and 
                            getattr(Equips, name) is not Equips.Equipment]
        
        for item_class in all_item_classes:
            temp_item = item_class()
            if hasattr(temp_item, 'rarity') and temp_item.rarity in item_pool:
                item_pool[temp_item.rarity].append(item_class)

        # 2. æ ¹æ®ä»JSONè¯»æ¥çš„æƒé‡ï¼Œéšæœºé€‰æ‹©å“è´¨
        rarities_to_spawn = random.choices(
            list(rarity_weights.keys()), 
            weights=list(rarity_weights.values()), 
            k=item_count
        )

        # 3. ä»å¯¹åº”å“è´¨çš„æ± å­é‡Œï¼ŒéšæœºæŒ‘é€‰ç‰©å“
        choices = []
        for rarity in rarities_to_spawn:
            if item_pool.get(rarity):
                item_class = random.choice(item_pool[rarity])
                choices.append(item_class())

        # 4. å¦‚æœæœªèƒ½ç”Ÿæˆä»»ä½•ç‰©å“ï¼Œåˆ™ç»™å‡ºæç¤ºå¹¶é€€å‡º
        if not choices:
            print("é”™è¯¯: ç‰©å“æ± ä¸ºç©ºæˆ–æœªèƒ½æ ¹æ®è§„åˆ™ç”Ÿæˆä»»ä½•ç‰©å“ï¼")
            self.current_room.is_cleared = True
            self.door_rects = self._generate_doors()
            chest_sprite.kill()
            return

        # 5. å¼¹å‡ºé€‰æ‹©ç•Œé¢
        from .choice_screen import ChoiceScreen
        self.game.state_stack.append(ChoiceScreen(self.game, choices, self.current_room))
        
        chest_sprite.kill()
        
    def on_monster_defeated(self, defeated_monster_uid):
        self.current_room.monsters = [m for m in self.current_room.monsters if m['uid'] != defeated_monster_uid]
        self._sync_sprites()
        if not self.current_room.monsters:
            self.current_room.is_cleared = True; self.door_rects = self._generate_doors()
            if self.current_room.type == "boss":
                portal_rect = pygame.Rect(0,0,200,80); portal_rect.center = (SCREEN_WIDTH/2, SCREEN_HEIGHT/2)
                self.exit_portal_button = Button(portal_rect, "å‰å¾€ä¸‹ä¸€å±‚", self.game.fonts['normal'])

    def update(self):
        self.player_group.update()
        if not self.current_room.is_cleared:
            self.monster_group.update()
            collided_monster = pygame.sprite.spritecollideany(self.player, self.monster_group)
            if collided_monster:
                from .combat import CombatScreen
                self.game.state_stack.append(CombatScreen(self.game, collided_monster.enemy_id, collided_monster.uid))
                self.monster_group.empty(); return
        else:
            for direction, door_rect in self.door_rects.items():
                if self.player.rect.colliderect(door_rect):
                    self._change_room(direction); break
    
    def _change_room(self, direction):
        x, y = self.current_room.x, self.current_room.y; next_room_coord = None
        if direction == "N": next_room_coord = (x, y - 1)
        if direction == "S": next_room_coord = (x, y + 1)
        if direction == "W": next_room_coord = (x - 1, y)
        if direction == "E": next_room_coord = (x + 1, y)
        if next_room_coord in self.floor.rooms:
            next_room = self.floor.rooms[next_room_coord]; self._enter_room(next_room)
            if direction == "N": self.player.rect.bottom = SCREEN_HEIGHT - 15
            if direction == "S": self.player.rect.top = 15
            if direction == "W": self.player.rect.right = SCREEN_WIDTH - 15
            if direction == "E": self.player.rect.left = 15

    def draw(self, surface):
        surface.fill(BG_COLOR)
        for door_rect in self.door_rects.values(): pygame.draw.rect(surface, (100, 200, 100), door_rect)
        if self.exit_portal_button: self.exit_portal_button.draw(surface)
        self.monster_group.draw(surface); self.chest_group.draw(surface)
        self.player_group.draw(surface)
        self._draw_minimap(surface)
        self.backpack_button.draw(surface)
        self.talents_button.draw(surface) # <-- æ–°å¢ï¼šç»˜åˆ¶å¤©èµ‹æŒ‰é’®
        
    def _draw_minimap(self, surface):
        minimap_rect = pygame.Rect(10, 10, 230, 230)
        pygame.draw.rect(surface, PANEL_BG_COLOR, minimap_rect); pygame.draw.rect(surface, PANEL_BORDER_COLOR, minimap_rect, 2)
        cell_size = 15
        for (x, y), room in self.floor.rooms.items():
            map_x, map_y = minimap_rect.x + x*cell_size + 5, minimap_rect.y + y*cell_size + 5
            cell_rect = pygame.Rect(map_x, map_y, cell_size - 1, cell_size - 1)
            base_color = NODE_STYLE.get(room.type, {"color": (255,255,255)})["color"]
            final_color = base_color
            if not room.is_cleared and room.type != "start":
                final_color = (base_color[0] // 2, base_color[1] // 2, base_color[2] // 2)
            pygame.draw.rect(surface, final_color, cell_rect)
            if room is self.current_room:
                p1 = (cell_rect.centerx, cell_rect.top + 3); p2 = (cell_rect.left + 3, cell_rect.bottom - 3); p3 = (cell_rect.right - 3, cell_rect.bottom - 3)
                pygame.draw.polygon(surface, (255, 255, 255, 200), [p1, p2, p3])


================================================================================
### æ–‡ä»¶è·¯å¾„: states\event_screen.py
================================================================================

# states/event_screen.py
import pygame
import random
from .base import BaseState
from ui import Button, draw_panel, draw_text
from settings import *
import Talents # å¯¼å…¥å¤©èµ‹æ¨¡å—

class EventScreen(BaseState):
    def __init__(self, game, event_id, origin_room):
        super().__init__(game)
        self.is_overlay = True
        self.event_data = self.game.event_data[event_id]
        self.origin_room = origin_room
        
        # ç•Œé¢çŠ¶æ€ç®¡ç†ï¼š'choosing' (é€‰æ‹©ä¸­) æˆ– 'showing_result' (æ˜¾ç¤ºç»“æœ)
        self.view_mode = 'choosing' 
        self.result_text = ""
        
        self._setup_ui()

    def _setup_ui(self):
        # é¢æ¿
        panel_w, panel_h = 800, 500
        self.panel_rect = pygame.Rect((SCREEN_WIDTH - panel_w) / 2, (SCREEN_HEIGHT - panel_h) / 2, panel_w, panel_h)
        
        # é€‰é¡¹æŒ‰é’®
        self.choice_buttons = []
        btn_w, btn_h = 600, 60
        num_choices = len(self.event_data["choices"])
        start_y = self.panel_rect.bottom - (btn_h + 20) * num_choices - 20
        
        for i, choice in enumerate(self.event_data["choices"]):
            rect = pygame.Rect(self.panel_rect.centerx - btn_w / 2, start_y + i * (btn_h + 20), btn_w, btn_h)
            self.choice_buttons.append(Button(rect, choice["text"], self.game.fonts['normal']))
            
        # â€œç»§ç»­â€æŒ‰é’®ï¼ˆç”¨äºæ˜¾ç¤ºç»“æœåï¼‰
        self.continue_button = Button(self.choice_buttons[-1].rect, "ç»§ç»­...", self.game.fonts['normal'])

    def handle_event(self, event):
        if self.view_mode == 'choosing':
            for i, button in enumerate(self.choice_buttons):
                if button.handle_event(event):
                    self._process_choice(i)
                    return
        elif self.view_mode == 'showing_result':
            if self.continue_button.handle_event(event):
                self._leave_event()

    # åœ¨ states/event_screen.py æ–‡ä»¶ä¸­ï¼Œæ‰¾åˆ°å¹¶æ›¿æ¢è¿™ä¸ªå‡½æ•°

    def _process_choice(self, choice_index):
        """å¤„ç†ç©å®¶çš„é€‰æ‹©å¹¶è®¡ç®—ç»“æœ"""
        choice_data = self.event_data["choices"][choice_index]
        outcomes = choice_data["outcomes"]
        
        rand_val = random.random()
        cumulative_chance = 0.0
        selected_outcome = None
        for outcome in outcomes:
            cumulative_chance += outcome.get("chance", 1.0)
            if rand_val < cumulative_chance:
                selected_outcome = outcome
                break
        
        if not selected_outcome: return

        outcome_type = selected_outcome["type"]
        self.result_text = selected_outcome["result_text"]
        
        player = self.game.player
        if outcome_type == "HEAL":
            if selected_outcome["amount"] == "full":
                player.hp = player.max_hp
        
        elif outcome_type == "WEAPON_UPGRADE":
            player.base_attack += 5
            player.attack += 5
        
        elif outcome_type == "WEAPON_CURSE":
            player.base_attack = max(1, player.base_attack - 3)
            player.attack = max(1, player.attack - 3)
            
        # --- æ ¸å¿ƒä¿®å¤ï¼šä½¿ç”¨æ–°çš„å¤©èµ‹å­¦ä¹ å’Œè£…å¤‡é€»è¾‘ ---
        elif outcome_type == "GAIN_TALENT":
            talent_class_name = selected_outcome["talent_class_name"]
            if hasattr(Talents, talent_class_name):
                talent_instance = getattr(Talents, talent_class_name)()
                
                # 1. å°è¯•å­¦ä¹ æ–°å¤©èµ‹
                was_new = player.learn_talent(talent_instance)
                
                if was_new:
                    # 2. å¦‚æœæ˜¯æ–°å­¦ä¼šçš„ï¼Œå°è¯•è‡ªåŠ¨è£…å¤‡å®ƒ
                    was_equipped = player.equip_talent(talent_instance)
                    if not was_equipped:
                        self.result_text += " (å¤©èµ‹æ§½å·²æ»¡ï¼Œè¯·åœ¨å¤©èµ‹ç•Œé¢(T)æ‰‹åŠ¨è£…å¤‡)"
                else:
                    self.result_text = "ä½ ä¼¼ä¹å·²ç»é¢†æ‚Ÿè¿‡ç±»ä¼¼çš„èƒ½åŠ›äº†..."

        elif outcome_type == "TRIGGER_COMBAT":
            from .combat import CombatScreen
            enemy_id = selected_outcome["enemy_id"]
            self._leave_event()
            # å‰§æƒ…æˆ˜æ–—ä¸éœ€è¦ origin_id
            self.game.state_stack.append(CombatScreen(self.game, enemy_id)) 
            return
            
        self.view_mode = 'showing_result'

    def _leave_event(self):
        """ç¦»å¼€äº‹ä»¶ï¼Œæ›´æ–°åœ°å›¾å¹¶å…³é—­ç•Œé¢"""
        from .dungeon_screen import DungeonScreen
        self.origin_room.is_cleared = True
        if len(self.game.state_stack) > 1:
            prev_state = self.game.state_stack[-2]
            if isinstance(prev_state, DungeonScreen):
                prev_state.door_rects = prev_state._generate_doors()
        self.game.state_stack.pop()

    def draw(self, surface):
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180)); surface.blit(overlay, (0, 0))
        
        draw_panel(surface, self.panel_rect, self.event_data["title"], self.game.fonts['large'])
        
        if self.view_mode == 'choosing':
            desc_rect = self.panel_rect.inflate(-80, -250)
            desc_rect.top = self.panel_rect.top + 100
            draw_text(surface, self.event_data["description"], self.game.fonts['normal'], TEXT_COLOR, desc_rect)
            for button in self.choice_buttons:
                button.draw(surface)
        elif self.view_mode == 'showing_result':
            result_rect = self.panel_rect.inflate(-80, -250)
            result_rect.top = self.panel_rect.top + 150
            draw_text(surface, self.result_text, self.game.fonts['normal'], HOVER_COLOR, result_rect)
            self.continue_button.draw(surface)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\loading.py
================================================================================

# states/loading.py
import pygame
import time
from .base import BaseState
from ui import draw_text, Button
from settings import *

class LoadScreen(BaseState):
    def __init__(self, game):
        super().__init__(game)
        self.back_button = Button((SCREEN_WIDTH / 2 - 150, SCREEN_HEIGHT - 100, 300, 60), "è¿”å›", self.game.fonts['normal'])
        self.slot_rects = [pygame.Rect(100, 120 + i * 50, SCREEN_WIDTH - 200, 50) for i in range(10)]
        self.load_fail_message = None

    def handle_event(self, event):
        if self.back_button.handle_event(event) or (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
            self.game.state_stack.pop()
            return

        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            for i, rect in enumerate(self.slot_rects):
                if rect.collidepoint(event.pos):
                    # --- è¿™æ˜¯æ ¸å¿ƒä¿®å¤ ---
                    # load_from_slot ä¼šæ›´æ–° self.game çš„ player, current_stage ç­‰
                    if self.game.load_from_slot(i):
                        from states.story import StoryScreen
                        # æ¸…ç©ºæ•´ä¸ªçŠ¶æ€æ ˆï¼Œç„¶åå‹å…¥ä¸€ä¸ªæ–°çš„ã€åŸºäºå·²åŠ è½½æ•°æ®çš„ StoryScreen
                        self.game.state_stack = [StoryScreen(self.game)]
                    else:
                        self.load_fail_message = f"æ§½ä½ {i} ä¸ºç©ºæˆ–æŸåï¼"
                    return
                    # --- ä¿®å¤ç»“æŸ ---

    def draw(self, surface):
        surface.fill(BG_COLOR)
        title_font = self.game.fonts['large']
        draw_text(surface, "é€‰æ‹©è¦åŠ è½½çš„å­˜æ¡£", title_font, TEXT_COLOR, pygame.Rect(0, 50, SCREEN_WIDTH, 100))

        for i, rect in enumerate(self.slot_rects):
            slot_data = self.game.peek_save_slot(i)
            is_hovered = rect.collidepoint(pygame.mouse.get_pos())
            if is_hovered:
                pygame.draw.rect(surface, PANEL_BORDER_COLOR, rect.inflate(10, 10), 2, border_radius=5)
            
            text = f"{i}. " + ("(è‡ªåŠ¨)" if i == 0 else "")
            if slot_data and slot_data.get("player"):
                player = slot_data["player"]
                save_time = time.strftime('%Y-%m-%d %H:%M', time.localtime(slot_data.get("timestamp", 0)))
                text += f"{player.name} - ç­‰çº§ {player.level} ({save_time})"
            else:
                text += "-- ç©º --"
            draw_text(surface, text, self.game.fonts['normal'], TEXT_COLOR, rect)

        if self.load_fail_message:
            fail_rect = pygame.Rect(0, SCREEN_HEIGHT - 150, SCREEN_WIDTH, 40)
            draw_text(surface, self.load_fail_message, self.game.fonts['normal'], (255, 100, 100), fail_rect)

        self.back_button.draw(surface)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\loot.py
================================================================================

# states/loot.py (å·²ä¿®æ­£)
import pygame
import random
from .base import BaseState
from ui import draw_panel, draw_text
from settings import *
import Equips
from Character import Character # éœ€è¦å¯¼å…¥Characterç±»ç”¨äºç±»å‹æ£€æŸ¥

class LootScreen(BaseState):
    def __init__(self, game, defeated_enemy_object=None, next_story_stage=None):
        super().__init__(game)
        self.is_overlay = True

        # --- æ ¸å¿ƒä¿®æ”¹åœ¨è¿™é‡Œ ---
        # defeated_enemy_object ç°åœ¨æ˜¯å®Œæ•´çš„æ•Œäººå¯¹è±¡
        self.defeated_enemy_object = defeated_enemy_object
        # æˆ‘ä»¬ä»ç„¶éœ€è¦ enemy_id æ¥æŸ¥è¯¢è£…å¤‡æ‰è½è¡¨
        self.defeated_enemy_id = defeated_enemy_object.id if isinstance(defeated_enemy_object, Character) else None

        self.next_story_stage = next_story_stage

        panel_w = SCREEN_WIDTH * 0.7
        panel_h = SCREEN_HEIGHT * 0.7
        self.panel_rect = pygame.Rect(
            (SCREEN_WIDTH - panel_w) / 2,
            (SCREEN_HEIGHT - panel_h) / 2,
            panel_w, panel_h
        )
        self._process_rewards()
        # ------------------------------------

        self._process_rewards()

    def _process_rewards(self):
        self.exp_messages = []
        if self.defeated_enemy_id:
            enemy_preset = self.game.enemy_data.get(self.defeated_enemy_id, {})
            self.exp_messages = self.game.player.add_exp(enemy_preset.get("exp_reward", 0))
        
        self.loot_messages = self._generate_loot()
        self.game.save_to_slot(0)
        


    def _generate_loot(self):
        messages = []
        found_any_loot = False

        # --- Part 1: è£…å¤‡æ‰è½é€»è¾‘ (ç°åœ¨ä½¿ç”¨ self.defeated_enemy_id) ---
        if self.defeated_enemy_id: # ç¡®ä¿IDå­˜åœ¨
            equipment_drops = self.game.loot_data.get(self.defeated_enemy_id, [])
            if equipment_drops:
                messages.append("--- æˆ˜åˆ©å“ ---")
                for drop_info in equipment_drops:
                    if random.random() < drop_info.get("chance", 1.0):
                        found_any_loot = True
                        item_class_name = drop_info["item_class_name"]
                        try:
                            item_class = getattr(Equips, item_class_name)
                            new_item = item_class()
                            display_name = getattr(new_item, 'display_name', item_class_name)
                            feedback = self.game.player.pickup_item(new_item)
                            if "æ”¾å…¥ä½ çš„èƒŒåŒ…" in feedback:
                                messages.append(f"è·å¾—äº†è£…å¤‡ï¼š{display_name}ï¼")
                            else:
                                messages.append(feedback)
                        except AttributeError:
                            messages.append(f"é”™è¯¯ï¼šæœªæ‰¾åˆ°ç‰©å“ {item_class_name}ã€‚")

        # --- Part 2: å…¨æ–°çš„ã€æ›´ç²¾ç¡®çš„å¤©èµ‹æ‰è½é€»è¾‘ ---
        import Talents

        # ç›´æ¥ä»ä¼ é€’è¿‡æ¥çš„æ•Œäººå¯¹è±¡ä¸­è·å–å®ƒå®é™…æ‹¥æœ‰çš„å¤©èµ‹åˆ—è¡¨ï¼
        if self.defeated_enemy_object and self.defeated_enemy_object.equipped_talents:
            messages.append("--- èƒ½åŠ›é¢†æ‚Ÿ ---")

            # éå†è¿™ä¸ªæ•Œäººåœ¨æˆ˜æ–—ä¸­çœŸæ­£æ‹¥æœ‰çš„æ¯ä¸€ä¸ªå¤©èµ‹
            for possessed_talent in self.defeated_enemy_object.equipped_talents:
                # åœ¨è¿™é‡Œè®¾ç½®ä¸€ä¸ªå›ºå®šçš„å¤©èµ‹æ‰è½ç‡ï¼Œæ¯”å¦‚ 15%
                TALENT_DROP_CHANCE = 0.15 

                if random.random() < TALENT_DROP_CHANCE:
                    # å°è¯•è®©ç©å®¶å­¦ä¹ è¿™ä¸ªå¤©èµ‹
                    was_new = self.game.player.learn_talent(possessed_talent)

                    if was_new:
                        found_any_loot = True
                        messages.append(f"ä½ ä»æ•Œäººèº«ä¸Šé¢†æ‚Ÿäº†ã€Œ{possessed_talent.display_name}ã€ï¼")

        # --- Part 3: æœ€ç»ˆæ€»ç»“ ---
        if not found_any_loot:
            messages.append("æ•Œäººæ²¡æœ‰ç•™ä¸‹ä»»ä½•æœ‰ä»·å€¼çš„ä¸œè¥¿ã€‚")

        return messages

    def handle_event(self, event):
        if (event.type == pygame.MOUSEBUTTONDOWN and event.button == 1) or \
           (event.type == pygame.KEYDOWN and event.key in [pygame.K_RETURN, pygame.K_SPACE]):
            
            if self.next_story_stage:
                from .story import StoryScreen
                self.game.current_stage = self.next_story_stage
                self.game.state_stack.pop()
                if self.game.state_stack and isinstance(self.game.state_stack[-1], StoryScreen):
                    self.game.state_stack.pop()
                self.game.state_stack.append(StoryScreen(self.game))
            else:
                self.game.state_stack.pop()

    def draw(self, surface):
        # ç»˜åˆ¶åº•å±‚ç•Œé¢
        if len(self.game.state_stack) > 1:
            self.game.state_stack[-2].draw(surface)
        
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180)); surface.blit(overlay, (0, 0))
        
        # --- æ ¸å¿ƒä¿®å¤ï¼šä½¿ç”¨ self.panel_rect ---
        title = "æˆ˜æ–—èƒœåˆ©" if self.defeated_enemy_id else "æ‰“å¼€å®ç®±"
        draw_panel(surface, self.panel_rect, title, self.game.fonts['large'])
        
        all_messages = self.exp_messages + self.loot_messages
        current_y = self.panel_rect.top + 120
        for line in all_messages:
            clean_line = line.replace("ğŸ‰ ", "")
            text_surf = self.game.fonts['normal'].render(clean_line, True, TEXT_COLOR)
            text_rect = text_surf.get_rect(center=(self.panel_rect.centerx, current_y))
            surface.blit(text_surf, text_rect); current_y += 35
            
        prompt_surf = self.game.fonts['small'].render("ç‚¹å‡»ä»»æ„å¤„ç»§ç»­...", True, TEXT_COLOR)
        prompt_rect = prompt_surf.get_rect(center=(self.panel_rect.centerx, self.panel_rect.bottom - 40))
        surface.blit(prompt_surf, prompt_rect)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\notification_screen.py
================================================================================

# states/notification_screen.py
import pygame
from .base import BaseState
from ui import draw_text
from settings import *

class NotificationScreen(BaseState):
    def __init__(self, game, message, duration=2.0):
        super().__init__(game)
        self.is_overlay = True
        self.message = message
        self.duration = duration # ç§’
        self.start_time = pygame.time.get_ticks()

    def update(self):
        # è®¡æ—¶ç»“æŸï¼Œè‡ªåŠ¨å…³é—­
        if pygame.time.get_ticks() - self.start_time > self.duration * 1000:
            self.game.state_stack.pop()

    def draw(self, surface):
        # åˆ›å»ºä¸€ä¸ªä½äºå±å¹•åº•éƒ¨ä¸­å¤®çš„å¯¹è¯æ¡†
        box_width = 600
        box_height = 80
        box_rect = pygame.Rect(
            (SCREEN_WIDTH - box_width) / 2,
            SCREEN_HEIGHT - box_height - 30, # ç¦»åº•éƒ¨30åƒç´ 
            box_width,
            box_height
        )
        
        # ç»˜åˆ¶åŠé€æ˜èƒŒæ™¯
        bg_surface = pygame.Surface(box_rect.size, pygame.SRCALPHA)
        bg_surface.fill((20, 35, 50, 200)) # ä½¿ç”¨é¢æ¿èƒŒæ™¯è‰²ï¼Œå¸¦é€æ˜åº¦
        surface.blit(bg_surface, box_rect.topleft)
        pygame.draw.rect(surface, PANEL_BORDER_COLOR, box_rect, 2, border_radius=10)

        # ç»˜åˆ¶æ¶ˆæ¯æ–‡æœ¬
        draw_text(surface, self.message, self.game.fonts['normal'], TEXT_COLOR, box_rect)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\rest_screen.py
================================================================================

# æ–‡ä»¶: states/rest_screen.py (æ–°æ–‡ä»¶)

import pygame
import random
from .base import BaseState
from ui import Button, draw_panel, draw_text
from settings import *

class RestScreen(BaseState):

    def __init__(self, game, origin_room):
        super().__init__(game)
        self.is_overlay = True
        self.origin_room = origin_room

        self.rest_used = False
        self.forge_used = False
        self.feedback_message = ""

        # --- æ ¸å¿ƒä¿®æ”¹åœ¨è¿™é‡Œ ---
        from Equips import UPGRADE_MAP 

        # 1. åˆ›å»ºä¸€ä¸ªåŒ…å«ç©å®¶æ‰€æœ‰ç‰©å“ï¼ˆå·²è£…å¤‡çš„ + èƒŒåŒ…é‡Œçš„ï¼‰çš„æ€»åˆ—è¡¨
        all_player_items = self.game.player.all_equipment + self.game.player.backpack

        # 2. ä»è¿™ä¸ªæ€»åˆ—è¡¨ä¸­ï¼Œç­›é€‰å‡ºæ‰€æœ‰å¯ä»¥è¢«å‡çº§çš„ç‰©å“
        self.upgradable_items = [
            item for item in all_player_items
            if item.__class__ in UPGRADE_MAP
        ]

        self._setup_ui()

    def _setup_ui(self):
        """åˆå§‹åŒ–ç”¨æˆ·ç•Œé¢å…ƒç´ """
        panel_w, panel_h = 800, 500
        self.panel_rect = pygame.Rect((SCREEN_WIDTH - panel_w) / 2, (SCREEN_HEIGHT - panel_h) / 2, panel_w, panel_h)

        # å®šä¹‰ä¸¤ä¸ªæ ¸å¿ƒé€‰é¡¹æŒ‰é’®çš„ä½ç½®
        btn_w, btn_h = 300, 180
        spacing = 50
        start_x = self.panel_rect.centerx - (btn_w * 2 + spacing) / 2

        self.rest_button = Button(
            (start_x, self.panel_rect.centery - btn_h/2, btn_w, btn_h),
            "ä¼‘æ¯", # æŒ‰é’®çš„åˆå§‹æ–‡å­—
            self.game.fonts['large']
        )
        self.forge_button = Button(
            (start_x + btn_w + spacing, self.panel_rect.centery - btn_h/2, btn_w, btn_h),
            "é”»é€ ",
            self.game.fonts['large']
        )
        
        # ç¦»å¼€æŒ‰é’®
        self.leave_button = Button(
            (self.panel_rect.centerx - 150, self.panel_rect.bottom - 100, 300, 60),
            "ç¦»å¼€",
            self.game.fonts['normal']
        )

    def handle_event(self, event):
        """å¤„ç†ç©å®¶çš„è¾“å…¥äº‹ä»¶"""
        # --- ä¼‘æ¯æŒ‰é’®çš„é€»è¾‘ (ä¸å˜) ---
        if not self.rest_used and self.rest_button.handle_event(event):
            self.rest_used = True
            heal_amount = int(self.game.player.max_hp * 0.3)
            self.game.player.heal(heal_amount)
            self.feedback_message = f"ä½ æ¢å¤äº† {heal_amount} ç‚¹ç”Ÿå‘½ï¼"
            self.forge_used = True # ä¼‘æ¯å’Œé”»é€ äºŒé€‰ä¸€
            return

        # --- å…¨æ–°çš„ã€æ›´å¼ºå¤§çš„é”»é€ é€»è¾‘ ---
        if not self.forge_used and len(self.upgradable_items) > 0 and self.forge_button.handle_event(event):
            self.forge_used = True
            self.rest_used = True # ä¼‘æ¯å’Œé”»é€ äºŒé€‰ä¸€

            player = self.game.player

            # 1. ä»å¯å‡çº§åˆ—è¡¨ä¸­éšæœºé€‰ä¸€ä»¶ (ç°åœ¨è¿™ä¸ªåˆ—è¡¨åŒ…å«äº†èƒŒåŒ…ç‰©å“)
            item_to_upgrade = random.choice(self.upgradable_items)
            item_name = getattr(item_to_upgrade, 'display_name', 'è£…å¤‡')

            from Equips import UPGRADE_MAP
            upgraded_class = UPGRADE_MAP.get(item_to_upgrade.__class__)

            if upgraded_class:
                # 2. åˆ›å»ºå‡çº§åçš„æ–°è£…å¤‡å®ä¾‹
                upgraded_item = upgraded_class()

                # 3. ä»åŸæ¥çš„ä½ç½®ç§»é™¤æ—§è£…å¤‡
                #    æ£€æŸ¥å®ƒæ˜¯åœ¨èº«ä¸Šè¿˜æ˜¯åœ¨èƒŒåŒ…é‡Œ
                if item_to_upgrade in player.all_equipment:
                    player.unequip(item_to_upgrade)
                elif item_to_upgrade in player.backpack:
                    player.backpack.remove(item_to_upgrade)

                # 4. å°†é”»é€ å¥½çš„æ–°è£…å¤‡æ”¾å…¥èƒŒåŒ…
                #    æˆ‘ä»¬ä½¿ç”¨ pickup_item æ–¹æ³•ï¼Œå› ä¸ºå®ƒèƒ½è‡ªåŠ¨å¤„ç†é‡å¤ç‰©å“è½¬åŒ–ä¸ºé‡‘å¸çš„é€»è¾‘
                feedback = player.pickup_item(upgraded_item)
                if "æ”¾å…¥ä½ çš„èƒŒåŒ…" in feedback:
                    self.feedback_message = f"é”»é€ æˆåŠŸï¼æ–°çš„ã€Œ{upgraded_item.display_name}ã€å·²æ”¾å…¥ä½ çš„èƒŒåŒ…ï¼"
                else: # å¦‚æœç©å®¶å·²ç»æœ‰å‡çº§ç‰ˆçš„è£…å¤‡äº†ï¼Œä¼šè‡ªåŠ¨è½¬åŒ–æˆé‡‘å¸
                    self.feedback_message = f"é”»é€ æˆåŠŸï¼ä½†ä½ å·²æ‹¥æœ‰åŒåè£…å¤‡ï¼Œè½¬åŒ–ä¸ºé‡‘å¸ï¼"

            else:
                self.feedback_message = f"ã€Œ{item_name}ã€ä¼¼ä¹æ— æ³•è¢«å¼ºåŒ–..."

            return

        # --- å¤„ç†ç¦»å¼€æŒ‰é’® (ä¸å˜) ---
        if self.leave_button.handle_event(event):
            self._leave_room()
            
    def _leave_room(self):
        """å¤„ç†ç¦»å¼€ä¼‘æ¯å®¤çš„é€»è¾‘"""
        from .dungeon_screen import DungeonScreen
        # æ ‡è®°è¿™ä¸ªæˆ¿é—´ä¸ºâ€œå·²æ¢ç´¢å®Œæ¯•â€
        self.origin_room.is_cleared = True
        
        # æ›´æ–°åœ°ç‰¢ç•Œé¢ï¼Œè®©å‡ºå£çš„é—¨æ˜¾ç¤ºå‡ºæ¥
        if len(self.game.state_stack) > 1:
            prev_state = self.game.state_stack[-2]
            if isinstance(prev_state, DungeonScreen):
                prev_state.door_rects = prev_state._generate_doors()
        
        # å°†è‡ªå·±ä»çŠ¶æ€æ ˆä¸­å¼¹å‡ºï¼Œè¿”å›åœ°ç‰¢ç•Œé¢
        self.game.state_stack.pop()

    def draw(self, surface):
        """ç»˜åˆ¶æ‰€æœ‰UIå…ƒç´ åˆ°å±å¹•ä¸Š"""
        # ç»˜åˆ¶åŠé€æ˜çš„èƒŒæ™¯é®ç½©
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))

        # ç»˜åˆ¶ä¸»é¢æ¿
        draw_panel(surface, self.panel_rect, "ç¯ç«æ—çš„ì‰¼í„°", self.game.fonts['large'])

        # --- ç»˜åˆ¶ä¼‘æ¯æŒ‰é’®å’Œæè¿° ---
        self.rest_button.draw(surface)
        rest_desc = "æ¢å¤30%æœ€å¤§ç”Ÿå‘½å€¼"
        rest_desc_rect = self.rest_button.rect.copy()
        rest_desc_rect.y += 190 # è°ƒæ•´æè¿°æ–‡æœ¬çš„ä½ç½®
        draw_text(surface, rest_desc, self.game.fonts['small'], TEXT_COLOR, rest_desc_rect)
        if self.rest_used: # å¦‚æœå·²ä½¿ç”¨ï¼Œç»˜åˆ¶ä¸€ä¸ªé®ç½©
            s = pygame.Surface(self.rest_button.rect.size, pygame.SRCALPHA)
            s.fill((50,50,50,180))
            surface.blit(s, self.rest_button.rect.topleft)

        # --- ç»˜åˆ¶é”»é€ æŒ‰é’®å’Œæè¿° ---
        self.forge_button.draw(surface)
        forge_desc = "éšæœºå¼ºåŒ–ä¸€ä»¶è£…å¤‡"
        if len(self.upgradable_items) == 0:
            forge_desc = "æ²¡æœ‰å¯å¼ºåŒ–çš„è£…å¤‡"
        forge_desc_rect = self.forge_button.rect.copy()
        forge_desc_rect.y += 190
        draw_text(surface, forge_desc, self.game.fonts['small'], TEXT_COLOR, forge_desc_rect)
        if self.forge_used or len(self.upgradable_items) == 0: # å¦‚æœå·²ä½¿ç”¨æˆ–æ²¡æœ‰è£…å¤‡ï¼Œç»˜åˆ¶é®ç½©
            s = pygame.Surface(self.forge_button.rect.size, pygame.SRCALPHA)
            s.fill((50,50,50,180))
            surface.blit(s, self.forge_button.rect.topleft)

        # ç»˜åˆ¶æ“ä½œåé¦ˆä¿¡æ¯
        if self.feedback_message:
            feedback_rect = pygame.Rect(0, self.panel_rect.top + 100, self.panel_rect.width, 40)
            feedback_rect.centerx = self.panel_rect.centerx
            draw_text(surface, self.feedback_message, self.game.fonts['normal'], HOVER_COLOR, feedback_rect)

        # ç»˜åˆ¶ç¦»å¼€æŒ‰é’®
        self.leave_button.draw(surface)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\saving.py
================================================================================

# states/saving.py
import pygame
import time
from .base import BaseState
from ui import draw_text, Button
from settings import *

class SaveScreen(BaseState):
    def __init__(self, game):
        super().__init__(game)
        self.back_button = Button((SCREEN_WIDTH / 2 - 150, SCREEN_HEIGHT - 100, 300, 60), "è¿”å›", self.game.fonts['normal'])
        self.slot_rects = [pygame.Rect(100, 120 + (i-1) * 50, SCREEN_WIDTH - 200, 50) for i in range(1, 10)]
        self.feedback_message = None
        self.feedback_timer = 0

    def update(self):
        if self.feedback_message and pygame.time.get_ticks() - self.feedback_timer > 2000:
            self.feedback_message = None

    def handle_event(self, event):
        if self.back_button.handle_event(event) or (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
            self.game.state_stack.pop()
            return

        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            for i, rect in enumerate(self.slot_rects, 1):
                if rect.collidepoint(event.pos):
                    self.feedback_message = self.game.save_to_slot(i)
                    self.feedback_timer = pygame.time.get_ticks()
                    return

    def draw(self, surface):
        surface.fill(BG_COLOR)
        title_font = self.game.fonts['large']
        draw_text(surface, "é€‰æ‹©è¦è¦†ç›–çš„å­˜æ¡£æ§½", title_font, TEXT_COLOR, pygame.Rect(0, 50, SCREEN_WIDTH, 100))

        for i, rect in enumerate(self.slot_rects, 1):
            slot_data = self.game.peek_save_slot(i) # <-- ä½¿ç”¨ peek_save_slot
            is_hovered = rect.collidepoint(pygame.mouse.get_pos())
            if is_hovered:
                pygame.draw.rect(surface, PANEL_BORDER_COLOR, rect.inflate(10, 10), 2, border_radius=5)
            
            text = f"{i}. "
            if slot_data and slot_data.get("player"):
                player = slot_data["player"]
                save_time = time.strftime('%Y-%m-%d %H:%M', time.localtime(slot_data.get("timestamp", 0)))
                text += f"{player.name} - ç­‰çº§ {player.level} ({save_time})"
            else:
                text += "-- ç©º --"
            draw_text(surface, text, self.game.fonts['normal'], TEXT_COLOR, rect)

        if self.feedback_message:
            feedback_rect = pygame.Rect(0, SCREEN_HEIGHT - 150, SCREEN_WIDTH, 40)
            draw_text(surface, self.feedback_message, self.game.fonts['normal'], (100, 255, 100), feedback_rect)
        
        self.back_button.draw(surface)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\shop_screen.py
================================================================================

# states/shop_screen.py (å·²æ›´æ–°)
import pygame
import random
import inspect # <-- 1. å¯¼å…¥ inspect æ¨¡å— (Tooltip éœ€è¦)
from .base import BaseState
from ui import Button, draw_panel, draw_text, TooltipManager # <-- 2. å¯¼å…¥ TooltipManager
from settings import *
import Equips

RARITY_PRICES = {"common": 50, "uncommon": 100, "rare": 250, "epic": 500, "legendary": 1000}

class ShopScreen(BaseState):
    def __init__(self, game, origin_room):
        super().__init__(game)
        self.is_overlay = True
        self.origin_room = origin_room
        self.shop_items = []
        self.feedback_message = ""
        self.feedback_timer = 0
        
        # <-- 3. åœ¨ __init__ ä¸­ï¼Œåˆå§‹åŒ– TooltipManager -->
        self.tooltip_manager = TooltipManager(self.game.fonts['small'])
        
        self._generate_inventory()
        self._setup_ui()

    def _generate_inventory(self):
        all_item_classes = [getattr(Equips, name) for name in dir(Equips) if isinstance(getattr(Equips, name), type) and issubclass(getattr(Equips, name), Equips.Equipment) and getattr(Equips, name) is not Equips.Equipment]
        choices = random.sample(all_item_classes, min(3, len(all_item_classes)))
        for item_class in choices:
            item = item_class()
            rarity = getattr(item, 'rarity', 'common')
            price = RARITY_PRICES.get(rarity, 9999)
            self.shop_items.append([None, item, price, False])

    def _setup_ui(self):
        panel_w, panel_h = 900, 600
        self.panel_rect = pygame.Rect((SCREEN_WIDTH - panel_w) / 2, (SCREEN_HEIGHT - panel_h) / 2, panel_w, panel_h)
        card_w, card_h, spacing = 250, 400, 25
        start_x = self.panel_rect.centerx - (card_w * len(self.shop_items) + spacing * (len(self.shop_items) - 1)) / 2
        
        for i, item_tuple in enumerate(self.shop_items):
            card_x = start_x + i * (card_w + spacing)
            card_rect = pygame.Rect(card_x, self.panel_rect.y + 120, card_w, card_h)
            button = Button(card_rect, "", self.game.fonts['normal'])
            item_tuple[0] = button
            
        leave_rect = pygame.Rect(self.panel_rect.centerx - 150, self.panel_rect.bottom - 80, 300, 60)
        self.leave_button = Button(leave_rect, "ç¦»å¼€å•†åº—", self.game.fonts['normal'])

    def handle_event(self, event):
        # ... (handle_event é€»è¾‘ä¿æŒä¸å˜) ...
        if self.leave_button.handle_event(event):
            self.origin_room.is_cleared = True
            from .dungeon_screen import DungeonScreen
            if len(self.game.state_stack) > 1 and isinstance(self.game.state_stack[-2], DungeonScreen):
                self.game.state_stack[-2].door_rects = self.game.state_stack[-2]._generate_doors()
            self.game.state_stack.pop()
            return
        for button, item, price, is_sold in self.shop_items:
            if not is_sold and button.handle_event(event):
                if self.game.player.gold >= price:
                    self.game.player.gold -= price
                    feedback = self.game.player.pickup_item(item)
                    if feedback:
                        from .notification_screen import NotificationScreen
                        self.game.state_stack.append(NotificationScreen(self.game, feedback))
                    self.feedback_message = f"æˆåŠŸè´­ä¹° {getattr(item, 'display_name', 'ç‰©å“')}ï¼"
                    self.shop_items[self.shop_items.index([button, item, price, is_sold])][3] = True
                else:
                    self.feedback_message = "é‡‘å¸ä¸è¶³ï¼"
                self.feedback_timer = pygame.time.get_ticks()
                return

    def update(self):
        if self.feedback_message and pygame.time.get_ticks() - self.feedback_timer > 2000:
            self.feedback_message = ""

        # <-- 4. åœ¨ update ä¸­ï¼Œæ·»åŠ æ‚¬åœæ£€æµ‹é€»è¾‘ -->
        hovered_item = None
        mouse_pos = pygame.mouse.get_pos()
        for button, item, price, is_sold in self.shop_items:
            if button.rect.collidepoint(mouse_pos):
                hovered_item = item
                break
        self.tooltip_manager.update(hovered_item)


    def draw(self, surface):
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180)); surface.blit(overlay, (0, 0))
        draw_panel(surface, self.panel_rect, "ç¥ç§˜å•†åº—", self.game.fonts['large'])
        
        gold_text = f"ä½ çš„é‡‘å¸: {self.game.player.gold} G"
        gold_surf = self.game.fonts['normal'].render(gold_text, True, (255, 215, 0))
        gold_rect = gold_surf.get_rect(right=self.panel_rect.right - 30, top=self.panel_rect.top + 20)
        surface.blit(gold_surf, gold_rect)

        for button, item, price, is_sold in self.shop_items:
            rarity = getattr(item, 'rarity', 'common')
            color = RARITY_COLORS.get(rarity, (255,255,255))
            
            bg_color = PANEL_BORDER_COLOR if button.is_hovered and not is_sold else PANEL_BG_COLOR
            pygame.draw.rect(surface, bg_color, button.rect, border_radius=10)
            pygame.draw.rect(surface, color if not is_sold else (80,80,80), button.rect, 2, border_radius=10)
            
            name = getattr(item, 'display_name', 'ç‰©å“')
            name_surf = self.game.fonts['normal'].render(name, True, color if not is_sold else (120,120,120))
            name_rect = name_surf.get_rect(centerx=button.rect.centerx, top=button.rect.top + 20)
            surface.blit(name_surf, name_rect)

            # ç»˜åˆ¶ç‰©å“æè¿°ï¼ˆè¿™é‡Œç”¨ tooltip ä»£æ›¿ï¼Œæ‰€ä»¥å¯ä»¥ç•™ç©ºæˆ–ç”»ä¸ªå›¾ï¼‰
            
            price_text = "å·²å”®ç½„" if is_sold else f"è´­ä¹° ({price} G)"
            price_color = (150,150,150) if is_sold else TEXT_COLOR
            price_rect_area = pygame.Rect(button.rect.x, button.rect.bottom - 70, button.rect.width, 70)
            draw_text(surface, price_text, self.game.fonts['normal'], price_color, price_rect_area)

        self.leave_button.draw(surface)
        if self.feedback_message:
             feedback_rect = pygame.Rect(0, self.panel_rect.top + 80, self.panel_rect.width, 30)
             feedback_rect.centerx = self.panel_rect.centerx
             draw_text(surface, self.feedback_message, self.game.fonts['small'], HOVER_COLOR, feedback_rect)

        # <-- 5. åœ¨ draw çš„æœ«å°¾ï¼Œç»˜åˆ¶æ‚¬åœæç¤º -->
        self.tooltip_manager.draw(surface)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\story.py
================================================================================

# states/story.py (å·²æ›´æ–°)
import pygame
from .base import BaseState
from .dungeon_screen import DungeonScreen
from .saving import SaveScreen
from .loading import LoadScreen
# <-- å¯¼å…¥ Button ç±»
from ui import draw_text, Button
from settings import *

class StoryScreen(BaseState):
    def __init__(self, game):
        super().__init__(game)
        # <-- é‡æ–°å¸ƒå±€ï¼Œä¸ºâ€œèƒŒåŒ…â€æŒ‰é’®è…¾å‡ºç©ºé—´
        button_w, button_h = 120, 40
        padding = 15
        # ä»å³å¾€å·¦ä¾æ¬¡æ˜¯ ä¿å­˜ -> åŠ è½½ -> èƒŒåŒ…
        save_rect = pygame.Rect(SCREEN_WIDTH - padding - button_w, SCREEN_HEIGHT - padding - button_h - 250, button_w, button_h)
        load_rect = pygame.Rect(save_rect.left - padding - button_w, save_rect.top, button_w, button_h)
        # <-- æ–°å¢èƒŒåŒ…æŒ‰é’®çš„ä½ç½®
        backpack_rect = pygame.Rect(load_rect.left - padding - button_w, load_rect.top, button_w, button_h)
        
        self.buttons = {
            "save": Button(save_rect, "ä¿å­˜(S)", self.game.fonts['small']),
            "load": Button(load_rect, "åŠ è½½(L)", self.game.fonts['small']),
            # <-- å°†æ–°æŒ‰é’®æ·»åŠ åˆ°å­—å…¸ä¸­
            "backpack": Button(backpack_rect, "èƒŒåŒ…(B)", self.game.fonts['small'])
        }
        self._initialize_story()

    def _initialize_story(self):
        # ... (æ­¤æ–¹æ³•ä¿æŒä¸å˜)
        start_index = getattr(self.game, "loaded_dialogue_index", 0)
        self.dialogue_index = start_index
        self.displayed_chars = 0
        self.typing_complete = False
        self.last_char_time = 0
        self.typewriter_speed = 30
        self.game.loaded_dialogue_index = 0

    def update(self):
        # ... (æ­¤æ–¹æ³•ä¿æŒä¸å˜)
        if not self.typing_complete:
            now = pygame.time.get_ticks()
            if now - self.last_char_time > self.typewriter_speed:
                stage_data = self.game.story_data.get(self.game.current_stage, {})
                dialogue_list = stage_data.get("text", [])
                if not dialogue_list or self.dialogue_index >= len(dialogue_list):
                    self.typing_complete = True
                    return
                line = dialogue_list[self.dialogue_index].get("line", "")
                if self.displayed_chars < len(line):
                    self.displayed_chars += 1
                    self.last_char_time = now
                else:
                    self.typing_complete = True
    
    def handle_event(self, event):
        from states.backpack import BackpackScreen # <-- ç¡®ä¿å¯¼å…¥
        
        # <-- ç°åœ¨å¯ä»¥ç›´æ¥è°ƒç”¨æŒ‰é’®çš„ handle_event æ–¹æ³•
        if self.buttons['save'].handle_event(event):
            self.game.state_stack.append(SaveScreen(self.game))
            return
        if self.buttons['load'].handle_event(event):
            self.game.state_stack.append(LoadScreen(self.game))
            return
        # <-- æ–°å¢ï¼šå¤„ç†èƒŒåŒ…æŒ‰é’®ç‚¹å‡»äº‹ä»¶
        if self.buttons['backpack'].handle_event(event):
            self.game.state_stack.append(BackpackScreen(self.game))
            return

        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            # é¿å…ç‚¹å‡»æŒ‰é’®æ—¶ä¹Ÿè§¦å‘å¯¹è¯å‰è¿›
            is_over_button = any(btn.rect.collidepoint(event.pos) for btn in self.buttons.values())
            if not is_over_button:
                self._advance_dialogue()
        
        if event.type == pygame.KEYDOWN:
            if event.key in [pygame.K_RETURN, pygame.K_SPACE]:
                self._advance_dialogue()
            elif event.key == pygame.K_s:
                self.game.state_stack.append(SaveScreen(self.game))
            elif event.key == pygame.K_l:
                self.game.state_stack.append(LoadScreen(self.game))
            elif event.key == pygame.K_b:
                self.game.state_stack.append(BackpackScreen(self.game))
    
# åœ¨ states/story.py æ–‡ä»¶ä¸­ï¼Œæ‰¾åˆ°å¹¶æ›¿æ¢è¿™ä¸ªå‡½æ•°

    def _advance_dialogue(self):
        from states.combat import CombatScreen
        from states.title import TitleScreen
        from states.dungeon_screen import DungeonScreen

        stage_data = self.game.story_data.get(self.game.current_stage)
        if not stage_data:
            print(f"é”™è¯¯: æ‰¾ä¸åˆ°å‰§æƒ…ID: {self.game.current_stage}")
            self.game.state_stack = [TitleScreen(self.game)]
            return
            
        dialogue_list = stage_data.get("text", [])

        # å¦‚æœæ‰“å­—æœºæ•ˆæœè¿˜æ²¡ç»“æŸï¼Œå°±ç«‹åˆ»å®Œæˆå®ƒ
        if not self.typing_complete:
            self.typing_complete = True
            # å®‰å…¨æ£€æŸ¥ï¼Œé˜²æ­¢ç©ºå¯¹è¯åˆ—è¡¨
            if self.dialogue_index < len(dialogue_list):
                current_line = dialogue_list[self.dialogue_index].get("line", "")
                self.displayed_chars = len(current_line)
            return

        # --- æ ¸å¿ƒä¿®å¤ï¼šå…ˆæ£€æŸ¥æ˜¯å¦åº”è¯¥æ¨è¿›ï¼Œå†å¤„ç† ---
        # æ£€æŸ¥å½“å‰å¯¹è¯è¡Œæ˜¯å¦æœ‰action
        if self.dialogue_index < len(dialogue_list):
            current_dialogue = dialogue_list[self.dialogue_index]
            # æ–‡ä»¶: states/story.py (_advance_dialogue æ–¹æ³•å†…)
            action = current_dialogue.get("action")
            if action == "start_trial":
                self.game.state_stack.pop()
                # --- æ ¸å¿ƒä¿®æ”¹åœ¨è¿™é‡Œ ---
                # æ—§ä»£ç : self.game.state_stack.append(DungeonScreen(self.game))
                # æ–°ä»£ç ï¼šæ˜ç¡®å‘Šè¯‰DungeonScreenè¦åŠ è½½å“ªä¸ªåœ°ç‰¢çš„ç¬¬1å±‚
                self.game.state_stack.append(DungeonScreen(self.game, "sunstone_ruins", 1))
                return

        # æ¨è¿›åˆ°ä¸‹ä¸€å¥å¯¹è¯
        self.dialogue_index += 1

        # --- åœ¨è¿™é‡Œæ£€æŸ¥æ˜¯å¦ç»“æŸ ---
        if self.dialogue_index >= len(dialogue_list):
            # æ‰€æœ‰å¯¹è¯éƒ½ç»“æŸäº†ï¼Œè¿›å…¥ä¸‹ä¸€ä¸ªstage
            self.game.current_stage = stage_data.get("next", "quit")
            if self.game.current_stage == "quit":
                self.game.state_stack = [TitleScreen(self.game)]
                return
            
            next_stage_data = self.game.story_data.get(self.game.current_stage, {})
            if next_stage_data.get("type") == "combat":
                enemy_id = next_stage_data.get("enemy_id", "slime")
                self.game.state_stack.pop()
                self.game.state_stack.append(CombatScreen(self.game, enemy_id))
            else:
                self._initialize_story() # é‡ç½®å¯¹è¯çŠ¶æ€ä»¥å‡†å¤‡ä¸‹ä¸€ä¸ªstory stage
        else:
            # å¦‚æœè¿˜æœ‰ä¸‹ä¸€å¥ï¼Œåˆ™é‡ç½®æ‰“å­—æœº
            self.displayed_chars = 0
            self.typing_complete = False
            self.last_char_time = 0

    def draw(self, surface):
        surface.fill(BG_COLOR)
        dialogue_box_rect = pygame.Rect(50, SCREEN_HEIGHT - 250, SCREEN_WIDTH - 100, 200)
        pygame.draw.rect(surface, PANEL_BG_COLOR, dialogue_box_rect, border_radius=10)
        pygame.draw.rect(surface, PANEL_BORDER_COLOR, dialogue_box_rect, 3, border_radius=10)

        # ... (å¯¹è¯æ¡†å’Œæ–‡æœ¬ç»˜åˆ¶é€»è¾‘ä¿æŒä¸å˜) ...
        stage_data = self.game.story_data.get(self.game.current_stage, {})
        dialogue_list = stage_data.get("text", [{"speaker": "é”™è¯¯", "line": "æœªæ‰¾åˆ°å‰§æƒ…æ–‡æœ¬"}])
        safe_index = min(self.dialogue_index, len(dialogue_list) - 1)
        dialogue = dialogue_list[safe_index]
        speaker, full_line = dialogue["speaker"], dialogue["line"]
        if speaker != "æ—ç™½":
            speaker_text_surf = self.game.fonts['normal'].render(speaker, True, TEXT_COLOR)
            speaker_panel_rect = speaker_text_surf.get_rect(topleft=(dialogue_box_rect.left + 30, dialogue_box_rect.top - 35))
            speaker_panel_rect.inflate_ip(20, 10)
            pygame.draw.rect(surface, PANEL_BG_COLOR, speaker_panel_rect, border_radius=5)
            pygame.draw.rect(surface, PANEL_BORDER_COLOR, speaker_panel_rect, 2, border_radius=5)
            surface.blit(speaker_text_surf, (speaker_panel_rect.x + 10, speaker_panel_rect.y + 5))
        text_to_render = full_line[:self.displayed_chars]
        text_rect = dialogue_box_rect.inflate(-40, -40)
        draw_text(surface, text_to_render, self.game.fonts['normal'], TEXT_COLOR, text_rect)
        if self.typing_complete:
            prompt_pos = (dialogue_box_rect.right - 40, dialogue_box_rect.bottom - 40)
            pygame.draw.polygon(surface, TEXT_COLOR, [prompt_pos, (prompt_pos[0] - 20, prompt_pos[1]), (prompt_pos[0] - 10, prompt_pos[1] - 15)])
        
        # <-- ç»˜åˆ¶ä¼šè‡ªåŠ¨åŒ…å«æ–°æŒ‰é’®ï¼Œæ— éœ€ä¿®æ”¹
        for button in self.buttons.values():
            button.draw(surface)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\talents_screen.py
================================================================================

# states/talents_screen.py
import pygame
import inspect
from .base import BaseState
from ui import draw_panel, draw_text, Button, get_display_name, TooltipManager
from settings import *

class TalentsScreen(BaseState):
    def __init__(self, game):
        super().__init__(game)
        self.is_overlay = True
        self.dragging_talent = None
        self.dragging_from = None # 'equipped' or 'learned'
        
        self._setup_layout()
        self.tooltip_manager = TooltipManager(self.game.fonts['small'])

    def _setup_layout(self):
        """è®¾ç½®UIå¸ƒå±€ï¼Œåˆ†ä¸ºå·¦å³ä¸¤ä¸ªåŒºåŸŸ"""
        margin, header_height = 40, 80
        self.container_rect = pygame.Rect(margin, margin, SCREEN_WIDTH - 2*margin, SCREEN_HEIGHT - 2*margin)
        self.header_rect = pygame.Rect(self.container_rect.x, self.container_rect.y, self.container_rect.width, header_height)
        
        content_y = self.header_rect.bottom + 10
        content_height = self.container_rect.height - header_height - 10
        
        # å·¦ä¾§ï¼šå·²è£…å¤‡å¤©èµ‹
        self.equipped_panel_rect = pygame.Rect(self.container_rect.x, content_y, 350, content_height)
        # å³ä¾§ï¼šå¤©èµ‹åº“
        self.learned_panel_rect = pygame.Rect(self.equipped_panel_rect.right + 10, content_y, self.container_rect.right - self.equipped_panel_rect.right - 10, content_height)
        
        self.close_button = Button(pygame.Rect(self.container_rect.right - 45, self.container_rect.top + 10, 35, 35), "X", self.game.fonts['normal'])

    def handle_event(self, event):
        if self.close_button.handle_event(event) or (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE):
            if self.dragging_talent: self._return_dragging_talent()
            self.game.state_stack.pop(); return
            
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1: self._handle_mouse_down(event.pos)
        if event.type == pygame.MOUSEBUTTONUP and event.button == 1: self._handle_mouse_up(event.pos)

    def _handle_mouse_down(self, pos):
        """å¤„ç†é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶ï¼Œè´Ÿè´£â€œæ‹¾èµ·â€å¤©èµ‹"""
        if self.dragging_talent: return
        
        # æ£€æŸ¥æ˜¯å¦ä»â€œå·²è£…å¤‡â€åŒºåŸŸæ‹¾èµ·
        for i, talent in enumerate(self.game.player.equipped_talents):
            rect = self._get_talent_rect(i, 'equipped')
            if rect.collidepoint(pos):
                self.dragging_talent, self.dragging_from = talent, 'equipped'
                self.game.player.unequip_talent(talent) # æ‹¾èµ·æ—¶ç«‹åˆ»å¸ä¸‹
                return
        
        # æ£€æŸ¥æ˜¯å¦ä»â€œå¤©èµ‹åº“â€åŒºåŸŸæ‹¾èµ·
        unequipped = [t for t in self.game.player.learned_talents if t not in self.game.player.equipped_talents]
        for i, talent in enumerate(unequipped):
            rect = self._get_talent_rect(i, 'learned')
            if rect.collidepoint(pos):
                self.dragging_talent, self.dragging_from = talent, 'learned'
                return

    # æ–‡ä»¶: states/talents_screen.py (æ›¿æ¢è¿™ä¸ªå‡½æ•°)

    def _handle_mouse_up(self, pos):
        if not self.dragging_talent: return

        talent_to_place = self.dragging_talent
        source_type = self.dragging_from
        self.dragging_talent, self.dragging_from = None, None

        # æ£€æŸ¥æ˜¯å¦æ”¾ç½®åœ¨â€œå·²è£…å¤‡â€åŒºåŸŸ
        for i in range(self.game.player.max_talent_slots):
            rect = self._get_talent_rect(i, 'equipped')
            if rect.collidepoint(pos):

                # è·å–ç›®æ ‡æ§½ä½åŸæœ‰çš„å¤©èµ‹
                target_talent = None
                if i < len(self.game.player.equipped_talents):
                    target_talent = self.game.player.equipped_talents[i]

                # å¦‚æœç›®æ ‡æ§½ä½æœ‰å¤©èµ‹ï¼Œå…ˆå¸ä¸‹å®ƒ
                if target_talent:
                    self.game.player.unequip_talent(target_talent)

                # å°è¯•è£…å¤‡æ­£åœ¨æ‹–æ‹½çš„å¤©èµ‹
                success = self.game.player.equip_talent(talent_to_place)

                if success:
                    # å¦‚æœè£…å¤‡æˆåŠŸï¼Œå¹¶ä¸”åŸç›®æ ‡æ§½ä½æœ‰å¤©èµ‹ï¼Œå¹¶ä¸”æ‹–æ‹½çš„å¤©èµ‹æ¥è‡ªå·²è£…å¤‡åŒº
                    # é‚£ä¹ˆè¿™å°±æ˜¯ä¸€æ¬¡â€œäº¤æ¢â€ï¼ŒæŠŠç›®æ ‡å¤©èµ‹è£…å¤‡å›å» (equip_talentä¼šè‡ªåŠ¨æ‰¾åˆ°ç©ºä½)
                    if target_talent and source_type == 'equipped':
                        self.game.player.equip_talent(target_talent)
                else:
                    # å¦‚æœè£…å¤‡å¤±è´¥ï¼ŒæŠŠæ‰€æœ‰ä¸œè¥¿éƒ½é€å›åŸå¤„
                    self._return_dragging_talent(talent_to_place) # é€å›æ‹–æ‹½å¤©èµ‹
                    if target_talent: # é€å›ç›®æ ‡å¤©èµ‹
                        self.game.player.equip_talent(target_talent)

                self.game.player.recalculate_stats()
                return

        # å¦‚æœæ”¾åœ¨å…¶ä»–ä»»ä½•åœ°æ–¹ï¼Œè§†ä¸ºå¸ä¸‹ (å³è¿”å›åŸå¤„)
        self._return_dragging_talent(talent_to_place)
        self.game.player.recalculate_stats()
        
    def _return_dragging_talent(self, talent):
        """åœ¨æ‹–æ‹½è¢«å–æ¶ˆæˆ–å¤±è´¥æ—¶ï¼Œå°†å¤©èµ‹é€å›åŸå¤„"""
        if self.dragging_from == 'equipped':
            self.game.player.equip_talent(talent)

    def update(self):
        """æ›´æ–°æ‚¬æµ®æç¤º"""
        if self.dragging_talent: self.tooltip_manager.update(None); return
        hovered_talent = None
        mouse_pos = pygame.mouse.get_pos()
        
        all_panels = [('equipped', self.game.player.equipped_talents), 
                      ('learned', [t for t in self.game.player.learned_talents if t not in self.game.player.equipped_talents])]

        for panel_type, talent_list in all_panels:
            for i, talent in enumerate(talent_list):
                rect = self._get_talent_rect(i, panel_type)
                if rect.collidepoint(mouse_pos):
                    hovered_talent = talent; break
            if hovered_talent: break
        
        self.tooltip_manager.update(hovered_talent)

    def _get_talent_rect(self, index, panel_type):
        """è®¡ç®—æŒ‡å®šç´¢å¼•çš„å¤©èµ‹åœ¨å“ªä¸ªä½ç½®"""
        panel_rect = self.equipped_panel_rect if panel_type == 'equipped' else self.learned_panel_rect
        padding = 20
        item_size, spacing = 60, 10
        cols = (panel_rect.width - 2 * padding + spacing) // (item_size + spacing)
        
        col = index % cols
        row = index // cols
        
        x = panel_rect.left + padding + col * (item_size + spacing)
        y = panel_rect.top + 100 + row * (item_size + spacing)
        return pygame.Rect(x, y, item_size, item_size)

    def draw(self, surface):
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA); overlay.fill((0, 0, 0, 180)); surface.blit(overlay, (0, 0))
        draw_panel(surface, self.container_rect, "å¤©èµ‹ç®¡ç†", self.game.fonts['large'])
        
        self._draw_equipped_panel(surface)
        self._draw_learned_panel(surface)
        self._draw_dragging_talent(surface)
        
        self.close_button.draw(surface)
        self.tooltip_manager.draw(surface)

    def _draw_equipped_panel(self, surface):
        player = self.game.player
        title = f"å·²è£…å¤‡ ({len(player.equipped_talents)}/{player.max_talent_slots})"
        title_rect = self.equipped_panel_rect.copy(); title_rect.height = 50; title_rect.move_ip(0, 40)
        draw_text(surface, title, self.game.fonts['normal'], TEXT_COLOR, title_rect)

        for i in range(player.max_talent_slots):
            rect = self._get_talent_rect(i, 'equipped')
            pygame.draw.rect(surface, (20, 30, 40, 150), rect, border_radius=8)
            pygame.draw.rect(surface, (70, 80, 100, 180), rect, 2, border_radius=8)
            
            if i < len(player.equipped_talents):
                talent = player.equipped_talents[i]
                if talent is not self.dragging_talent:
                    talent_text = talent.display_name[:2] # æ˜¾ç¤ºå¤©èµ‹å‰ä¸¤ä¸ªå­—
                    draw_text(surface, talent_text, self.game.fonts['normal'], TEXT_COLOR, rect)

    def _draw_learned_panel(self, surface):
        title_rect = self.learned_panel_rect.copy(); title_rect.height = 50; title_rect.move_ip(0, 40)
        draw_text(surface, "å¤©èµ‹åº“", self.game.fonts['normal'], TEXT_COLOR, title_rect)
        
        unequipped = [t for t in self.game.player.learned_talents if t not in self.game.player.equipped_talents]
        
        # ç»˜åˆ¶æ‰€æœ‰å·²å­¦ä¹ çš„å¤©èµ‹æ ¼å­
        for i, talent in enumerate(unequipped):
            if talent is not self.dragging_talent:
                rect = self._get_talent_rect(i, 'learned')
                pygame.draw.rect(surface, PANEL_BG_COLOR, rect, border_radius=8)
                pygame.draw.rect(surface, PANEL_BORDER_COLOR, rect, 2, border_radius=8)
                talent_text = talent.display_name[:2]
                draw_text(surface, talent_text, self.game.fonts['normal'], TEXT_COLOR, rect)

    def _draw_dragging_talent(self, surface):
        if self.dragging_talent:
            mouse_pos = pygame.mouse.get_pos()
            name = get_display_name(self.dragging_talent)
            font = self.game.fonts['normal']
            text_surf = font.render(name, True, TEXT_COLOR)
            rect = text_surf.get_rect(center=mouse_pos)
            
            bg_rect = rect.inflate(20, 12)
            pygame.draw.rect(surface, PANEL_BG_COLOR, bg_rect, border_radius=8)
            pygame.draw.rect(surface, PANEL_BORDER_COLOR, bg_rect, 2, border_radius=8)
            surface.blit(text_surf, rect)


================================================================================
### æ–‡ä»¶è·¯å¾„: states\title.py
================================================================================

# states/title.py
import pygame
from .base import BaseState
from .loading import LoadScreen
from ui import Button
from settings import *

class TitleScreen(BaseState):
    def __init__(self, game):
        super().__init__(game)
        self.buttons = {
            "new_game": Button((SCREEN_WIDTH / 2 - 150, 300, 300, 60), "æ–°æ¸¸æˆ", self.game.fonts['normal']),
            "continue_game": Button((SCREEN_WIDTH / 2 - 150, 400, 300, 60), "ç»§ç»­æ¸¸æˆ", self.game.fonts['normal']),
            "load_game": Button((SCREEN_WIDTH / 2 - 150, 500, 300, 60), "åŠ è½½æ¸¸æˆ", self.game.fonts['normal']),
        }
    
    def handle_event(self, event):
        from states.story import StoryScreen # <-- Import ç§»è‡³æ­¤å¤„
        if self.buttons['new_game'].handle_event(event):
            self.game.start_new_game()
            self.game.state_stack.append(StoryScreen(self.game))
        
        elif self.buttons['continue_game'].handle_event(event):
            if self.game.load_from_slot(0):
                self.game.state_stack.append(StoryScreen(self.game))
            else:
                self.game.start_new_game()
                self.game.state_stack.append(StoryScreen(self.game))

        elif self.buttons['load_game'].handle_event(event):
            self.game.state_stack.append(LoadScreen(self.game))

        if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
            self.game.running = False # åœ¨ä¸»èœå•æŒ‰ESCåˆ™é€€å‡º

    def draw(self, surface):
        surface.fill(BG_COLOR)
        title_surf = self.game.fonts['large'].render("æˆ‘çš„æˆ˜æ–—æ¸¸æˆ", True, TEXT_COLOR)
        title_rect = title_surf.get_rect(center=(SCREEN_WIDTH / 2, 150))
        surface.blit(title_surf, title_rect)
        for button in self.buttons.values():
            button.draw(surface)


